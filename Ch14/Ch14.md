
## Encrypting your data

There are three states of data. Data in transit, when it flows through the network. Data in use, when it is actively being
read and modified and data at rest, which refers to data that is stored in stable storage. In the previous chapter, we discussed
securing your data in transit using TLS 1.2 and strong encryption. In this chapter, we are going to focus on securing your data
at rest. 

Some data is intrinsically public in nature, a press release, for example. Some data is _very_ private, such as healthcare, 
financial, personally identifying, etc. A part of any security consideration is the notion of a defense in depth. Even if your
servers are protected (physically and virtually), you still need to consider the case that someone will be able to get their
hands on your data.

RavenDB supports strong encryption (`XChaCha20Poly1305` with 256 bits key) to do full and transparent data encryption of your
entire database. This feature ensures that nothing unencrypted is written to the disk and even in memory, outside of a running
transaction, everything is encrypted. 

In many industries, data encryption is a regulatory requirement (PCI and HIPPA come to mind) and it is a fairly routine 
request even if the application in question doesn't _require_ it, but can benefit from the additional safeties it provides. 
The encryption of data at rest doesn't come to replace other security measures (such as limit access to your database, encrypting
the communication lines, protecting your access credentials, etc) but to complement them. 

The major advantage of having encryption at the database level is that you don't need to change anything in your applications 
and clients. RavenDB will take care of all encryption behind the scenes, with no external changes that you have to deal with. 
A user that has access to an encrypted database can simply access it, query documents, modify them, etc. RavenDB will take 
care of encrypting and decrypting data as needed. RavenDB also requires all encrypted database access to use HTTPS, so this takes
care of the data in transit portion as well. 

> **What database encryption does _not_ protect you from?**
> 
> Encrypting the database means that if you open your database file, the data inside it will appear indistinguishable from random
> noise, unless you have the key. This means that if you lost a hard disk, you can be sure that the data on it will not be accessible.
> But that is just one threat vector.
>
> Encrypting the database will not protect you from lost credentials. If that user has permissions for the
> database in question, RavenDB will decrypt the information from the disk and hand it over to this authorized user.
> 
> Such encryption will also only place a few hurdles in the path of someone that is able to execute code on the database machine
> as the database user or as `root`, because they will be able to connect to RavenDB using the `rvn admin-channel` and register
> a certificate, then just access the data normally. 

RavenDB goes to great lengths to ensure that on disk, and even in memory, your data is encrypted. The data is only decrypted when
there is an active transaction, and even then, only the pieces that are touched by that transaction are decrypted. Once the 
transaction is completed, RavenDB will zero the memory to erase the sensitive data. 

Database encryption should be deployed as part of comprehensive security strategy, including control access to the machines, 
having a secure backup strategy, including security concerns with your high availability and offsite deployment, key management, and the appropriate audit / monitoring tools. This is a much wider topic than can be covered in this book, so I'll focus only
on the details of data encryption in RavenDB.

Before we get to the details, I want to mention that encryption has a cost. In terms of the database performance, it is usually
around 15% - 20%, depending on the exact load. In most cases, that is a perfectly fine price to pay for the additional security.
However, there are also additional costs in managing encrypted databases. Key management and backup, secure backups, being able 
to _get_ the encryption key when you need to restore the database, etc. 

All of these can add up to significant operational overhead, as much as RavenDB attempts to reduce it. I suggest ensuring  that
you need the benefits of database encryption before enabling this feature, rather than just saying "encryption is good" and 
pressing forward needlessly. 

We'll start by doing a walkthrough of actually defining an encrypted database through the studio, to get you started, and then
we'll dive into what is actually going on behind the scenes and how RavenDB is actively protecting your data.

### Setting up an encrypted database

The first requirement for an encrypted database is that your cluster will run in a secured mode. There is no point is securing
the data on disk if anyone on the network can see the data going in and out. In the [previous chapter](#security) we went over 
the steps required for a such a setup, so I'll skip them here. 

A database in RavenDB can be marked as encrypted at creation time. You can see how this looks like in the studio in Figure 14.1.

![Creating an encrypted database](./Ch14/img01.png)

An encrypted database uses a 256 bits key to encrypt all the data stored in the database. Without that key, the data in the 
database is only so much random seeming noise. As you can imagine, that key is _important_. RavenDB also provides no way to 
get the encryption key of an existing database, you have to know that in advance. The properties of the key are also important.
The key is a 256 bits value, generated using a cryptographically strong random number generator. You _can_ provide your own key,
but in general, there is little reason to bother. 

What you should be doing is keep a copy of the encryption key somewhere, so you'll have access to this key (and thus, the 
database using it) later on if needed. RavenDB make such a decision explicit, as you can see in Figure 14.2. 

![Encryption configuration includes just the key, and require that you'll store a copy of it](./Ch14/img02.png)

You have to confirm that you have made sure that you have a copy of the key. For convenience's sake, RavenDB offers the ability
to print the key (as well as it's QR code). The idea here is that you print this page, and then file it away in a locked 
cupboard somewhere. Even the most sophisticated of computer attacks will have a hard time reaching to information stored on
paper, and that is a method that can easily be implemented. 

Of course, in many organizations, there is already some policy around encryption keys usage, storage, and backup. Sometimes it 
is with Hardware Security Modules, sometimes using services such as vault such as the Azure Vault, Keywhiz, and HashiCorp Vault.
Regardless, you should have a copy of the encryption key.

> **What can an admin do with the encryption key?**
>
> Given the emphasis I just placed on the admin holding a copy of the encryption key, you might think that you'll be often
> using it. That cannot be further from the truth. There are _no_ cases where it is needed during normal operations. The
> encryption key is needed when you restore from a snapshot backup if the machine is lost and you need to move the data
> to another machine (which must be provided with the key) and if you want to add a new node to the encrypted database
> group and want all the nodes to use the same key (which is desired, but not required).

Another requirement for encrypted databases is that the admin _has_ to select what nodes should be part of the encrypted database
group. Usually, RavenDB will select these based on its own cognizance, but for encrypted databases, an admin needs to specify that
directly. This is to handle such cases where you have severs that might have different security zones in the same cluster. 

> **Storing the encryption keys**
> 
> Only the nodes actually participating in the database group will have the encryption key for that database. At encrypted
> database creation time, RavenDB will contact each of the nodes that will host the database and give them the encryption
> key to use. This is done over an encrypted HTTPS request, of course.
> 
> For this reason, you need to select the nodes that will participate manually and they must be up and available during the 
> database creation time so they can accept the new key.

Once the database is created, this is pretty much it, as far as deviations from the standard usage and configuration of databases
are concerned. 

### Full database encryption

Caesar, about 21 centuries ago, used a cipher to send messages securely, by shifting the letters of his messages by 3 characters.
When most of the population was illiterate, that was probably sufficient security. Today, the science of cryptography and 
cryptoanalysis is a _bit_ more complex.

The goal of encryption is to take an input and a key, and then generate a random-looking pattern of bytes, with no
way to go back to the original input with having the key. That is only part of what a good encryption scheme must deal with 
today, though. Modern cryptography needs to handle such things as timing (and other side channels) attack, forward secrecy,
authenticated encryption and many other details that are crucial for the security of the system but tend to be rather 
obtuse, onerous and obscure to those who aren't well versed in the world of encryption.

RavenDB uses the Daniel J. Bernsteinâ€™s `XChaCha20Poly1305` algorithm to encrypt your databases, as implemented by the libsodium 
library. Both the algorithm and the library have been analyzed and audited by cryptographic experts and passed with flying 
colors. I'm not going to discuss the actual encryption, that is quite out of scope for this book and you can find the gory 
details elsewhere. I'm going to focus on the way RavenDB uses encryption to protect your data. You can safely skip this 
section, as it has a very little impact on using and operating RavenDB.

Internally, RavenDB holds your data inside a datafile (usually called `Raven.voron`) that is memory mapped to the RavenDB 
process. We also use temporary files^[These files are also memory mapped, but they aren't persistent, as far as RavenDB is 
concerned. Instead, we are using memory mapped files to avoid using too much private memory and give the operating system
well-known backing store for this temporary memory. It also allows RavenDB to have fine-grained control over the memory
usage required by the storage requirements.] which typically found in in the `Temp` directory and have names such as:
`Temp/scratch.0000000000.buffers` or `Temp/compression.0000000000.buffers`). 
There are also the write ahead journals, which are the key to RavenDB's transactional nature and ACID capabilities, these
are stored in the `Journals` directory with names such as `Journals/0000000000000000001.journal` or 
`Journals/0000000000000000002.journal`. 

All these files contain some portion of your document data, and as such, need to be encrypted. Let's see how we deal with
encrypting each of them in turn. 

#### Encrypting the write ahead journal

The write ahead journal is a set of files (`Journals/0000000000000000001.journal`, `Journals/0000000000000000002.journal`, etc)
that RavenDB uses to maintain its ACID guarantees. Each journal file is allocated in advanced (typically 256MB at a time) and 
a new transaction is written to the file whenever it is committed. Indeed, a transaction cannot be considered committed unless
it has been successfully written to the journal file^[RavenDB uses direct and unbuffered I/O to write to the disk, ensuring 
that writes are actually persistent, skipping the caches in the middle.].

A journal file is a set of consecutive transactions. When RavenDB opens a database, it will read the journal file, find all the
transactions that haven't been synced to disk yet and apply them to the data file. In this way, even if we crashed, we can be 
certain that no data has been lost. Without encryption, a transaction is protected using a non-cryptographic hash (`XXHash64`)
to ensure that the full transaction has been written to disk. This allows us to verify whether a transaction was committed or
not.

> **Authenticated encryption**
>
> If I took the following text `{'User': 'Oren', 'Admin': 'N' }` and "encrypted" that using Caesar cipher, I would get the 
> following output text: `{'Xvhu': 'Ruhq', 'Dgplq': 'Q' }`. Figure 14.3 shows the encryption key for this cipher. 
>
> ![The encryption key for Caesar cipher](./Ch14/img03.png)
>
> I'm using Caesar cipher here because it makes it easier to talk about encryption while being simple enough that we don't
> need to delve into complex mathematics to discuss the details. 
>
> A common usage pattern for encrypted data is to hand it to an untrusted party, then accept it back from that untrusted
> party again at a later time. A good example of that can be cookies in the browser. You can use the text above is used 
> as the session cookie to remember the user between different HTTP requests. Obviously with a better encryption algorithm.
>
> Now, imagine that somewhere in your code you have a line like `isAdmin = GetSessionCookieData().Admin != 'N'`. We gave
> the cookie to the browser, and the user is free to modify it. What will happen if we change the encrypted text to be
> `{'Xvhu': 'Ruhq', 'Dgplq': 'R' }`? The only change we made was to flip the `'Q'` in the end to `'R'`. When "decrypted"
> the output will be `{'User': 'Oren', 'Admin': 'O' }` and suddenly the user is considered to be an admin.
>
> In other words, just because the encrypted text was successfully decrypted, it doesn't mean that it is actually the
> value that was originally encrypted. It might have been tampered with, and there have been real attacks using angle. 
>
> Because of that, all modern encryption algorithms use a mode called Authenticated Encryption (Additional Data) which is
> usually shortened to AEAD. In this mode, in addition to encrypting the data, the algorithm also computes a cryptographically
> secure hash over the encrypted data (and potentially additional data as well) and then sign it.
>
> In the same manner, during decryption, the signature is checked first and the decryption fails if the signature doesn't
> match. Any tampering with the data will be caught in this manner. RavenDB uses only AEAD encryption to 
> protect your data, so any attempt to modify it will be immediately detected. Such modification can be done maliciously 
> or as a result of a hardware failure (bit flipping in storage, for example).

With encryption, we store only the transaction header unencrypted in the journal file. The transaction data itself is encrypted
using `XChaCha20Poly1305`. This is an authenticated encryption algorithm, giving us cryptographic assurance that if the 
decryption was successful, the data we got matches the data we encrypted. Since we are already verifying the integrity of the
data, we don't bother also using `XXHash64` on the transaction when using encryption.
Each transaction is encrypted with a different key, derived from the master key and the transaction id and a 192 bits random
nonce. 

#### Encrypting the main data file

The main data file (`Raven.voron`) contains all the data in your database. Unlike the journals, which are written to in a
consecutive manner, one transaction at a time, the data file is written and read from using random I/O. In order to handle this
mode of operations, the data file is split into 8KB pages^[There are a lot of other reasons why the data is divided into pages,
and this is how RavenDB works without encryption as well. It just happens that it also plays very nicely into the requirements
for using the data while keeping it encrypted.] which can be treated as independent of one another. 
If there is a value that is over 8KB in size, it will use as many consecutive pages as needed and will be treated as a single
page. 

Each page is encrypted independently. This means that when we need to read a page, we can go directly to that page, decrypt it
and read its content without having to touch anything else in the database. In this fashion, we gain the ability to do random
reads and writes through the database. The structure of a page is shown in Figure 14.4.

![The internal structure of an encrypted page in RavenDB](./Ch14/img04.png)

As you can see in Figure 14.4, the page is composed of a header, nonce, MAC and the data itself. You are already familiar with
the nonce. But what is the MAC field for? This is the Message Authentication Code, which is used to verify that the page hasn't
been modified (see the section about Authentication Encryption previously in this chapter). Another interesting tidbit is the
fact that the space we have for the nonce is only 16 bytes (128 bits), but we know that the `XChaCha20Poly1305` algorithm uses
a 192 bits (24 bytes) nonce. Listing 14.1 shows what is actually is going on

```{caption="Internal structure of the page header and the full nonce usage"}
+--------+
|Page    |
|Header  |
|        |
|32 bytes| <-------+
+--------+         |
|Nonce   |      Actual nonce
|16 bytes|         |24 bytes
+--------+ <-------+
|MAC     |
|16 bytes|
+--------+
```

When RavenDB needs to encrypt a page, it will generate a 128 bits random value and store it in the nonce portion of the page 
header. However, when we need to pass a nonce to `XChaCha20Poly1305`, we will pass a value that is 24 bytes in size, starting
8 bytes _before_ the nonce. In other words, the nonce also contains 8 bytes from the page header.
In practice, this means that the nonce is using 128 bits of randomness with an additional 64 bits that will change as RavenDB
sees fit. 

Each page is encrypted using a dedicated key, derived from the master key and the page number of this page. The page header is
stored unencrypted, naturally, and the page's contents are encrypted.

#### How RavenDB access encrypted data?

RavenDB keeps all the data in an encrypted database encrypted at all times, both on disk and in memory. Whenever a transaction
needs to access a particular page, that page is decrypted into memory that is owned by that transaction. For the duration of
the transaction, the unencrypted values touched by this transaction will be resident in memory. 
When the transaction is over, that memory will be securely wiped. 

To further protect your data, RavenDB will attempt to lock the unencrypted data in memory, so it will not be written to a 
page file and will not be visible in core dumps. This is done by calling `mlock` or `VirtualLock`, depending on the system
in question.

Locking memory into physical RAM is subject to certain limitations and may require you to change system configuration to 
allow RavenDB to lock enough memory to handle routine operations. If your threat model doesn't include worrying about attackers
digging into the page file, you can tell RavenDB that it is fine to fail to lock memory using the following configuration 
option: `Security.DoNotConsiderMemoryLockFailureAsCatastrophicError`. 

This might be a valid choice if the system doesn't _have_ a swap or a page file defined or if you are using encrypted swap 
already, so there is no need to worry about data leaks from there. 

RavenDB also uses a few temporary files (`Temp/scratch.0000000000.buffers` and `Temp/compression.0000000000.buffers`, for
example). In terms of encryption, there are two types that we care about. First, you have the `scratch` files, which is where
RavenDB writes your data until it is written to the data file. These files are encrypted in the exact same manner as the data
file. Whenever there is the need to access data from one of them, they are decrypted to a temporary storage for the transaction
and then wiped after the transaction has been completed.

> **Notice the logs output**
>
> In an encrypted database, with high value data, you should pay attention to the output of the log. RavenDB do not generally
> log documents' data to the log file, even on the highest logs detail, but it can certainly write document IDs in certain cases.
> In such a case, you should either ensure that the logs directory is an encrypted directory or disable logging entirely. 

The other set of files are used as temporary buffers and are wiped immediately after use. The `compression` set of files, for
example, are used as part of writing to the journal. We write the transaction data to the memory mapped `compression` file and
then compress it, then we encrypt the data and finally write the encrypted compressed data to disk. Once that is done, we'll 
securely wipe the `compression` file memory to remove all traces of your data from memory.

What is encrypted? 
Everything that is stored in the database file, which includes:

* Documents
* Revisions
* Conflicts
* Attachments
* Tombstones

What is _not_ encrypted? 
Values that are stored at the level of the cluster, which are:

* Identities
* Compare Exchange Values
* The database record

The identity is generally not considered to be sensitive information, but Compare Exchange value most certainly can contain
data that you'll wish to keep private. Most importantly, the database record may contain connection strings to other databases.
This is relevant only if you are using SQL ETL and providing the connection string password in the connection string.
In this case, the full connection string is stored at the cluster level and is not impacted by the encryption mode of the 
database in question.

To enable encryption at the cluster level, you'll need to take additional steps, as we'll see now.

#### Encrypting the cluster information

In addition to storing your databases' data, RavenDB also stores data at the cluster level. This is usually called the server 
store and it is managed independently by any node in the cluster. The data that is stored there includes all the database 
records, identities, compare exchange values, etc. 
This is stored in all the nodes in the clusters, including databases that do not reside on this particular node.

You can also encrypt the information on the server store, although it is a bit more involved than the process of encrypting
a database and you must repeat this operation on _all_ the nodes in the cluster.

1. Shutdown the RavenDB node
2. Run `rvn offline-operation encrypt /path/to/system-db`
3. Restart the RavenDB node

The key here is in the second step. This loads the existing server store (which typically resides in the `System` 
directory), generate a new key (see the section about Key Management a bit later in this chapter) and encrypt the server store
using this key.

This should be done on all the nodes in the nodes in the cluster, and will typically result in a different key being generated
for each of the nodes. Note that RavenDB does _not_ enforce system store encryption on all the nodes. This is done to allow
rolling migration of encrypting of the system store (taking a node at a time, encrypting it and restarting it). If you decided
to encrypt your system store, make sure that this is done on all the nodes in the cluster. This includes _adding new nodes_, 
you can also run the `rvn offline-operation encrypt` command prior to adding the new node to the cluster, so at no point will
it write unencrypted information to disk.

#### Encrypting indexes

In addition to the main data file, there are also indexes to consider. Each index actually have a separate `Raven.voron` file,
it's own `scratch` and `compression` files, etc. And just like the main data file, this is encrypted on all levels, using the
exact same techniques that we just discussed.

> **Key derivation and additional security**
> 
> You might have noticed that pages and transactions aren't actually encrypted using the master key. Instead, each time we
> need to encrypt a value, we generate a derived key for that purpose. The idea is that even if due to some error an attacker
> was able to figure out what the key is for a particular page or transaction in the database, that would only help them
> for _that_ particular key.
>
> The key derivation function ensures that even if you know what the derived key was, you cannot go back to the master key
> that was used to generate it. This way, even full key exposure for a particular part of the data isn't going to expose 
> the entire database.

During queries, the indexing transaction will decrypt the relevant pages so you can perform searches normally, then wipe the
data from the memory when the query is completed. There is one exception to this rule, however, and that is in memory caches
that are used by the indexing engine for various reasons.

These caches contain the indexed terms as in memory arrays and are kept outside the transaction boundary. This is because 
creating them can be quite expensive. They are never written to disk, but they might be written to the page file. If you are 
concerned about the safety of this data, either ensure that the page file / swap are encrypted or don't index any sensitive
information. There is rarely a need to query using the full credit card number, for example. The last 4 digits are usually
sufficient. Document data that hasn't been indexed is not included in the cache, of course. 

During indexing, we also write temporary files to the indexing directory, containing the indexed data. These files are also 
encrypted using `XChaCha20Poly1305`, with a random key that is generated by RavenDB.

Even index _definitions_ are encrypted, so you can be assured that everything that is going to persistent medium is encrypted
and safe. What about what goes on the network?

### Encrypted data on the wire

Different nodes in the cluster may use different keys to encrypt the database. That means that we can't just send the raw
encrypted data from one node to the other. Indeed, whenever we send data over the network, be it as a response to a client's 
query or to replicate data to another node, we first decrypt the data, and then we send it. 

This sounds worrying, but remember that an encrypted database may only reside on a node that is running in a secured mode.
In other words, all the communication is done using HTTPS and TLS 1.2 and is both strongly encrypted and authenticated.
Let explore a few of the ways this is actually in use in practice.

Aside from a client querying the database, there are few other ways in which we can get data out of RavenDB. Replication, 
external replication, and ETL are the most common ones. Backups should also be considered, and are handled later in this
chapter.

Replication is for different database instance the same database group. All of them are going to be encrypted (usually, but
not always, with the same key. See Key Management section later in this chapter). External replication allows us to replicate
data to a different database, on the same cluster or on a different one. 
RavenDB requires that external replication from an encrypted database must go to a secured server, but does _not_ require that
it will be an encrypted one. 

> **The lost (encrypted) laptop**
>
> Why doesn't RavenDB require that external replication from an encrypted database will also go to an encrypted database? Because
> the other side is the one that controls the server. We don't gain anything by this requirement and there are several 
> desirable scenarios where we don't want or need that.
> 
> Consider the case of a salesperson that goes out to customers. They need to carry some data on their machine, to be able 
> to fill in new orders, etc. However, that data may be sensitive in nature, so we set up the database on the laptop as an 
> encrypted database. We also set up external replication to the master cluster in our data center. Since the risk we protect
> against with encrypted database is the laptop being lost or stolen, and we assume that the data center is locked, we don't
> want to encrypt the data in the master cluster. In this way, data that goes out and travel is encrypted, and the data we
> store in a secure location is not, which give us better performance and make certain operational tasks easier (see the 
> discussion on backups later in this chapter).

In addition to external replication, it is common to use ETL processes to get the data out of your RavenDB database. A good
example would be in a system that stores payment information. Because of PCI compliance issues, we have to store the data
in an encrypted manner. However, we also setup RavenDB ETL process to another database, to allow us to do more work on the data. 
As part of the RavenDB ETL process, we removed the sensitive payment details, so we are effectively left with just the orders
history. We aren't required to encrypt that, so there is no need to do so. In the same way, we can also use SQL ETL to transfer
some of the data to a reporting database for later analysis.

One thing to note here is that RavenDB will insist that RavenDB ETL use a secured mode (HTTPS), but we don't have a good way to
detect whether your SQL ETL connection string is encrypted, it's the admin responsibility to ensure that this communication
channel is safe from eavesdropping. 

For that matter, regardless of whether the communication is encrypted or not, the administrators need to be aware of the data
flow inside the system and that you aren't sending sensitive information into an unencrypted store, potentially exposing data
that shouldn't be stored in plain text. 

### Key management

This section is _important_ and probably the most important aspect for an administrator to be aware of. Everything else in this
chapter describes how RavenDB works and doesn't usually require operator attention. But in order to understand the security
of the system, you need to be aware where your keys are. 
You can encrypt your data using the strong encryption methods, using post-quantum algorithms and yet it all hinges on the 
security of your keys. If the key leaks in some fashion, this is game over as far as the security of the system is concerned.

As you can imagine, we put a lot of thought into key management. There are competing concerns here, however. The more secure
your system is, the harder it is to use. As you already seen, we didn't have to really do much when setting up the encrypted
database earlier in this chapter. We had a key generated for us by RavenDB, but aside from writing it down, we could just 
run everything normally. This leads to an interesting question, where is the key stored, and how?

In fact, there isn't _a_ key, there might be more than one. RavenDB uses the following keys^[Both the database keys and the 
server master key are local to a node, not shared across the cluster.]:

* Database encryption key - per database key used as the master encryption key for the database. These are stored in 
  the server store.
* Server master key - a server-wide value that is used to encrypt the database encryption keys.

By default, the server store is not encrypted, and in order to avoid an attacker simply being able to read the database 
encryption keys from the file system, we encrypt the database encryption keys with the server master key.
Of course, this just moves the attack vector, so how does RavenDB protect the server master key?

We could try encrypting _that_, as well, but this will just lead us to need to encrypt the new encryption key. And if we'll
encrypt that, we'll discover that it is turtles all the way down. This isn't a problem that is unique or new to RavenDB.
Your organization is likely to have policies in place for storing the encryption key. We'll discuss how RavenDB can fit into
those later on, for now, let's see how RavenDB stores the server master key by default.

On Windows, there is the Data Protection API (`DPAPI`) which allow RavenDB to piggyback the encryption of the key on top of
the Windows password. Conceptually, Windows uses a value derived from the logged in user's password to encrypt / decrypt 
values. This means that we don't need to have a server master key, and can rely on `DPAPI` to manage that for us.
This means that whenever we need to store the database encryption keys, we'll call `DPAPI`, which will
encrypt the key, and store this encrypted value. Whenever we open an encrypted database, we'll hand the encrypted value 
back to `DPAPI` and get the encryption key back, so we can use that to open the encrypted database.

This has the advantage of being pretty seamless and usually being good enough security. The disadvantage is that this is
tied to the Windows password. For example, an admin resetting the password will cause `DPAPI` to fail on any decrypting 
values that were encrypted with the old password (note that _changing_ the password, which requires having the old password,
is safe in this regard. It is only a password reset that will cause us to lose access to previously encrypted DPAPI values).

On Linux, the situation is a lot more complex. There isn't a single solution, like `DPAPI` on Linux. Instead, there are a lot
of solutions that can be used (`libsecret`, `Gnome Keyring`, `KDE Vallet`, etc). Because there is no accepted answer, and 
as a desire to avoid dependencies that might not exist in all deployments, RavenDB doesn't make use of any of these 
solutions (see the next section for how you can customize that).
Instead, we use the operating system permissions to securely hold the key. This is stored in `~/.ravendb/secret.key` file
with permissions set to only allow the RavenDB user access to it. 

On Linux, if you have a single hard disk, that stores both the `secret.key` file and the encrypted database as well, you 
can plug this hard disk to a separate system, where you have `root` privileges and skip any permissions checks on the 
file system level. On Windows, there are tools such as `DPAPick` that can decrypt `DPAPI` values, given offline access to
a machine. 

So by default, RavenDB utilize the operating system level mechanisms to secure the server master key, but that can give
you only up to a certain level of security. Instead, you can customize the manner in which RavenDB get the encryption key.

#### Customizing key management in RavenDB

Your master encryption key is the holy grail of your database security. RavenDB has reasonable defaults to store it, using
`DPAPI` or file system permissions, depending on which operating system it is running on, but there is a limit to how much
that can protect your data. In many organizations, there are strict security policies around key management, and RavenDB 
allows you to follow them easily.

In much the same way that we can customize how RavenDB is getting the `X509` certificate to ensure that the communication
is safe, we also provide you with a way to specify an executable that will fetch the key from some secrets store. This is 
controlled using the `Security.MasterKey.Exec` configuration value. 

Listing 14.2 shows an example of a PowerShell script that can be invoked to fetch the encryption key from the Azure Vault.

```{caption="Getting the encryption key from Azure Vault and sending it to RavenDB" .ps1}
$secret = Get-AzureKeyVaultSecret -VaultName 'AllMySecrets' -Name 'RavenMasterEncKey'
$key = [System.Convert]::FromBase64String($secret.SecretValueText)
$stdout = [System.Console]::OpenStandardOutput()
$stdout.Write($key, 0, $key.Length)
```

RavenDB will invoke this script, read the key from the standard output and use that as the server master key. In this way,
you have complete control over key storage, access control, etc.

> **Changing the key**
>
> You _can_ change the server master key, but it takes a bit of work, effectively, you have to decrypt and re-encrypt
> the server store with the new key. That is reasonable to do because the server store is usually fairly small. 
> Changing the database encryption key is not really possible without a full export / import, which on large database
> can take a lot of time.
>
> Since different servers can use different keys, you might want to create the new key on a new server, then tell
> RavenDB to move the databases over. This way, you have an online process and you don't have to take the system down
> while this is happening. But in practice, changing the key is rare, and isn't usually needed.

It is important to note that failure to retrieve the server master key (or getting the wrong key) will cause failure to
load encrypted databases (and if the server store is encrypted, failure to start RavenDB).

#### Managing the database encryption key

So far we talked primarily about the server master key, but the database encryption key also deserves some attention. 
Earlier in this chapter, we have created an encrypted database, and as part of that, we also got the encryption key to 
safely store away (Figure 14.2). 

Encryption keys are _not_ part of the global cluster state, nor are they usually sent over the wire. Instead, at database
creation time, the server generates a key, then contact each of the nodes configured to host this database and tell them
what the key for this database is. Only then is the actual database being created.

If you created an encrypted database on node `A`, and later you want to expand the database group so it will also reside 
on node `C`, how does this work? The encryption key is not available on node `C`, after all, just trying to expand the database
group to node `C` will result in an error, because setting up a key for an encrypted database is a separate action from
setting up the database. The database creation wizard makes this process seamless, but it is important to understand what
is going on beneath the surface. 

> **Getting the encryption keys from RavenDB**
>
> As an administrator, you can get the server master encryption key by using `rvn offline-operation get-key` and providing
> the path to the server store folder. This is typically used if you need to move the database between machines.
>
> To get the database encryption key, you need to go to `Manage Server` and then to `Admin JS Console`, choose
> `database` as the type and select the database you want to get the key for. Now you can run the following 
> command to get the key: 
> 
> `return database.DocumentsStorage.Options.MasterKey;`
>
> You can see an example of this in Figure 14.5. 
>
> ![Getting the encryption key from an active database using an admin script](./Ch14/img05.png)
>
> This technique is using the admin scripting functionality, which is only available to the cluster administrator and 
> allows you to execute arbitrary scripts in the context of RavenDB itself. The same functionality is also exposed via
> the `rvn` tool, using `rvn admin-channel` and then the `script` command. 
>
> Note that getting the server master encryption key is an _offline_ operation, while the only way to get the database
> encryption key is when the database server is up and running. 

Because different nodes do not necessarily have the same encryption key for the same database, and because the encryption
key is _important_, we require an administrator action to create the key on a node before RavenDB can actually load an
encrypted database. This can be done through a REST call, as you can see in Listing 14.3.

```{caption="Push a database encryption key to a node" .ps1}
$baseUrl = "https://c.raven.development.run"
$dbName = "Northwind"

$spm = [System.Net.ServicePointManager]
$spm::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
$rng = [System.Security.Cryptography.RNGCryptoServiceProvider]
$key = New-Object byte[] 32
$rng::Create().GetBytes($key)
$payload = [System.Convert]::ToBase64String($key)
$cert = Get-PfxCertificate -FilePath admin.cert.pfx

Invoke-WebRequest "$baseUrl/admin/secrets?name=$dbName" `
    -Certificate $cert -Method POST -Body $payload
```

There is actually a lot going on in Listing 14.3. First, we define the node that we are going to push the key to and the 
database whose encryption key we'll push. Then we ask PowerShell to use TLS 1.2 to talk to the server (sometimes it 
defaults to TLS 1.0, which isn't supported by RavenDB for security reasons). 
`RNGCryptoServiceProvider` is then used to generate a cryptographically secured random number, we convert it to base64
and then use a certificate with cluster administrator privileges to send it to the node.

Once this is done, we can now expand the Northwind database from node `A` to node `C` as well. The database will be created
on the new node and the previously pushed encryption key will be in use. An administrator can decide that they want to 
use the same key on all the nodes, which may simplify some operations (restoring from backup, for example) or different
keys. We'll speak more about backup later in this book, but there are some things about backing up an encrypted database that 
require special attention, let's go over them.

### Backing up encrypted databases

Just because a database is encrypted doesn't mean that it doesn't need all the usual care and maintenance. In particular, I'm 
thinking about backups, restores, and high availability considerations. We'll discuss backups in full in the next part of this
book, so I'm not going to get too deep into the details of how to work with backups here. Instead, I'll just discuss the details
that are important to remember when dealing with encrypted databases.

RavenDB supports the following forms of backups:

* Snapshot - a compressed binary snapshot of the database file at a given point in time, as well as additional data from the 
  cluster level that belongs to the database (identities, compare exchange values, etc).
* Full backup - a compressed JSON of all the data in the database, as well as the cluster level data.
* Incremental backup - a compress JSON of all the data in the database since the last full backup, as well as the cluster 
  level data.

For an encrypted database, it is important to consider what parts of the backup are encrypted, and in what manner. With a 
`Snapshot` backup, the entire snapshot is encrypted using the database encryption key. Conceptually, it is the raw file
from the disk, as is^[Note that this is just a conceptual model. You can't just copy the file out of the way while 
RavenDB is running and consider this a backup].

As a result, in order to restore the snapshot, you _must_ have the appropriate encryption key at restore time. Without the 
encryption key, there is no way to restore the database, access the data or really do anything at all. 

Alongside the snapshot data, there is also the cluster level data. This is typically much smaller, but this is _not_ 
encrypted in the case of a snapshot. This data is compressed, but other than that, it is available to anyone that can 
read the backup media.

Full and incremental backups are always completely unencrypted. You should be aware of your backup strategy and where you are
going to back up your encrypted databases. RavenDB can push backups to a local or shared directory, to an `FTP`/`SFTP` 
site, to Azure blob storage, Amazon S3, and Amazon Glacier. 

In any of these cases, if you have an encrypted database, you need to consider where you are going to store the data. 
You can backup to an encrypted folder, or enable data at rest encryption settings when uploading to the cloud (exactly how
depends on which system you are using, but all have some level of support for automatic encryption of uploaded content).

We'll discuss backup management at length later in this book, but I want to emphasise that for encrypted databases, in 
addition to backing up the data for the document itself, it is important to also backup the encryption key. This is 
important for restoring snapshot data, but it can also be _very_ relevant if an admin has reset a password of a user, 
resulting in `DPAPI` failure to decrypt the database encryption key at startup.
This error can happen pretty far down the line. If the admin reset the password on Monday, but RavenDB already had got
the encryption key in memory, there will be no issue until RavenDB unloads the database and needs to reload it. That
can happen several days or weeks later. 

At that point, being able to grab the encryption key from a locked drawer and provide it to RavenDB so it can load the
encrypted database is preferred to having to go and restore everything. 

### Summary

This chapter may be hard to decipher, but I hope you got the right keys from it. In a more serious tone, we have gone
over a lot of information about how RavenDB is using high-end encryption to safely protect your data. 
RavenDB uses the `XChaCha20Poly1305` algorithm to encrypt any and all data on disk, and will only decrypt information 
during an active transaction. RavenDB will also immediately wipe the decrypted contents in memory on transaction closure
reducing the time that sensitive information is available. During this time, the memory holding the decrypted data is 
locked into memory, so it will not be written to a page file or a swap partition.

We went over the details of how RavenDB encrypts every part of the system, from how transactions are encrypted as they are
written to disk to how each individual data page in the database is encrypted using its own unique key. We saw what is 
actually encrypted (documents, attachments, revisions) and what isn't encrypted (identities and compare exchange values)
even if the database is encrypted. We then saw how we can encrypt the cluster level data by encrypting the server store
and saw for the first time the `rvn` tool. 

Following this, we looked at what is probably the most important topic for you in this chapter, how the encryption keys
are being managed by RavenDB. By default, RavenDB encrypts the database encryption keys using the server master key. This
master key is then encrypted using `DPAPI` on Windows or protected using file system permissions on Linux.
You also have the option of telling RavenDB how to fetch the master key from a Hardware Security Module, a vault or any
other method that fits your security policies using the `Security.MasterKey.Exec` option. 

Finally, we discussed backup concerns for encrypted databases, in particular, the safekeeping of the encryption keys.
I find it ironic that what is probably the most secure method is printing the encryption key and then storing it offline
in a locked cupboard at your offices, but I've found it to be one of the most efficient ways to handle such an issue. Having
the key backed up in such a way means that you don't have to think about it too much, but if you do have a need for the key
it is available to you. 

You might have noticed some emphasis on my part about the topic of keeping the encryption key safe. This is because the key
is _important_, without it, you have no access to the database. This is a basic property of an encrypted database, and yet
we have had gotten support calls with some variant of "we lost the key, how do we get the data back?". This can be because
of a password reset invalidating a `DPAPI` encrypted value, losing the main hard disk of the machine, but still having the
database drive up or for many other reasons. 

Regardless of the reason, the key was lost (or who is to blame for it), if there is no key, there is no way to access the 
data. That is the _point_ of encryption. So please remember that when you create an encrypted database, keep your encryption
keys somewhere safe, just in the off case that you'll need them.

This also closes our discussion on security inside RavenDB, the next topic we have on the table is an in-depth dive into 
operations, deployments and monitoring your production clusters.