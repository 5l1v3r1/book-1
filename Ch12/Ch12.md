

## Working with indexes

We've spent the last three chapters going through how querying works in RavenDB, what are indexes, how they operate and what they
can do. We looked at anything from simple map indexes to spatial queries, from performing full text queries to aggregating large
amount of data using map-reduce. What we haven't talked about is how you'll typically work with indexes in a typical bussiness
application.

This chapter will focus on that, discussing how to create and manage indexes from the client side, how to perform queries and what
options are available for us on the client API. We already expored some basic queries in Chapter 4, but we only touched queries 
very briefly, just enough to get by while we learn more about RavenDB. Now we are going to dig deep and see everything that we can
do with indexes and queries in RavenDB.

### Deploying and managing indexes

RavenDB is schemaless, you can have documents in any shape, way or form that you'll like. However, indexes are one of the ways 
that you'll bring back structure to such a system. An index will take the documents as input and output the index entries in a 
fixed format. Queries on this index must use the fields defined on the index (unless the index is doing dynamic field generation),
and there is typically a strong tie between the structure of the index, the output of queries and the client code that is using
it.

That is interesting, because it means that changing the index might cause client code to break, and that brings to mind very 
strongly the usual issues you run into with a fixed schema. This often leads to complexities when developing and working with 
schemas, because versioning, deploying and keeping them in sync with your code is a hassle.

RavenDB allows you to define your indexes directly in your code, which allows you to version the indexes as a single unit with the
rest of your system. In order to see how this work, we'll use a C# application. Open `PowerShell` and run the commands shown in 
Listing 12.1.

```{caption="Creating a new RavenDB project" .cmd}
dotnet new console -n Northwind
dotnet add .\Northwind\ package RavenDB.Client
dotnet restore .\Northwind\
```

The commands in Listing 12.1 just create a new console application and add the RavenDB client package to the project. Now, go to 
RavenDB and create a new database, named `Northwind`. Go to `Settings` and then `Create Sample Data` and click on the `Create`
button. Click on the `View C# Classes` link and copy the code to a file call `Entities.cs` and save it in the `Northwind` app 
folder.  

We are now ready to start working with real indexes from the client side. 

#### Working with indexes from the client

Before we get to defining new indexes, let's start with an easier step, querying on an existing index. Your `Program.cs` file 
should be similar to Listing 12.2.

```{caption="This console application queries RavenDB for all London based employees" .cs}
using System;
using System.Linq;
using Raven.Client.Documents;
using Orders;

namespace Northwind
{
  class Program
  {
    static void Main(string[] args)
    {
      var store = new DocumentStore
      {
        Urls = new []
        {
          "http://localhost:8080"
        },
        Database = "Northwind"
      };
      store.Initialize();

      using(var session = store.OpenSession())
      {
        var londonEmployees = 
          from emp in session.Query<Employee>()
          where emp.Address.City == "London"
          select emp;

        foreach(var emp in londonEmployees)
        {
          Console.WriteLine(emp.FirstName);
        }
      }
    }
  }
}

```

The code in Listing 12.2 is the equivalent of Hello World, but it will serve as our basic structure for the rest of this chapter.

The query we have in Listing 12.2 is pretty simple dynamic query, the like of which we already saw in Chapter 4. This is 
translated to the following RQL: `FROM Employees WHERE Address.City = $p0`. So far, there are no surprises, and if you'll check
the indexes on the database, you should find that the `Auto/Employees/ByAddress.City` index was automatically created to satisfy
the query. How can we select the index we want to use for a query from the client side? You can see the answer in Listing 12.3.

```{caption="Specifying the index to use for a query (using strings)" .cs}
var ordersForEmployee1A = 
  from order in session.Query<Order>("Orders/Totals")
  where order.Employee == "employees/1-A"
  select order;

foreach(var order in ordersForEmployee1A)
{
  Console.WriteLine(order.Id);
}
```

As you can see, the major difference is that we are now querying on `Orders/Totals` index and we pass that as a string to the 
`Query` method. Using this methods means that we need to define the index somewhere, which leads to the deployment and 
versioning issues that I already discussed. RavenDB has a better solution.

#### Defining simple indexes via client code

When using a strongly typed language, we can often do better than just passing strings. We can use the features of the langauge
itself to provide use with a strongly typed answer for that. We'll re-create the `Orders/Totals` index in our C# code, as shown
in Listing 12.4 (you'll need to add a `using Raven.Client.Documents.Indexes;` to the file).

```{caption="The Orders_Totals2 index is defined as a C# class" .cs}
public class Orders_Totals2 : AbstractIndexCreationTask<Order>
{
    public Orders_Totals2()
    {
      Map = orders =>
        from o in orders
        select new
        {
            o.Employee,
            o.Company,
            Total = o.Lines.Sum(l => (l.Quantity * l.PricePerUnit) * (1 - l.Discount))
        };
    }
}
```

We use `Orders/Totals2` as the index name in Listing 12.4 to avoid overwriting the existing index, this way, we can compare the 
new index to the existing one. There are a few interesting features shown in Listing 12.4. First, we have a class definition
that inherits from `AbstractIndexCreationTask<T>`. This is how we let RavenDB know that this is actually an index definition, 
and what is the type that it will be working on.  
In the class constructor, we set the `Map` property to a Linq expression, transforming the documents into the index entries. 
Now we just need to actually create this index. There are two ways of doing that, shown in Listing 12.5.

```{caption="Creating indexes from the client side" .cs}
// create a single index
new Orders_Totals2().Execute(store);

// scan the index and create all the indexes in 
// the assembly as a single operation
var indexesAssembly = typeof(Orders_Totals2).Assembly;
IndexCreation.CreateIndexes(indexesAssembly, store);
```

The first option in Listing 12.5 shows how we can create a single index. The second tell RavenDB to scan the assembly provided
and create _all_ the indexed defined there. 

> **Automatically creating indexes**
>
> The `IndexCreation.CreateIndexes` option is a good way to not have to manage indexes manually. You can stick this call
> somewhere in your application's startup during development and as an admin action in production. This way, you can muck
> about with the index definitions as you wish, and they will always match what the code is expecting. 
>
> In other words, you can checkout your code, run the application and the appropraite indexes for _this version of the code_
> will be there for you, without really having to think about it. For production, you might want to avoid automatic index
> creation on application startup and put that behind an admin screen or something similiar, but you'll still have the option
> of ensuring that the expected indexes are actually there. This makes deployments much easier, because you don't have to 
> manage the "schema" outside of your code.

After running the code in Listing 12.5, you'll see that there is an index named `Orders/Totals2` in the database. By convention,
we replace `_` with `/` in the index name. Now is the time to try to query this index, in a strongly typed manner, as you can 
see in Listing 12.6.


```{caption="Specifying the index to use for a query (strongly typed)" .cs}
var ordersForEmployee1A = 
  from order in session.Query<Order, Orders_Totals2>()
  where order.Employee == "employees/1-A"
  select order;
```

The second generic parameter to `Query` is the index that we want to use.


#### Defining map-reduce idnexes via client code


#### Locking indexes


### Side by side


### Threads & indexing

### Inspecting auto indexes

### indexing performance

### terms



### Querying from the client API

This is going to be a short chpater, merely showing you how to use the client API to invoke the behaviors we have been discussing in 
the past few chapters