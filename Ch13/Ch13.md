
## Securing your Ravens

[Securing your Ravens]:(#security)

The Internet is often seen as a magical grove, with the sum total of human knowledge at your fingertips and a land of unlimited
opportunities. If you dig down just a little bit, you'll find that this is not a magic grove, but a haunted woods. The Internet
is a hostile place, with very little trust given or expected. A network packet traveling between two machines is likely to 
be intercepted, inspected, logged and modified before it reaches its destination. 

From re-writing links to downloads to include malware to phising sites that will steal your passwords and then your identity, the
ideal of a network that is safe to browse is very far from reality. You don't typically notice this, because the baseline 
assumption is, and has been for a while, that the network itself it hostile. Website uses certificates and top of the line 
encryption to idenitify themselves and hide the content of requests and responses over the wire, digital signatures are sent and
validated automatically by your browser and platform.

We have reached the stage where it is required to use military grade encryption, to upload the lunch selfie that is going to be 
uploaded to the cloud for all to see. There is so much encryption around us that we don't really notice. From the green lock icon
on the browser to common chat platforms employing end to end encryption, forward security and authentication. When the network is
hostile, only the foolish will go forth without the armor of encryption.

This chapter is not meant to be a thorough discussion of security practices in general. There have been many books published on 
the subject that deals in many aspects of the problem. From how to protect your data and services to how to break into 
insufficently protected locations and ransack their contents. 

We are going to focus on understanding the threat model your RavenDB instances face and what kind of features RavenDB has to deal
with such threats. This chapter is all controlling who can access the data inside your databases, protecting the conversation 
between client applications and that database from being eavesdropped or modified as well as protecting the data on disk from 
being usable if it is stolen.

> **Running RavenDB in unsecured mode**
>
> It might be surprising to hear, but it is very common to run RavenDB with no security whatsoever. This is typically what you'll
> have when RavenDB is running on a developer machine. By default, this mode is only allowed as long as RavenDB is listening to
> either `127.0.0.1`, `::1` or `localhost`. In other words, as long as RavenDB is not listening on the network^[RavenDB will 
> _refuse_ to run in this mode while listening to other IPs unless you explicitly tell it that you are fine with an unsecured 
> setup.].
>
> In such a mode, _none_ of the security features of RavenDB are accessible. You cannot authenticate users (anyone listening on
> the network would be able to hijack the connection, after all) nor can you create or use encrypted databases (anyone can
> access the server and get the encrypted data, so why bother).
>
> Note that even in development mode, it is still _strongly_ recommended that you'll run in a secured configuration. The RavenDB
> team have worked _hard_ to make sure that running in a secured mode is easy, preceisely because of this. Your default mode 
> should be a secured one.

So far, we have run RavenDB in its unsecured configuration, suitable only for development work in a secured network. In any other
case, you'll want to run RavenDB in a secured mode. A core part of the design of RavenDB has been security, and most importantly,
making sure that running RavenDB in a secured fashion is _easy_ enough to be the default. 

### Introduction to transport level security and authentication

I'm going to assume that you have little to no knowledge about security. This is likely false, but it is better to give you 
information that you already have than miss something critical. Securing a RavenDB server requires that we'll take care of the 
following issues:

1. Allow the client to verify that the database server is indeed the one we wanted to talk to. 
2. Allow the server to verify that the client is a valid one and to decide what access it should have.
3. Prevent anyone else from eavedropping to the communication between server and client, hijack the client credentials, etc.

RavenDB is not the first to have these set of requirements and instead of rolling our system^[Roll your own is usually a _bad_
idea with security practices.] it uses the TLS 1.2^[TLS - Transport Level Security, the successor to SSL and what is actually 
used when you are using HTTPS, for example.] protocol. You might not be familiar with the term, but a more common use name for
this is HTTPS. RavenDB uses TLS 1.2 in the following ways:

* The database server identifies itself with a `X509` certificate to clients.
* Clients use `X509` client certificate to identify itself to the server.
* All traffic between the database and clients is encrypted.

TLS 1.2 is the recommended protocol for secured communication by NIST and PCI 3.1 and in Dec 2017 was the chosen protocol for
close to 90% of the entire encrypted web traffic world wide.

If you have previously deployed a website or application using HTTPS, you are already familiar with the key problem of using 
TLS / HTTPS, the certificate. Rather more to the point, _getting_ a certificate.

A certificate, according to [Wikipedia](https://en.wikipedia.org/wiki/Public_key_certificate), is: "is an electronic document
used to prove the ownership of a public key". That doesn't really mean much to a layperson. A certificate is a way for a service
to identify itself in a crytographically secured manner. There are two types of certificates that usually interest us, self-signed
certificates and certificated signed by a Certificate Authority (CA). 

A self signed certificate is similar to a post-it note at a class reunion, while a certificate signed by a CA is more like an 
official ID. Figure 13.1 might make things easier to explain.

![Self signed vs. CA certificates, in real world terms.](./Ch13/img01.png)

Unlike the real world, certificate uses cryptographic signatures to identify themselves. You can assume that if the connection
is using a certificate, then no outside party can listen to the contents of the traffic between client and server. That, as it
turns out to be, is just half of the issue. Consider going to your class re-union, seeing a name tag that say "Your Best 
Friend From High School" and then whispering a dire secret to that person. 

You can be sure that your secret has only reached that person's ears, but the fact that they have a name tag with a particular
name doesn't actually mean that they _are_ that person. In the real world, you'll typically use a government issued id to 
verify identity. There is a much higher level of trust given to a driver license with your details than to a post-it note with
a hand written name.

In the same sense, you have a self signed certificate (which ensures that the connection is private, but doesn't gurantee who
you are talking to) and you have a CA signed certificate. A CA is supposed to do some level of validation before issuing a 
certificate. And as part of issuing the certificate, it will sign it using its own cryptographic signature. This way, you have
a list of trusted CA (called the Root CAs) and by default you'll trust that certificates that you run into that are signed by
those CA are valid. 

> **What does it means, CA validation?**
> 
> There are different types of certificates that you can use. They range from Domain Validation (DV), code signing, Extended
> Validation (EV) and many more usages. For the purpose of RavenDB, we only care about DV certificates, which allow you 
> to verify that the server you are talking to is actually the server you _think_ that you are talking to.
> 
> The purpose of a domain validation certificate is to ensure that when you type `https://db.example.org` your connection will
> not be intercepted in the middle. This is done by getting a certificate from the server and checking that it is indeed signed
> for this domain and by someone that you trust.
>
> It's important to note that this is _all_ it does. Most CAs will only check that you have control over that domain before
> issuing a certificate. And if you have the certificate for a site, you can absolutely pretend to be that site. If you have
> bought the domain `example.org` you can get a certificate for `db.example.org`, but unless you have _really_ good eyes and
> a good font choice, you wouldn't know that the `a` character in the domain is not U+0061 but actually U+0251, a completely
> different letter, resulting in a different domain. 
> 
> I'm using the Unicode letters because it is so sneaky, but the same rules apply to `exampel.org` or `examp1e.org`. One can
> mislead you by a typo and the other with `1` vs `l`. At the time of this writing, both domains were actually available for
> purchase, by the way.
> 
> Another asepct of security to consider is who you trust. For example, inside an organization, the admins usually have a 
> root certificate installed on all the machines, so they can generate certificate for any site they wish to. 

A CA can be one of the global Root CAs (such as Comodo, IdenTrust, DigiCert and Let's Encrypt), which are trusted by most 
browsers and operating systems or it can be a local CA. For example, the operations teams define a root certificate that is 
trusted by all your machines, and used that to generate certificates. The real world parallel for a local root CA is 
accepting employee ID cards as proof of identity inside a company. 

#### Certificate usage inside RavenDB

RavenDB uses certificates for all communication and authentication needs. This has the advantage that _anything_ can talk to
RavenDB, because HTTPS is so widely supported. Operations teams are also used to handling certificates, securely storing them,
renewal, revocation, etc. 

By default, the client API will trust the server if the server's certificate is a match to the expected URL, the certificate is
valid and the certificate is signed by a trusted party. You can override such decisions by setting the 
`RequestExecutor.ServerCertificateCustomValidationCallback` and do you validation logic there. This is useful if you are using
self-signed certificates that aren't trusted by the client, or if you want to verify additional properties on the certificate. 

When running in a secured mode, RavenDB required that the client, as well, will authenticate using a `X509` certificate. This
is called a client certificate and it allows the client and server to establish a mutually authenticated channel between them.
The server certificate requires that the client trust it and using the Root CA and the trust chains that are 
defined on the client machine. For the server to trust a client certificate, that certificate needs to be explicitly registered
in the cluster. 

> **Reducing optional attach surface**
> 
> Part of the security design for RavenDB is that its security comes with a single on/off switch. The unsecured mode for 
> RavenDB uses plain text transport only (HTTP), supports no authentication and cannot use encrypted databases. It can
> also only talk to other unsecured servers and be part of an unsecured cluster. 
>
> On the other hand, in the secured mode, we use HTTPS and TLS 1.2 for all communications, require authentication for all
> operations (using client certificates) and can only talk to other secured servers and be part of a secured cluster. This
> also allows us to have encrypted databases.
>
> The reasoning is that by not allowing a secured server with no authentication we prevent operator mistakes from exposing
> production machines to the world. Sadly, this is a _very_ common occurance and something that we have strived to make
> difficult to do by accident. 

We'll go through exactly how to do that in the next section, for now, I want to focus on the general theory and what exactly
is going on before diving into how you'll operate it.

Client certificate are easy, the only thing that needs to trust them is RavenDB, and we can either register a certificate
with the cluster directly, or ask the cluster to generate them for us. Getting a server certificate is usually much more
complex, because you need to deal with trust issues and in many organizations, access to certifciates is tightly controlled
(and right so). 

Let's us see what RavenDB does to make secured setup easier. 

### Setting RavenDB up in a secured fashion

Setting up RavenDB in a secured mode is a fairly simple process. You can do it yourself by setting the right configuration values
and deploy it directly. However, the first time that you'll start a RavenDB instance you'll be direct to the setup wizard, where
you can make important decisions about how RavenDB will be deployed. You can see how this look slike in Figure 13.2. 

![The setup wizard is the first screen you'll see when accessing RavenDB for the first time](./Ch13/img02.png)

You have four options available. You can setup RavenDB by generating a certificate through `Let's Encrypt`, use your own 
certificate, setup RavenDB in _unsecured_ mode or complete the setup process for a cluster node that was started on another
instance. 

> **Using `Let's Encrypt`**
>
> Part of the reason TLS and HTTPS aren't used everywhere is the issue of certificates. In order for a certificate to be useful
> you need it to be trusted, which means that you need to get it from one of the Root CAs. Up until recently, that was something
> that you could only get in a commercial setting. This severly limited HTTPS adoption and made it a lot more complex
> 
> Enter `Let's Encrypt`, whose mission is to bring HTTPS everywhere, by providing free, trusted, certificiates to all in an 
> fully-automated manner. The only requirement that `Let's Encrypt` has is that you prove in some manner that own the domain
> for which you are requesting a certificate. 

The online documentation does an excellent job in walking you through all the options of setting up RavenDB, so I'm not going
to go into detail on each and every option. Instead, I'm going to walk you through setting up a RavenDB cluster in a production
mode in as few a steps as possible. Right now, my focus is the security of the solution, we'll talk a lot more about deployment
options on later chapters.

First, uncompress the RavenDB server package (available on the [https://ravendb.net/downloads](https://ravendb.net/downloads))
three times, to `raven/srv-a`, `raven/srv-b` and `raven/srv-c`. We are going to run three instances of RavenDB on a single 
machine, but you can follow the exact same steps to setup RavenDB on multiple machines. Just be sure to get the IP addresses
correctly and to open the relevant ports in the firewalls.

> **`Let's Encrypt` is completely optional**
> 
> It's important to note that this part of the process is _entirely_ optional. You can run your RavenDB instance using your own
> certificates and your own domains. This is provided to make it easy to setup RavenDB in a secured manner.
> 
> For most operation teams, certificate and domain management is their bread and butter and RavenDB couldn't care less about
> where you got your certificate from. You can use the same setup process with your own certificate by selecting 
> `Provide Your Own Certificate` option. 

First, run the `raven/srv-a/run.sh` (Linux) or `raven/srv-a/run.ps1` (Windows) script. This should start the RavenDB instance
and open your browser automatically. If this does not happen, look for the `"Server available on: <url>"` line on the 
command line and go the the specified url. 

You should see a screen similar to Figure 13.2. 

> **Automatic certificate generation requires a (free) license**
>
> `Let's Encrypt`'s free certificate generation helps a lot, but to actually generate a certificate, you need to have a domain
> that you own that you can use to generate the certificate. In many cases, you are deploying only internally, without having
> any external access.
>
> To alleviate a lot of the complexity of such deployment, RavenDB take upon itself to handle all of that. The RavenDB team is
> managing a set of root level domains from which it allocates subdomains to users, and RavenDB uses these subdomains to create
> the certificate.
> 
> These domains looks like: `<name>.development.run` or `<name>.ravendb.community`^[The exact domain you'll get depend on the
> the license you are using. If you are using a development license, you'll get `development.run`, if you are using a 
> community license you'll get `ravendb.community` and `ravendb.run` for commercial licenses.],
> where you can provide any `<name>` you want as long as it wasn't taken first by someone else. 
>
> Names are provided on a first come, first serve basis, and once they have been given to a user, they are associated with the
> user permenantly. This is because we need to be sure that only a single user ever got a specific domain. 
> This is to avoid the option of two users having certificates to the same domain, which will allow them to capture traffic 
> meant to the other.
> 
> You can request a free license from the RavenDB site and use that license during the setup process to register your domain name
> and then get the certificate to run RavenDB securely. That license is tied then tied to the domain and can be used later to 
> modify the domain's settings and to generate another certificate. 

On the setup screen, select the `Generate Let's Encrypt Certificate`, provide the license that you recieved over email (you can
get a free license by registering on the RavenDB website) and click next. You can see the next screen in Figure 13.3.

![The domain selection page allows you to select the name of your cluster.](./Ch13/img03.png)

The domain selection screen in Figure 13.3 is where you can select your domain name. This will also be how you'll usually refer to
your cluster. If this is the first time you are running through the process, you'll need to select name. As long as it isn't already
taken by someone else, you will be granted the name. If you have already setup RavenDB, you'll be able to select from the domain 
names you have previous registered. After selecting the domain name, click next. 

You'll be faced with the cluster setup, as shown in Figure 13.4. We're setting a local cluster, so set the `HTTP Port` to `443`,
the `IP Address` to `127.0.1.1` for node `A`. Note that this is `127.0.1.1`, _not_ `127.0.0.1`, which you are more used to. In this 
case we are relying on the fact that the entire `127.x.x.x` IP range has been reserved for the loopback device. Why use `127.0.1.1`,
then? Because we want to bind to the HTTPS port 443 by default, and it is unlikely that someone has already bound to `127.0.1.1:443`.

For production, you'll obvious not have to fight some other program^[I'm looking at you, Skype.] for access to a port, but I'm assuming
that you will run this exercise on your own machine to start with. You can see what this should look like in Figure 13.4. 

![Setting up a cluster of 3 machines, including setting of DNS records](./Ch13/img04.png)

If you'll look at the left portion of Figure 13.4, you'll see a list of nodes (`A`, `B` and `C`). As we already seen in 
[Chapter 6](#clustering-setup), we usually use the letters of the alphabet to name the nodes in the cluster. Click on `Add node` 
to add node `B` on your system and give is the IP `127.0.1.2`, thenk do this again for node `C` with the IP `127.0.1.3`.

If you are deploying to multiple machines, make sure that the IPs
are correct, that the ports are available and that the firewall permits the machines to talk to one another. In particular, note that
RavenDB actually uses two ports, one for HTTPS (usually 443) and one for TCP (usually 38888). You'll need to open both boths for 
incoming connections in the firewall.
The setup process supports binding to an internal IP and register the DNS name to an external IP (common in cloud platforms such as
AWS, Azure, etc).

Assuming you went with `127.0.1.1` and local cluster, you are now ready and can hit the next button. The next little bit should take 
about a minute or two, as RavenDB contacts `Let's Encrypt`, completes the DNS challenge to prove that you are now in control of 
the domain you have selected (in my case, this is `raven.development.run`, yours will be different and unique to you, of course).
Along with generating the certificate via `Let's Encrypt`, RavenDB does another very important action, it updates the _global_ 
DNS records to setup the domain name you have chosen with the IPs you have setup.

> **Troubleshooting the setup**
>
> As mentioned, this isn't going to be a step by the step guide to setup RavenDB. The online documentation goes through that in 
> great detail. If you run into any issues during this process, the following quick list should include the most common problems
> to deal with, and the online docs have full troubleshooting guidance.
>
> First, _read the error_. We have gone to great lengths to make sure that RavenDB errors are clear, consice, tell you what is 
> wrong an in many cases how to fix it. Common reasons for setup failure include:
>
> * Another application is already listening on the port.
> * On Linux, using port 443 usually requires root. You can either use a higher port (such as 8443) or use 
>   `sudo setcap CAP_NET_BIND_SERVICE=+eip /path/to/Raven.Server` to grant the RavenDB binary the rights to bind to a low numbered port.
> * Check if your anti virus / proxy is preventing RavenDB from binding to the network or clients to access it.
> * Your firewall is blocking incoming network connections, so you cannot connect to RavenDB.
> * Your DNS server is aggresively caching and you can't see the DNS updates made by RavenDB to the domain you have chosen. 
>   You can set your DNS server to `8.8.8.8` to avoid that or wait about 30 minutes for the usual refresh cycle.

Upon successful completeion of the setup, you'll see some informative output with details about your newly defined cluster.
In addition to the success message from the setup, your browser has also downloaded a `.zip` file. This file is critical and should
be saved carefully. You can see the contents of this file in Figure 13.5.

![Contents of the setup `.zip` file with everything you need to get your cluster started.](./Ch13/img05.png)

The file contains a client certifcate with admin level privileges to the cluster (`admin.client.certificate.raven`), the license used
and a readme file with additional setup instructions. In Figure 13.5 you can also see that there are three directories there, `A`,`B` 
and `C`. These contain the configuration _and the server certificate_ for each of the nodes in the cluster. Depending on your 
organization policies, you might need to store them them separately. We'll touch on that toward the end of this chapter. 

You should install the admin client certificate into your browser. If you are using Chrome, double clicking on the certificate should 
usually start the wizard to do so. Otherwise, use `Settings`, `Manage certificates`, `Import...` inside Chrome to import the client
certificate. 

> **The certificate is generated locally**
>
> This is for the technically inclined, regarding the security of the generated certificate. The RavenDB setup process is running
> locally on your machine. The only involvement of an external party (aside from `Let's Encrypt`, of course) is when 
> the `api.ravendb.net` service register the `Let's Encrypt` challenge in the DNS.
>
> The actual certificate sign request (CSR) is generated on your local machine, as is the private key for the certificate. Neither
> `Let's Encrypt` nor `api.ravendb.net` are exposed to your private key nor can either party re-create the certificate / private
> key. The certificate is genareted locally, under your own control. From there, the safety of the certificate is in your hands.
> We'll discuss some management strategies for that toward the end of this chapter.

Once that is done, you can click on the `Restart Server` button at the end of the setup screen. The browser should then redirect you
to the RavenDB management studio. However, at this point we are actually running a secured server, and you need to authenticate 
yourself to the server. This is the purpose of installing the admin certificate. You should get a dialog similar to the one shown
in Figure 13.6 and should select the appropriate certificate (if you have more than one)^[If you made a mistake with the certificate
select and chose the wrong one (or cancelled the dialog), you'll need to close Chrome and start it again to make it forget this 
decision. Creating an incognito window also works, and might be easier.].

![Chrome certificate selection dialog for your RavenDB instance](./Ch13/img06.png)

You should now see the see the studio's dashboard. A new feature that is now available is the "Who am I?" notification. Look at the 
bottom of the window, you'll see a bright green lock icon. Hovering on that will reveal to you what certificate you are using and
what permissions are available to you. You can see an example of this in Figure 13.7.

![The "Who am I" feature gives you details about how you authenticated to the server and the permissions you are granted.](./Ch13/img07.png)

At this point, we are done setting up a single node, but we haven't actually setup the cluster, have we? In the studio, go to 
`Manage Server` and then `Cluster` and you'll see that node `A` is up but both `B` and `C` show up in red. This is because we haven't
even started either `B` or `C`.

#### Setting up the rest of the cluster

You can now run the `raven/srv-b/run.sh` (Linux) or `raven/srv-b/run.ps1` (Windows) script. This will start up a new instance of RavenDB,
also in initial setup mode. Unlike the previous iteration, we don't need to do much. At the bottom of the setup window, you have the 
`Continue cluster setup for new node`, as you can see in Figure 13.2. Click on that button and then upload the `.zip` file that you 
got from the first node, select node `B` in the drop down and then click `next`.  You can see how this looks like in Figure 13.8.

![Completing the setup process for the second node in the cluster](./Ch13/img08.png)

You should get the success screen again, with details about the setup. Click on `Restart server` at the bottom and you are done. If you'll
look now under the `Manage Server` and then `Cluster` in node `A` you'll see that it had recognized that node `B` is functional, 
connected to it and fully joined it to the cluster. You can now repeat the process with node `C` to complete the cluster setup.

This is it, you now have a cluster of three nodes. You have a valid certifcate that is broadly trusted that is used to secure all
access to the cluster. Authentication to the cluster is done via the generated admin client certificate (and you'll learn more about
authentication in RavenDB later in this chapter). The setup process also updated the DNS system for your cluster, so you can put
`https://a.raven.development.run`^[Your URL will obviously be a bit different] and go node `A`, or `https://b.raven.development.run`
to go to node `B`, etc. 

> **Updating the certificate over time**
>
> A certificate has a time limit built into it. In the case of `Let's Encrypt`, the certificates are generated for a maximum on 
> 90 days. This means, operationally speaking, that you'll need to replace them. You don't usually need to worry about that, in
> the same way that the certificate was automatically generated for you during the setup, RavenDB will make sure to update the
> certificate when it is needed (with plenty of buffer to avoid issues).
>
> RavenDB will take care of updating the certificate, distributing the new certificate to the rest of the cluster, orchestrating
> the certificate replacement (this is done live, without any downtime on any node) when all the nodes have the new certificate.
>
> If there are any issues in the process, RavenDB will alert the operations team in plenty of time to handle it. It will also 
> be retry on regular basis to avoid being blocked by any transient errors. 

In other words, you are pretty much done as far as the setup is concerned. What is left is to create databases, create certificates
so applications and users can connect to the cluster (and not as the cluster admin!) and that's _it_. Even ongoing maintenance in 
the form of refreshing the certificate is done for you automatically and transparently.

#### Security concerns with the automated setup

The automated setup is nice. I'm really happy about it and it can save you a lot of time an effort. It is also a feature that is 
primarily aimed at developers running a secured system locally, small applications that don't get a lot of operator attention. 
However, that has a cost. In order to make this process seamless, RavenDB uses `api.ravendb.net` to answer the `Let's Encrypt`
DNS challenge and update the DNS records to point to your server. 

This is provided as courtesy for RavenDB users, but for mission critical systems, it is recommended that your operations team
will take ownership on that. The actual certificate is generated on _your_ machine, not on any machine that is owned by us, 
however, given that your don't own the domain name for you cluster, you have to go through `api.ravendb.net` for any change.

We are not in the business of providing hosting, nor is there any 24x7 support for things like "I need to change the server IP
address on this node". For production systems, you are encouraged to run this on systems that you control.

A security audit of your system will also point out that since we own the domain name, we can generate our own certificate for
your cluster domain. We obviously promise to do no such thing (and you can check the certificate transparency logs to verify
that), but running a critical system is best done on your own systems and under your control

> **Certificate transparency**
>
> Every certificate generated by a Root CA is registered in the public certificate transparency logs. This means that in order
> for a certificate to be trusted, it must be logged. We have carefully designed the structure of the RavenDB default domain
> name so we can't genearte certificates for your cluster' domain without it being immediately visible in the certificate
> transparency logs. 
>
> The technical detials is that your nodes URL look like: `<node-tag>.<cluster-name>.development.run`, where RavenDB controls
> the `development.run` domain. We can generate a wildcard certificate for `*.development.run`, but that will not be valid
> for nested domains. In the case of the `raven` cluster name, you'll need certificate that will be valid for URLs such as
> `https://a.raven.development.run` and a wildcard certificate on the root domain will not do, only a certificate for 
> `*.raven.development.run` will be acceptable, and that will be very visible in the certificate transparent logs. 

Nevertheless, consider the automated setup to be something akin to training wheels on a bicycle. Really useful to get you 
going, but something that you intend to grow out of in the fullness of time. 

The setup process when you provide your own certificate is actually _faster_ and provide the same experience and ease of use, 
without having to worry about 3rd parties. 

### Authentication and authorization

We now have a RavenDB cluster setup with encrypted channels of communication and strong authentication for clients. We can use
the admin client certificate that was generated during the setup to authenticate ourself to the cluster as the admin, which
gives us the ability to create additional certificates and manage permissions.

> **Certificates are not users**
>
> It's tempting to consider a certificate as a simple replacement for a user/pass. In other words, to consider that a certificate
> is just another way for a user to authenticate. I would suggest avoiding this line of thinking. Instead, consider the access
> to the cluster (and specific databases inside it) to be on an application basis, rather than a user. 
>
> In other words, don't give out certificates to specific users, but to applications. For example, `orders.northwind` or 
> `fulfilment.northwind`, for the relevant applications. It may sound like a petty decision, but it actually have profound 
> implications to the way you view the security of the system.
>
> The problem with trying to model security as users is that your users aren't (and shouldn't) accessing and manipulating the
> data directly. Instead they are going through your application, where business rules, validation and authorization decisions
> can be made with the full knowledge of your domain and application.
>
> The example I like to give is an employees management system and a `VacationRequest`. Any employee can create a `VacationRequest`
> document at any time, and modify it freely and it is in the `Submit` state. At this point, the employee's manager can then 
> `Approve` or `Deny` the request. From the point of view of the database, all of the operations (`Request`, `Submit`, `Approve` 
> and `Deny`) are _business_ operations. As far as the database is concerned, those are all just reads and writes.
> 
> Attempting to push business level authorization decisions (such as "only an employee's manager can `Approve` a 
> `VacationRequest`") to the database lead to a lot of complexity for both the application and the database and can cause data
> security leaks. 

Managing certificates and permissions is done via the studio in the `Manage Server`, `Clusters` page (naturally, you can also 
define certificates through an API, so this is easily automated). You can see how this looks like in Figure 13.9.

![Client certificate screen in the RavenDB studio](./Ch13/img09.png)

In order for RavenDB to accept a client certificate as valid, it _must_^[With one exception, the server's own certificate is
always acceptable as a client certificate.] be registered with the cluster. Note that RavenDB does not validation on the 
certificate itself, aside from verifying that the certificate itself has not expired, as long as the certificate was registered
with RavenDB, that is fine. 

In particular, RavenDB does not check the certificate chain of trust, the validity period of the certificate that signed the 
client certificate or place any requirements at all on the certificate or its properties aside from being usable for
`Client Authentication`. This is important, because the generated admin client certificate, for example, is signed by the
server certificate that RavenDB is using.

In the case of the `Let's Encrypt` setup that we run in the previous section, the generated server certificate is only valid for
three months, but the admin client certificate (that is signed by the generated server certificate) is valid for five years. Even
though the signing certificate has expired (and since replaced), RavenDB will continue to accept the admin client certificate until
the client certificate itself will expire. 

> **Certificates expire, plan for this**
>
> By default, RavenDB generates client certificates with a validity period of 5 years. If you need a different duration, you 
> can generate your own client certificates and use that. Regardless of the validity period, it is important to understand that
> certificates can and do expire. A certificate that run in production just fine for years may expire one day and cause you 
> to scrubmle, figuring out exactly where it is stored and registering a new certificate.
>
> RavenDB will warn about soon to be expired certificates (both the cluster certificate and client certificates) but you 
> should have a plan in place to ensure rotation of certificates at regular interval. That is a good security practice, but
> it is also good operations practice, because it means that you practice actually replacing certificates, so your operations
> team can actually do that when needed.

Creating a new client certificate is easy, click on the `Generate client certificate` button, you should see a screen similar
to Figure 13.10.

![Generate new client certificate and assign permissions to it.](./Ch13/img10.png)

In Figure 13.10 you can see the creation of a new certificate, `uat.northwind` and that we granted it read/write access to
the `test` database. Once you click on the `Generate` button, a new certificate will be generated on the server, registered
with the appropriate permissions and the browser will download the newly generated certificate file.

It's important to understand that on the server side, RavenDB only keeps track of the certificate _public_ information. In 
other words, the private key of the client certificate is never persist to RavenDB. If you want to register an existing 
client certificate with RavenDB, you can do so with the `Upload client certificate`, you don't need to upload the private
key, only the public information about the certificate.

> **Certificates and permissions are cluster wide**
>
> You can make modifications to the trusted certificates and to the permissions assigned to them from any node in the system.
> Modifying the cluster is a cluster operation and will be reflected on any node in the cluster. 

Internally, the only details about the certificates that RavenDB keep is the certificate subject, expiration and most 
importantly, the certificate thumbprint, which is used to identify the certificate when a connection comes in.

#### Security clearances and permissions in RavenDB

A complex security system has many places where it can fail, just due to its complexity. RavenDB's security was design
to be simple and obvious. There are three clearance levels available to the system, only two of which are generally 
applicable for your needs. The commonly used clearances are:

* Cluster administrator - that's you. The admin cluster certificate that was generated during the initial setup is one
  such role. It has access to _everything_ and can do _any_ operation. This is the equivalent of `root` in Linux. 
* User - this is a certificate that needs to be assigned permissions to specific databases. It is limited to the permissions
  explicitly given to it.

There is also the `Operator` clearance level, which is similar to the cluster administrator in scope, but is limited with the 
kind of operations it can do on the cluster. This is typically only used in cloud environments when the host is the one that 
manages the cluster and the operator can modify settings within the cluster, but not impact the cluster itself.

> **The `cluster node` clearance alias**
>
> If you look closely at Figure 13.9, you'll see that there is another clearance level that I didn't mention, the 
> `cluster node` role. What is the story about that? The `cluster node` se doesn't really exists. It is simply 
> an alias for the `cluster administrator` role. But why does it exists? Because the communication between
> different RavenDB servers also require authentication (discussed in more detail in the next section) and 
> we wanted to have a clear distinction between operators that were initiated by a user and operations that 
> were initiated by a node directly.
>
> In particular, a node may decide to forward a request to another node, and that is done with its own certificate.
> RavenDB ensures that all the validation and authorization checks were made on the original node, _before_
> forwarding the request with the node's own certificate to authorize it. 

Permissions in RavenDB apply only to certificates with the `User` security clearance level. Permissions apply to a particular
database or databases and determine whatever a certificate has access to that database and if so, at what level. The
available permissions are:

* Database admin - Read and write access to the documents in the database, query, create static indexes, setup backups,
  ETL processes, define the revisions retention and the conflict resolution policy, etc. Basically, any operation that is
  scope to the single database that this user is the administrator of.
* Read/Write - Can read and write documents, can query over documents and existing indexes, including creation of automatic
  indexes by the query optimizer, define and use subscriptions and in general do any non maintenance task on the databases
  that this user has access to.

Typically, a certificate will only have access to a single database, or very few (it's own application database and 
possibly a shared one for ETL, etc). 

RavenDB explictly does not have the notion of a readonly access mode. If you want to provide a user with access to the data
without the ability to modify it, give an access to its own database and setup external replication (or even RavenDB ETL, 
to decide exactly what is going to be exposed). Your source data cannot be read or modified by this user, and they have their
own copy of the data that they can work with in isolation.

> **Reminder: Only database admins can create static indexes**
>
> An important note about static indexes. These allow you to write code that will be executed as part of the indexing process.
> If a user have permissions to create a static index, they can use that to write code that does _anything_. It is awkward,
> but that is entirely possible.
>
> For this reason, static index creation is limited to database administrators only. Note that this also means that a 
> sufficently motivated user with database admin access can access _other_ databases. For the most part, we assume that if 
> you handed a user a database administrator access, you trust that user. 
>
> If a true security boundary is required between database administrators of different databases, the recommended mode is to
> split the databases to independent clusters, so the first administrator don't have any access to the second cluster.

Because static index creation requires higher security privileges, it is common to split that function off into a separate 
tool that is run in production with elevated permissions and only run with `Read/Write` permissions normally. 

#### Server to server authentication

We have talked about how certificates are used by RavenDB to identify the clients, but what about the servers? When we setup 
our cluster earlier in this chapter, we didn't concern ourselves with any security, so it seems. How can the different servers
in the cluster trust each other?

The answer to that is simple. Any time a RavenDB server talks to another node, it will idenitfy itself using the server 
certificate of this node. On the other side, we just need to recognize that server certificate, and from then on it can be 
handled just like any other client. 

> **I lost the keys to the kingdom, what now?**
> 
> Edge cases are always hardest thing that you have to deal with in development. In a security system, you need to consider
> what happens when you manage to lose all the keys to the system. What happens if you lost the client certificate that 
> it used to talk to RavenDB? At this point, RavenDB has no way of recognizing you and will rightly reject any requests
> as unauthorized.
>
> There are two ways to handle this. First, you can use the `rvn admin-channel` tool, which uses the operating system
> to ensure that you should have access to the RavenDB process. This gives the `root` user (or `Administrator` on Windows)
> the ability to get a back channel into RavenDB and run a few commands to get back on your feet (such as 
> `trustClientCert`, to register a new certificate with `Cluster Administrator` clearnace).
>
> If you have access to the server, you can also get the server's certificate, and use that, since a client that is 
> connecting using the same certificate as the one that the server is running is always trusted.

When running in a cluster, we typically use a wildcard certificate (such as `*.raven.development.run`) or a certificate that
contains multiple `Subject Alternative Names` (such as `a.raven.development.run`, `b.raven.development.run`, 
`c.raven.development.run`).

This means that all the nodes in the cluster are using the _same_ certificate. That leads to an interesting behavior, 
when a client connects to a server, and it is authenticating using the same certificate that the server itself is using.
When we recognize such an occurrence, we consider the connection to be trusted and grant it `cluster node` privileges. 
No need to register the certificate for this to work.

This means that if you need to connect to the server and don't have a client certificate registered, but can get the 
server certificate that the server is using, you can use that and it will be trusted without the admin having to take
any action.

Putting these two facts together, we can see that when we bring up a new node in the cluster, using the same certificate
as the other nodes, it intrinsically knows that it can trust the other side and this greatly simplify the process of 
setting up a secured cluster.

You _can_ run RavenDB cluster with a different certificate for each node, but you'll need to register all the certificates
in the cluster. That is a bit of a chicken and egg problem, because you can't _have_ a cluster until the nodes trust 
each other. The `rvn admin-channel` tool solves this by providing the `trustServerCertificate` command that you can run
on each of the nodes, teaching each of the ndoes that they can trust the others.

Updating the cluster certificate at runtime is a delicate dance. You need to first distribute the new certificate 
(including the private key) to all the nodes, then register the new certificate as a `cluster node`, then start 
switching over all new connections to use the new certificate. Different nodes may do that at different times, which is
why we need to ensure that the new certificate is registered expilcitly.

RavenDB will manage this dance for you automatically. When you are using `Let's Encrypt`, RavenDB will automatically
refreshing the cluster certificate about a month before it is due to expire. Then the actual certificate replacement
will take place once all the nodes confirmed that they have the new certificate. You can also trigger this process
manually with your own certificate using the `Replace cluster certificate` button, as shown in Figure 13.9.

#### Authentication between clusters

We talked so far about certificates and trust within a cluster. We also need to talk about how this works when we 
are running mulitple clusters and need to securely talk from one cluster to another. Whenever a RavenDB server 
communicates with the outside world, it uses its own server certificate as the client certificate for the 
connection, so it will be properly identified on the other side.

Inside the same cluster, the nodes are typically using the same cluster, so they will know that they can trust the
connection. But when we are talking about separate clusters, we'll need to explicitly tell the remote cluster that
it can trust our cluster.

In Figure 13.9, you can see the `Export cluster certificates` button. Clicking on this will download a `.pfx` file
containing the public portion of all the nodes in the cluster (everything that has a `cluster node` clearance level).
You can take that `.pfx` file to a different cluster and register it using `Upload client certificate`, givein it 
the appropriate permissions for your needs.

> **Handling automatic certificate refresh in cross cluster authentication**
>
> One wrinkle that you do have to deal with is when you are using cross cluster authentication and also have 
> automatic certificate updates. In such a case, the remote cluster is not familiar with the new certificate
> and you'll need to manually add it to the remote cluster. 

This is often used as part of external replication and RavenDB ETL processes. These are commonly used between 
different clusters. You'll note that you don't have to specify credentials as part of the ETL connection string
or when setting up external replication. The credentials are implicit in the cluster itself and uses the cluster 
identity.

### Externalizing certificate management

Certificates are considered to be of _high_ importance. If you have the certificate for a domain, you can 
eavedrop on communication to that domain, modify responses, pretend to _be_ that domain and in general do
a whole bunch of pretty nasty stuff, from a security point of view.

In many organizations, there are strict policies regarding how you are expected to manage certificate, because
of their sensitive nature. These policies range from let's not put them on a publicly shared folders to only store
certificates on Hardware Security Modules with Level 4 certification. 

The number of variety of policies regarding such a critical part of securing your certificates is astounding, and
RavenDB makes no attempt to accomodate all of them. Instead, we offer a choice. 

In the `Let's Encrypt` scenario we explored so far, the actual certificate is located in the server's folder, with
the `Security.Certificate.Path` configuration parameter pointing to the file. The certificate file is not encrypted
on the disk.

> **Default security of the certificate**
>
> We could have added additional security measures to the `Let's Encrypt` certificate, such as storing it on the 
> file system in an encrypted form. But then we would need to store the certificate password somewhere. Indeed,
> RavenDB supported encrypted certificates and you can provide a password using the `Security.Certificate.Password`
> configuration option. But this just move the problem of securing the certificate password.
>
> Given that this certificate is routinely refreshed by RavenDB and can be re-generated at will using the license
> file (which is also typically sitting right next to the certificate), there is no point in trying to secure this
> too much. If your threat model calls for securing the certificate from an attacker that has physical access to
> the files on disk, you should not be using the `Let's Encrypt` setup mode, but provide your own certificate and
> use mode advanced methods to provide the certificate, as we'll soon explore.

Given the wide variety of options and policies on certificate storage, if you need something more sophisticated 
than a certificate file on disk (with an optional password), you need to tell RavenDB how to get the certificate
yourself. This is done by two configuration options `Security.Certificate.Exec` and 
`Security.Certificate.Exec.Arguments`.

You can see a sample of how this can be done in Listing 13.1. 

```{caption="Partial configuration of shelling out to a user defined method for obtaining the certificate" .json}
{
	"ServerUrl": "https://0.0.0.0",
	"PublicServerUrl": "https://a.raven.development.run",	
    "Security.Certificate.Exec": "powershell",
    "Security.Certificate.Exec.Arguments": "get-cert-by-id.ps1 90F4BC16CA5E5CB535A6CD8DD78CBD3E88FC6FEA"
}
```

The idea is that instead of RavenDB having to support all the various options, policies and rules around storing
certificates, you tell RavenDB that whenever it wants to get the certificate, it just needs to run the specified
process and read the certificate from the standard ouptut. Listing 13.2 shows the implementation of the 
`get-cert-by-id.ps1`.

```{caption="PowerShell script to get a certificate by id from the current user's key store" .ps1}
try
{
    $thumbprint = $args[0]
    $cert = gci "cert:\CurrentUser\my\$thumbprint"
    $exportedCertBinary = $cert.Export("Pfx")
    $stdout = [System.Console]::OpenStandardOutput()
    $stdout.Write($exportedCertBinary, 0, 	
    	$exportedCertBinary.Length)
}
catch
{
    write-error $_.Exception
    exit 3
}
```

The output of the script is the `.pfx` binary data, sent to the standard output. You can report errors using
the standard error, which will be included in the RavenDB error message. In this way, you can integrate RavenDB
into your existing policies with very little hassle. 

For example, if you wanted to get the certificate from Azure Vault, you'll use: `Get-AzureKeyVaultSecret` cmdlet.
You are also not limited to just using PowerShell and are free to shell out to any process and method you'll like. 

#### Refreshing the certificates manually

One thing that we need to be aware 

### Summary