
# Deep dive into the RavenDB Client API

In this chapter we are going to take a deep dive into how the client API works. We are going to show mostly C# code examples, but the 
same concepts apply to any of the RavenDB Client APIs, regardless of platforms, with minor changes to make it fit the platform.

There are still some concepts that we haven't gotten around to (clustering or indexing, for example) which will be covered in 
their own chapters. But the Client API is very rich and has a lot of useful functionality on its own, quite aside from the server
side behavior. 

We already looked into the document store and the document session, the basic building blocks of CRUD in RavenDB. But in this chapter we
are going to look beyond the obvious and into the more advanced features. One thing we'll _not_ talk about in this chapter is querying.
We'll talk about that extensively in [Chapter 9](#map-indexes), so we'll keep it there. You already know the basic of querying in RavenDB
but there is a _lot_ more power waiting for you to discover there.

This chapter is going to contain a _lot_ of code examples and discuss the nitty gritty details of using the client. It is also divided into 
brief sections that each deal with a specific feature or behavior. I suggest reading over this to note what the capabilities of RavenDB are
and coming back to it as needed in your application.

For the rest of this chapter, we'll use the classes shown in Listing 4.1 as our model, using a simplified help desk as our example. 

```{caption="Simplified Help Desk sample model" .cs}
public class Customer
{
	public string Id { get; set; }
	public string Name { get; set; }
}

public class SupportCall
{
	public string CustomerId { get; set; }
	public DateTime Started { get;set; }
	public DateTime? Ended { get;set; }
	public string Issue { get; set; }
	public List<string> Comments { get; set; }
}
```


## Writing documents

Writing documents in RavenDB is easy, as we saw in [Chapter 2](#zero-to-ravendb). If we want to create a new support call, we can use the code in 
Listing 4.2 to do so.

```{caption="Creating a new support call using the session" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);
	session.SaveChanges();
}
```

This is basic behavior of RavenDB, and how you would typically work with saving data. But there are lot of additional things that we can do when
writing data. For example, the user might have sent us some screen shots that we want to include in the support call. 

### Working with attachments

You can add attachments to a RavenDB document to store binary data relating to that document. Let us assume that the user have sent us a screen shots
of the problem along with the call. Listing 4.3 shows how we can store and retrieve the attachments.

```{caption="Saving attachments to RavenDB as part of opening the support call" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);

	foreach(var file in attachedFiles)
	{
		session.Advanced.StoreAttachment(call, file.Name, file.OpenStream());
	}

	session.SaveChanges();
}
```

Note that we are using the session to store both the support call document and any attachments that the user might have sent. An attachment is basically
a file name and a stream that will be sent to the server (with an optional content type). When the call to `SaveChanges` is made, the RavenDB Client API
will send both the new document and all of its attachments to the server in a single call, which will be treated as a transaction. Both the document and
the attachments will be saved, or both will fail.

That was easy enough, but how do we get those back? The list of attachments for a particular document is accessible via the document metadata, as shown
in Listing 4.4. 

```{caption="Getting the list of attachments for a support call" .cs}
using(var session = store.OpenSession())
{

	//TODO: Unstable API

	var call = session.Load<SupportCall>("SupportCalls/238-B");
	var attachments = session.Advanced.GetAttachmentNames(call);

	// render the call and the attachment names
}
```

Calling `GetAttachmentNames` is cheap, since the attachments on a document are already present in the document metadata, which we loaded as part of
getting the document. There is no server side call involved. Note that the result of `GetAttachmentNames` does not include the _content_ of the 
attachments. To get the attachment itself, and not just its name, you need to make a separate call, as shown in Listing 4.5.

```{caption="Getting an attachment content" .cs}
using(var session = store.OpenSession())
{
	var call = session.Load<SupportCall>("SupportCalls/238-B");
	var attachments = session.Advanced.GetAttachmentNames(call);

	//TODO: Unstable API

 	using(var stream = session.Advanced.GetAttachment(call, attachments[0].Name))
 	{
		// process the content of the attachment 	
 	}
}
```

Each call to `GetAttachment` will make a separate call to the server to fetch the attachment, if you have a lot of attachments, be aware that 
fetching all of their information can be expensive due to the number of remote calls that are involved. 

### Working with the document metadata

In the attachments section, we noted that attachment information is stored in the document metadata. RavenDB used the metadata for a lot of things,
most of them you don't generally care about (etag, change vector, etc). But the document metadata is also available to you for your own needs and 
use. 

Actual use case for direct use of the document metadata are actually pretty rare. If you want to store some information, you'll typically want to 
store it in the document itself, not throw it to the sidelines in the metadata. Typical use cases for storing data in the medata are corss cutting
concerns. The preeminent one is auditing (who editted this document, for example). 

In order to demonstrate working with the metadata, we'll consider the case that creating a support call is a complex process that has to go through
several steps. In this case, while we saved the document to RavenDB, it is still in draft status. Typical modeling advice would be to model this 
explicitly in the domain (so you'll have a `IsDraft` or `Status` property on your model), but for this example, we'll use the metadata. You can see
the code for setting a draft status in the metadata in Listing 4.6.

```{caption="Setting a metadata flag as part of creating a new support call" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);

	var metadata = session.Advanced.GetMetadataFor(call);
	metadata["Status"] = "Draft";
	
	session.SaveChanges();
}
```

We can call `GetMetadataFor` on any document that has been associated with the session. A document is associated with the session either by loading
it from the server or by calling `Store`. After the document has been associated with the session, we can get its metadata and manipulate it.

Changes to the metadata count as changes to the document and will cause the document to be saved to the server when `SaveChanges` is called. 

### Change tracking and `SaveChanges`



### Optimistic concurrency and change vectors

#### Pessimistic locking

Metadata, locked by


### Patching documents


### Bulk insert


### Deferring commands

### Waiting for replication or indexing

## Reading documents

### Lazy requests

### Streaming data

## Cross cutting concerns on the client

### Conventions

### Listeners

metadata, auditing

## Versioning and revisions

### Changes API


## How RavenDB uses JSON

The RavenDB Server and the RavenDB C# Client API use a dedicated binary format to represent JSON in memory. The whole of [Chapter 27](#blittable)
is dedicted to this format, but it is worth understanding a bit about how RavenDB think about JSON even at this stage. Typically you'll work
with JSON documents in their stringified form, a set of UTF8 characters with the JSON format. That is human readable, cheap to parse and quite
easy to read and work with.

But JSON parsing requires you to work in a streaming manner, which means that to pull up just a few values from a big document, you still need to
parse the full document. As it turns out, once a document is inside RavenDB, there are a _lot_ of cases where we want to just get a few values 
from it. Indexing a few fields is very common, and parsing the JSON each and every time can be incredibly costly. Instead, RavenDB accept the JSON
string on write and turn it into an internal format, called Blittable^[I don't like the name, but we couldn't come up with anything better]. 

A blittable json document is a format that allows RavenDB random access to any piece of information in the document without having to parse the 
document with property traversal cost of (amortised) O(1). Over the wire, RavenDB is sending JSON strings, but internally, it is all blittable.
The C# client is also using blittable format internally, since that helps a _lot_ with memory consumption and control. You generally won't see
that in the public API, but certain very low level operations may expose you to it.

Blittable documents are immutable once created and _must_ be disposed after you are done with them. Since the document session will typically hold
such blittable objects, the session _must_ also be disposed to make sure that all the memory it is holding is released. An important consideration
for the overall performance of RavenDB is that blittable documents always reside in native memory. This is done because it allows RavenDB fine grained
control over where and how the memory is used, reused and its life cycle. 

On the client side, using the blittable format means that we have to deal with reduced memory consumption and reduced fragmentation, and it also reduce
the speed of caching significantly.

## Caching

### Aggresive caching

## Data Subscriptions

### Versioned Subscriptions
