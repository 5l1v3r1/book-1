
# Zero to RavenDB

[zero-to-ravendb]: The very first steps we need to take in our journey to understand RavenDB is to actually getting
it running on our machine, so we can actually get things done. I'm deferring discussion on what it is, how it works,
etc to a later part of this book, because I think that having a live version that you can play with will make it 
much easier to understand RavenDB.

## Setting RavenDB on your machine

For this section, I'm assuming that you are a developer trying to get a RavenDB instance so you can explore it. I'm
going to ignore everything related to actual production deployments in favor of getting your setup in as few steps 
as possible. Full discussion on how to deploy, secure and run RavenDB in product is available in 
[Chapter 19](#prod-deploy).

I'm going ot go over a few quick install scenarios, and you can select whichever one makes the most sense to your
setup. After that, skip to the next section where we'll actually start using RavenDB.

### Running on docker

What is probably the easiest way to get RavenDB is via Docker. If you already have Docker installed, all you need to
do is run the following command:

	docker run -e AllowAnonymousUserToAccessTheServer=true 
	       -p 8080:8080 ravendb/ravendb

And Docker will get the latest RavenDB version and spin a new container to host it. Note that we run it in 
developer mode, without any authentication.

The output of this command should look something like Listing 2.1.

```{caption="RavenDB Server Output"}   
       _____                       _____  ____
      |  __ \                     |  __ \|  _ \
      | |__) |__ ___   _____ _ __ | |  | | |_) |
      |  _  // _` \ \ / / _ \ '_ \| |  | |  _ <
      | | \ \ (_| |\ V /  __/ | | | |__| | |_) |
      |_|  \_\__,_| \_/ \___|_| |_|_____/|____/


      Safe by default, optimized for efficiency

 Build 40013, Version 4.0, SemVer 4.0.0-beta-40xxx, Commit ca31ca1
 PID 6, 64 bits
 Source Code (git repo): https://github.com/ravendb/ravendb
 Built with love by Hibernating Rhinos and awesome contributors!
+---------------------------------------------------------------+
 Listening to: http://10.0.75.2:8080
 Server started, listening to requests...
 Running as Service
 Tcp listening on 0.0.0.0:38888
 ```

The most important piece of information you have there is the `Listening to: http://10.0.75.2:8080`, which tells you
the URL to put in your browser to access the newly installed instance.

### Running on Windows

To setup RavenDB on Windows you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Windows x64, in this case) and download the `zip` file containing the binaries.

Extract the file to a directory and then run the `Start.cmd` script or `Server\Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing:

	Server\Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Running on Linux

To setup RavenDB on Linux you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Linux x64, most likely) and download the `tar.bz2` file containing the binaries.

**TODO: http://issues.hibernatingrhinos.com/issue/RavenDB-7020 ** Need to verify if we need `dotnet` or how to run
directly from the `tar.bz2` file on a brand new machine.

Extract the file to a directory and then run the `run.sh` script or `./Server/Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing this
command:

	./Server/Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Using the live demo instance

Without installing anything, you can point your browser to 
[http://4.live-test.ravendb.net](http://4.live-test.ravendb.net?source=book) and access the public demo instance 
that we have available. This is useful for quick checks and verifications, but it isn't meant for for anything 
more serious than that. 

Obviously, all data in the live instance is public, and there are no guarantees about availability. We use this 
instance to tryout the latest versions, so that is also a consideration. In short, if you need to verify something 
small, go ahead and hit that instance. Otherwise, you'll need your own version.

## Your first database

By now, you have already setup an instance of RavenDB to work with, and managed to load the RavenDB Studio in 
your browser. For simplicity's sake, I'm going to assume from now on that you are running on the local machine
on port 8080. Point your browser to [http://localhost:8080](http://localhost:8080) and you should be greeted with
an empty RavenDB instance. You can see how it looks in Figure 2.1.

![Empty RavenDB node](./Ch02/img01.png)

What we have right now is a RavenDB node that is a self contained cluster^[Actually, that is not really the case, 
but the details on the state of a new node are a bit complex and covered in the [Chapter 5](#clustering-setup)].
Now that we have a running node, the next stage it to create a new database on this node. 

You can do that by clicking on the `New database` button and naming it `Northwind`, accepting all the defaults for
the dialog. We'll discuss what all of those mean in [Chapter 19](#prod-deploy). Click on the `Create` button and 
that is pretty much it, your new database is ready, you can see how this looks like in Figure 2.2.

![New empty database](./Ch02/img02.png)

Of course, this new database contains no data, which make it a pretty hard to work with it. We'll use the 
`sample data` feature in RavenDB to have some documents that we can work with. On the left menu, go to `Tasks` and 
the to `Create Sample Data` and then press the `Create` button. 

Pressing this button will populate the database with the sample `Northwind` dataset. If you aren't familiar with 
Northwind, it is a sample dataset of an online store, including such common concepts as orders, customers and 
products. Let's explore this data set inside of RavenDB.

On the left menu, select `Documents` and you'll see a view similar to Figure 2.3. Showing the recently updates 
documents and the collections that were created. 

![Northwind documents view](./Ch02/img03.png)

Collections are the basic building blocks inside RavenDB. Every document belongs to exactly one collection, usually
based on the entity type of the document on the client. It is very similar to tables in a relational database, but 
unlike tables, there is no requirement that documents within the same collection will share the same structure or 
have any sort of schema.

Collections are very important to the way RavenDB organize and optimize the data internally, and the optimization 
opportunities that they provide are discussed at length in [Chapter 26](#stroage-layout). We'll frequently use 
collections to group similar documents together and apply some operation on them (subscribing to changes, indexing,
querying, ETL, etc).

Click on the `Orders` collection and then on the first document in the listing, which should be `orders/830'. The 
result is shown in Figure 2.4. This is the first time we are actually looking at the core reason RavenDb exists, 
a real JSON document.

![An orders document](./Ch02/img04.png)

If you are fammiliar with working with non relational databases, this is pretty obvious and non too exciting, but 
if you are mostly used to relational databases, there are several things to note here.

In RavenDB we are able to store arbitrarily complex data as a single unit. If you will look closely at Figure 2.4 
you'll see that instead of just storing a few columns, we can store rich information. By working with nested 
objects (`ShipTo` property) or arrays of complex types (the `Lines` property). 

This means that we don't have to split our data to statisfy the phyiscal constraints of our storage, we can store 
a whole object graph in a single document. We'll talk about modeling a lot more in [Chapter 3](#crud), but for now
I'll just mention that the basic modeling method in RavenDB is based around Root Aggregates and complete the 
picture in the next chapter.

In the meantime, you can explore the different collections and the sample data in the studio. We spent a lot of 
time and effort on the RavenDB Studio, and while I'll be the first to admit that it is pretty, looking at a 
syntax highlighted text editor isn't really that impressive. So let us see what kind of things we can do with the
data as a database.

## Working with the RavenDB Studio

This section will cover working the basics of working with data with the RavenDB Studio. If you are a developer, 
you're probably anxious to start seeing code, we'll get into that in the next section, no worries.

### Creating & Editing documents

When you look at a particular document, you can edit the JSON and click on `Save`, and the document will be saved.
There isn't really much to it, to be honest. Creating new documents is a bit more interesting. Let us create a new
category. 

In them left menu, go to `Documents` then under `Collections` click on `Categories` and then select 
`New document in current collection` as shown in Figure 2.5.

![New document in current collection](./Ch02/img05.png)

This will open the editor on a new document with an empty document based on one of the existing categories. Note
that the document id is set to `categories/`. Complete the contents of the document and save it. RavenDB wiil 
assign the document id automatically for you.

One thing that may not be obvious is that while the studio generates an empty document based on the existing ones,
there is no such thing as schema in RavenDB and you are free to add or remove properties and values and modify the
structure of the document however you feel like. This feature makes evolving your data model and handling more 
complex data much easier.


### Patching documents

The first thing we'll learn to do is how to do bulk operations inside the studio. On the left menu, go to 
`Documents` and then look at the bottom, where you'll find the `Patch` menu, click on it, and you'll see the 
screen shown in Figure 2.5.

![Patching the categories](./Ch02/img06.png)

Patching allows you to write a Javascript function that can modify the matching documents. To try this out, we'll
run a non trivial transformation on the `categories` documents, let us add location support and the ability to 
store the category name in mulitple languages using a patch script.

Put the code in Listing 2.1 in the `Patch script` text box.

```{caption="Patching categories for internationalization support" .js}   
	this.Name = [{"Lang": "en-us", "Text": this.Name }];
	this.Description = [{"Lang": "en-us", "Text": this.Description }];
```

You can click on `Test` and select a specific category document to view the results of running this operation on 
that specific document. The before & after results of running this script `categories/4` is showing in Figure 2.6.

![Internationalizing categories with Javascript patching](./Ch02/img07.png)

Patch scripts allows us to modify our documents en masse, and they are very useful when you need to reshape 
existing data. You can apply them on a specific document, a whole collection or all documents matching a specific
query.

It is important to mention that such bulk operations are not spanning a single transaction, but can be composed of
multiple transactions. For performance reasons, we might break such processing into multiple independnet (and 
concurrent transactions) that each process some portion of the data. Each independent transaction still maintain 
all the ACID properties, but not the patch operation as a whole.

### Deleting documents

Deleting documents in the studio can be done by going to a particular document and hitting the `Delete` button, if
you want to delete a particular document or deleteing a whole collection by going to the collection page (left 
menu, then `Documents` then selecting the relevant collection in the `Collections` menu), selecting all the 
documents in the header row and clicking the `Delete`.

### Querying documents

The previoud sections talked about how to Create, Update and Delete documents. But for full CRUD support, we still 
need to read documents. So far, we looked at documents whose ids were already known to us, or entire collections. 
In this section, we'll focus on querying documents based on their data.

In the left menu, go to `Indexes` and then to `Query`. This is the main screen for querying documents in the 
RavenDB Studio. As the index, select `dynamic/Companies` and in the query text box write `Address.Country: UK` and 
then click the query button. You can see the results of this query in Figure 2.8. 

![All companies in the UK query results](./Ch02/img08.png)

The studio can also guide you in how to compose queries (you probably noticed the `Add filter` helper when you 
wrote the query). We'll discuss indexes and querying at length in [Part III](#map-indexes). 

This section was meant to gigve you the basics of using the RavenDB Studio, not to be a thorough walkthrough of 
all the options. This is mostly here so you are familiar with the basics of using the studio and can see the 
results of what we are doing in code in the _next_ section, where we get to actual coding.

## Your first RavenDB program

We are finally at the good parts, where we can start slinging code around. For simplicity's sake, I'm going to use
a simple console application to explore the RavenDB API. Typically, RavenDB is used in web / backend applications, 
so we'll also explore some of the common patterns of organizing your RavenDB usage in your application later in 
this chapter.

The code in this book is using C#, but the documetnation can guide you on how to achieve the same results in any
supported clients. 

Create a new Console Application and run the command Listing 2.1 on the `Package Manager Console`.

```{caption="Installing RavenDB Client NuGet package" .powershell}   
	Install-Package Raven.Client 
		-Source https://www.myget.org/F/ravendb/api/v3/index.json 
		-IncludePrerelease
```

This will setup the latest client version for RavenDB 4.0 on the project. The next step is to add a namespace
refeence by adding `using Raven.Client.Documents;` to the top of the `Program.cs` file. 

And now we are ready to start working with the RavenDB client API. The first thing we need to do is to setup access
to the RavenDB cluster that we are talking to. This is done by creating an instance of `DocumentStore` and setting
configuring it as showing in Listing 2.3.

```{caption="Creating a document store pointed to a local instance" .cs }   
var store = new DocumentStore
{
    Urls = { "http://localhost:8080" },
    DefaultDatabase = "Tasks"
};

store.Initialize();
```

This code setups a new `DocumentStore` instance and let it know about a single node, the one running on the local
machine, and that we are going to be using the `Tasks` database. The document store is the starting location for 
all communication with the RavenDB cluster. It holds the configuration, caching, any customizations that you might
have applied, etc.

Typically, you'll have a single instance of a document store per application (singleton pattern) and use that same
instance for the lifetime of the application. Before we can continue, however, we need to go ahead and create the 
`Tasks` database in the studio, so we'll have a real database to work with. 

The document store is the starting location for all RavenDB work, but the real work horse that we typically use is
the session. The session is the one that will hold our entities, talk with the server and in general acts as the 
front man to the RavenDB cluster.

Before we can actually start using the session, we need _something_ to actually store. It is possible to work with
completely dynamic data in RavenDB, but that is a specific scenario that is covered in the documentation. Most of
the time, you are working with your entities. For the purpose of this chapter, we'll use the notion of tasks to 
build a simple list of things todo. 

Listing 2.4 shows how an class that will be saved as a RavenDB document looks like. 

```{caption="Entity class representing a task" .cs }   
public class ToDoTask
{
    public string Id { get; set; }
    public string Task { get; set; }
    public bool Completed { get; set; }
    public DateTime DueDate { get; set; }
}
```

This is about as simple as you can get, but we are only starting, so that is good. Let us create a new task inside
RavenDB, reminding us that we need to pick up a bottle of milk from the store tomorrow. The code to perform this
task (pun intended) is shown in Listing 2.5.

```{caption="Saving a new task to RavenDB" .cs }   
using (var session = store.OpenSession())
{
    var task = new ToDoTask
    {
        DueDate = DateTime.Today.AddDays(1),
        Task = "Buy milk"
    };
    session.Store(task);
    session.SaveChanges();
}
```

We open a new session and create a new `ToDoTask`. We then store the task in the session and then call 
`SaveChanges` to save all the changes in the session to the server. You can see the results of this in Figure 2.9.

![The newly created task in the studio](./Ch02/img09.png)

As it so happpened, I actually was able to go to the store today and got some milk, so I need to mark this task as
completed. Listing 2.6 shows the code required to handle updates in RavenDB.

```{caption="Loading, modifying and saving a document" .cs }   
using (var session = store.OpenSession())
{
    var task = session.Load<ToDoTask>("ToDoTasks/1");
    task.Completed = true;
    session.SaveChanges();
}
```

You can notice several interesting things even in this very small sample. We load the document and modify it, then
we call `SaveChanges`. We didn't need to call `Store` again. Because the `task` instance was loaded via the session
it was also tracked by the session, and any changes made to it would be sent back to the server when `SaveChanges`
is called. 

The document session implements the `Unit of Work` design pattern and make it much easier to work with complex 
behaviors, since you don't need to manually track changes to your objects and decide what needs to be saved and what
shouldn't. It also means that the only time that the RavenDB client will send updates to the server is when you call 
`SaveChanges`. That, in turn, means that you'll experience a reduced number of network calls, all of the changes 
will be sent as a single batch to the server. And because RavenDB is transactional, all those changes will happen as
a single transaction, either completing fully or not there at all.

Let us exapnd on that and create a few more tasks, you can see how that works in Listing 2.7.

```{caption="Creating multiple documents in a single transaction" .cs }   
using (var session = store.OpenSession())
{
   for (int i = 0; i < 5; i++)
   {
       session.Store(new ToDoTask
       {
           DueDate = DateTime.Today.AddDays(i),
           Task = "Take the dog for a walk"
       });
   }

   session.SaveChanges();
}
```

You can see the end result of all this playing around in Figure 2.10. We are creating 5 new tasks and saving them in 
the same `SaveChanges` call, so they will be saved as a single transactional unit.

![All the current tasks](./Ch02/img10.png)

Now that we have all those tasks, we want to start querying on the data. I want to know what kind of tasks I have for
the next couple of days. In order to get that information, I can use the query in Listing 2.8.

```{caption="Querying upcoming tasks using Linq" .cs }   
using (var session = store.OpenSession())
{
    var tasksToDo =
        from t in session.Query<ToDoTask>()
        where t.Completed == false &&
              t.DueDate >= DateTime.Today &&
              t.DueDate <= DateTime.Today.AddDays(2)
        orderby t.DueDate
        select t;

    foreach (var task in tasksToDo)
    {
        Console.WriteLine($"{task.Id} - {task.Task} - {task.DueDate}");
    }
}
```

Running the code in Listing 2.8 code gave the following output:
	
	ToDoTasks/2 - Take the dog for a walk - 5/14/2017 12:00:00 AM
	ToDoTasks/3 - Take the dog for a walk - 5/15/2017 12:00:00 AM
	ToDoTasks/4 - Take the dog for a walk - 5/16/2017 12:00:00 AM

The query code sample show us using Linq to performance queries against RavenDB with very little hassle and no ceremony
whatsoever. There is actually a _lot_ going on behind the covers, but we'll leave all of that to 
[Part III](#map-indexes).

Let us look at an aggregation query, the code in Listing 2.9 giving us the results of all the tasks per day.

```{caption="Aggregation query on tasks" .cs }   
using (var session = store.OpenSession())
{
    var tasksPerDay =
        from t in session.Query<ToDoTask>()
        group t by t.DueDate into g
        select new
        {
            DueDate = g.Key,
            TasksPerDate = g.Count()
        };

    foreach (var tpd in tasksPerDay)
    {
        Console.WriteLine($"{tpd.DueDate} - {tpd.TasksPerDate}");
    }
}
```

If you are familiar with Linq, there isn't much to say about the code in Listing 2.9. It works, and it is very obvious and 
easy to understand. If you _aren't_ familiar with Linq, I strongly recommend learning it. From the consumer side, it is
very beautiful. As someone who had to implement querying using Linq a few times, it is utterly atrocious, but lucky for
you, that isn't _your_ problem, it's mine.

So far, we explored a bit about the RavenDB API, we saved documents, editted a task and queried the tasks in various
ways. This was intended to get you familiarized with the API and how to work with RavenDB. The client API was designed
to be very simple, focusing on the common CRUD scenarios. Deleting a document is as easy as calling `session.Delete` 
and all the complex options that you would need are packed insided the `session.Advanced` property. 

Now that you have a basic understanding of how to write a `Hello World` in RavenDB, we are ready to dig deeper and 
see the client API in all its glory.

## The RavenDB Client API 

You've already used the document store to talk to RavenDB, but what is its purpose? The document store holds the RavenDB 
Cluster urls (so far, we used only a single URL, but in most cases our data will span multiple nodes), the default database
we'll talk to and the API Key that will be used to authenticate ourselves with the cluster. It is the first thing that we
create when we need to talk to RavenDB. But its importance extends beyond just knowing who to talk to.

### The Document Store

The document store holds all the client side configuration for RavenDB, how we are going to serialize your entities, how to 
handle failure scenarios, what sort of caching strategy to use, and much more. In typical application, you shall have a
single document store instance per application (singleton). Because of that, the document store is thread safe, and a typical 
initialization pattern looks like Listing 2.10.

```{caption="Common pattern for initialization of the DocumentStore" .cs }   
public class DocumentStoreHolder
{
	private readonly static Lazy<IDocumentStore> _store = 
		new Lazy<IDocumentStore>(CreateDocumentStore);

	private static IDocumentStore CreateDocumentStore()
	{
		var documentStore = new DocumentStore
		{
			Urls = // urls of the nodes in the RavenDB Cluster
			{
				"https://ravendb-01:8080",
				"https://ravendb-02:8080",
				"https://ravendb-03:8080",
			},
			DefaultDatabase = "Tasks",
		};

		documentStore.Initialize();
		return documentStore;
	}

	public static IDocumentStore Store
	{
		get { return _store.Value; }
	}
}
```

The use of Lazy ensures that the document store is only created once, without having to worry about double locking or 
explicit thread safety issues. And we can configure the document store as we see it. The rest of the code has access to the
document store using `DocumentStoreHolder.Store`. That should be relatively rare, since apart from configuring the document
store, the majority of the work is done using sessions.

You can also create `DocumentStore` using a connection string, as shown in Listing 2.11.

```{caption="Using connection string with the DocumentStore" .cs }

// in real life, read from configuration
// var conString = GetConnectionString(); 
var conString = 
	"Url=https://ravendb-01:8080; Url=https://ravendb-02:8080;" + 
	"Url=https://ravendb-03:8080; Database=Tasks;" 				+
	"ApiKey=tasks.myapp.example/MKGBO59mhw3y8DIP0yqLSKdM";

var documentStore = new DocumentStore();
documentStore.ParseConnectionString(conString)
documentStore.Initialize();
```

Listing 2.11 shows how we configure multiple nodes, setup security and select the appropraite database. We'll learn about how
to work with a RavenDB Cluster in [Part II](#clustering-setup). We still have a lot to cover on the document store without  
getting to clusters, though.


#### Conventions

The RavenDB Client API, just like the rest of RavenDB, aims to Just Work. As a result of that, it is based around the notion 
of conventions. A series of policy decisions that has already been made for you. Those range from deciding which property
holds the document id to how the entity should be serialized to a document.

For the most part, we expect that you'll not have to touch the conventions. A lot of thought and effort has gone into 
ensuring that you'll have little need to do that. But there is simply no way that we can foresee the future, or answer every
need, which is what pretty much every part of the client API is customizable.

Most of that is handled via the `DocumentStore.Conventions` property, by registering your own behavior. For example, by 
default the RavenDB Client API will use a property named `Id` (case sensitive) to store the document id. But there are users
who want to use the entity name as part of the property name. So we'll have OrderId for orders, ProductId for products, etc.
^[I'll leave aside Id vs. ID, since it is handled in the same manner].

Here is how we can tell the RavenDB Client API that it should apply the `TypeName + Id` policy:

	documentStore.Conventions.FindIdentityProperty = 
		prop => prop.Name == prop.DeclaringType.Name + "Id";


I'm not going to go over each option in the conventions since there are quite a few of them. The documentation does a 
good job of going over them in details, and it is probably worth your time to go and peruse through them, even if for the
most part, they aren't really something that you'll touch.

Other options that can be controlled via the document store are request timeout, caching configuration, creating indexes and
transformers, setting up listeners, listening to changes and doing bulk inserts into RavenDB. We'll cover all of those 
further into this book.

#### Authentication

A database holds a lot of information, and usually it is pretty important that you'll have control over who can access that
information and what they can do with that. RavenDB fully supports this notion.

In development mode, you'll usually work with the `Raven/AnonymousUserAccessMode` setting set to `Admin`. In other words, any
access to the database will be considered to be an access by an administrator. This reduces the number of things that you
have to do upfront. But as easy as that is for development, for production, we set that setting to be `None`. This option
requires all access to the database server^[Note that this is a server level option, rather than a database level option] to
be done only by authenticated users.

> **Caution:** unsecured networked databases are bad for you.
> 
> By default, RavenDB will *refuse* to listen to anything but the local host if the `Raven/AnonymousUserAccessMode` is set to
> `Admin`. This is done for security reasons, to prevent admins from accidently exposing RavenDB without authentication over 
> the network. If you attempt to configure a non localhost url with anonymous access set to `Admin`, RavenDB will answer all 
> requests with an error page explaining what happened and how to fix this.
> 
> You can let RavenDB know that this is something that you actually want (if you are running on a secured local network), for
> example. That requires an additional and explicit step to make sure that this is a concious choice and not an admin 
> oversight.

RavenDB uses API Keys for authentication, the good thing about API Keys is that they are _not_ users. They are not tied to a
specific person or need to be managed as such. Instead, they represent specific access that was granted to the database for a
particular reason. I find that this is a much more natural way to handle authentication, and typically API Keys are granted on
a per application / role basis.

A much deeper discussion of authentication, managing API Keys and security in general is the topic of [Chapter 20](#security).

### The session

The session (formally known as document session, but we usually shorten it to just a session) is the primary way your code
interacts with RavenDB. If you are familiar with NHibernate or Entity Framework, you should feel right at home. The RavenDB
session was explicitly modeled to make it easy to work with.

> **Terminology**
>
> We tend to use the term document to refer both to the actual documents on the server, and to manipulating them client side.
> It is common to say: "load that document and then... ". But occasionally we need to be more precise. 
>
> We make a distinction between a document and an entity (or aggregate root). A document is the server side representation,
> while an entity is the client side equivalent. An entity is the deserialized document that you work with client side, and
> save back to the database to become an updated document server side.

We already gone over the basics in `Your first RavenDB program`, so you are familiar with basic CRUD operations using the 
session. Let us look at the session with a bit more scrutiny. One of the main design forces behind RavenDB was the idea that
it should Just Work. And the client API reflect that principle. If you look at the surface API for the session, here are the 
following high level options:

* Load()
* Include()
* Delete()
* Query()
* Store()
* SaveChanges()
* Advanced

Those are the most common operations that you'll run into on a day to day basis. And more options are available under the
`Advanced` property.

#### Load 

As the name implies, this gives you the option of loading a document or a set of documents into the session. A document
loaded into the session is managed by the session, any changes made to the document would be persisted to the database when
you call `SaveChanges`. A document can only be loaded once in a session. Let's look at the following code:

	var t1 = session.Load<ToDoTask>("ToDoTasks/1");
	var t2 = session.Load<ToDoTask>("ToDoTasks/1");

	Assert.True(Object.ReferenceEquals(t1, t2));

Even though we call `Load<ToDoTask>("ToDoTasks/1")` twice, there is only a single remote call to the server, and only a single
instance of the `ToDoTask` class. Whenever a document is loaded, it is added to an internal dictionary that the session
manages. Whenever you load a document, the session check in that dictionary to see if that document is already there, and if
so, it will return the existing instance immediately. This helps avoid aliasing issues and also generally helps performance.

For those of you who deals with patterns, the session implements the `Unit of Work` and `Identity Map` patterns. This is most
obvious when talking about the `Load` operation, but it also applies to `Query` and `Delete`.

`Load` can also be used to read more than a single document at a time. For example, if I wanted three documents, I could use:

	Dictionary<string, ToDoTask> tasks = session.Load<ToDoTask>(
		"ToDoTasks/1",
		"ToDoTasks/2",
		"ToDoTasks/3"
	);

This will result in an dictionary with all three documents in it, retreived in a single remote call from the server. If a 
document that we tried to load was not found on the server, the dictionary will contain null for that document id.

> **Budgeting remote calls**
> 
> Probably the easiest way to kill your application performance is to make a lot of remote calls. And the common culprit is
> the database. It is common to see application making tens of calls to the database, usually for no good reason. In 
> RavenDB, we have done several things to mitigate that problem. The most important among them is to allocate a budget for
> every session. Typically a session would encompass a single operation in your system. An HTTP request or the processing of 
> a single message is usually the lifespan of a session.
>
> And a session is limited by default to a maximum of 30 calls to the server. If you try to make more than 30 calls to the
> server, an exception is thrown. This serves as an early warning that your code is generating too much load on the system
> and as a Circuit Breaker^[See [Release It!](http://pragprog.com/book/mnee/release-it), a wonderful book that heavily
> influenced the RavenDB design].
> 
> You can increase the budget, of course, but just having that in place ensures that you will think about the number of
>  remote calls that you are making.
>
> The limited number of calls allowed per session also means that RavenDB has a lot of options to _reduce_ the number of
> calls. When you call SaveChanges(), we don't need to make a separate call per changed entity, we can go to the database
>  once. In the same manner, we also allow to batch _read_ calls. We'll discuss it in the next chapter, on the Lazy section.

Just like when you attempt to load an existing document that was already loaded, the session will also remember that couldn't 
load that document, and even if asked again, will immediately return null, rather than attempt to load the document again.

#### Working with multiple documents

We have seen how to work with a single document, and we even saved a batch of several documents into RavenDB in a single
transaction, but we haven't actually worked with anything more complex than a `ToDoTask`. That is pretty limiting in terms
of the amount of complexity we can express. Listing 2.12 us add the notion of people who can be assigned tasks to the model.

```{caption="People and Tasks model in RavenDB" .cs}
 public class Person
 {
     public string Id { get; set; }
     public string Name { get; set; }
 }

 public class ToDoTask
 {
     public string Id { get; set; }
     public string Task { get; set; }
     public bool Completed { get; set; }
     public DateTime DueDate { get; set; }

     // the assigned person id goes here
     public string AssignedTo { get; set; } 
 }
```

From looking at the model in Listing 2.12 we can learn a few interesting tidbits. First, we can see that each class stands on
its own. We don't have a `Person` property on `ToDoTask` or `Tasks` collection on `Person`. We'll about modeling more 
extensively in [Chapter 4](#client-api), but the gist of modeling in RavenDB is that each document is independnt, isolated and
coherent. 

What does this mean? We should be able to take a single document and work with it successfully without having to look or load 
at additional documents. The easiest way to think about it is to think about physical documents. With phyiscal documents, I am
able to pick up the document and read it, and it should make sense. References to other locations are frequent, but they'll 
usually also give me enough information in the document itself so I don't _have_ to go and read those references.

In the case of the `ToDoTask`, I can look at my tasks, create new tasks or mark them as completed without having to look the 
`Person` document. This is quite a shift from working with relational database, where traversing between rows and tables in 
very common and frequently required. 

Let us see how we can create a new task and assign it to a person. Listing 2.13 

```{caption="Creating a new person document" .cs}
using (var session = store.OpenSession())
{
    var person = new Person
    {
        Name = "Oscar Arava"
    };
    session.Store(person);
    Console.WriteLine(person.Id);
    session.SaveChanges();
}
```

## Testing with RavenDB