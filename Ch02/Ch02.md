
# Zero to 60 with RavenDB, from installation to usage

In this chapter, we will install RavenDB and start working with it. Before we can get started with RavenDB, we need to have a live instance that we can work with. There are several ways to run RavenDB:

* Development - console mode
* Production
    * Windows Service
    * IIS
* In the cloud - [RavenHQ](http://www.ravenhq.com)

The console mode is very useful for development, because you can see the incoming requests to RavenDB, and you can interact with the server directly. For production usage, you can install RavenDB as a Windows Service or in IIS. We'll discuss the relative merits of each option toward the end of this chapter. 

For running in the cloud, you can use the RavenDB as a Service option provided by [RavenHQ](http://www.ravenhq.com). You can read more on RavenHQ in Chapter TODO, for now, we'll focus on everything you need to get RavenDB running on your own machine.

## Setting up everything

Go to the [RavenDB download page](http://ravendb.net/download), and download the latest version. At the time of this writing, this is version 3.0. You should download the zip archive and extract it. Then go to the Start.cmd file and double click it.
This will start RavenDB in console (debug) mode as well as open your browser to point to the RavenDB Management Studio^[The acronym for the studio is RDBMS.]. 

Note the URL in the browser. By default, RavenDB will try to use http://localhost:8080 as its endpoint. But if you have a service already taking this port, it might select port 8081, etc. 

The studio will ask you to create a database, please name the database Northwind, and press the Create button. You can ignore the bundles selection for now, we'll discuss them at legnth later.
Now that we have a database, go to the Tasks tab and then to Create Sample Data dialog, press the Create Sample Data button. You should see a progress bar running for a short while, and now you have a new database, including data that we can play with.

> The Northwind database is the sample database that came with SQL Server, it has been used for decades as _the_ sample database in the Microsoft community. We choose this database as our sample data because it is likely already familiar to you in its relational format.

Go to the Documents tab and then select the Products collection on the left. You should see something similar to Figure 1.

![The Products collection in the Northwind database](.\Ch02\Figure01.png)

This looks remarkably similar to what you'll see in a relational database. The data is shown in grid format, and we have the "tables" on the left. If you click on one of the products (the link is on the left most column), you'll enter into the actual document view, as shown in Figure 2.

![Editing a product document in the RavenDB Studio](.\Ch02\Figure02.png)

Now we can actually see the JSON data of the documents. But products are pretty simple documents, pretty much a one to one translation from the relational model. Let us look at a more interesting example. Let us go to orders/827, you can use the Go To Document text box at the top of the studio to go directly there. The content of that document is shown is Listing 1.

You can see several interesting things in Listing 1. We no longer have a simple key/value model that matches exactly to the column values in the relational model. We can aggregate related information into a common object, as in the case of the ShipTo property which has all of the shipping information. 

But probably even more important is the way we are handling the line items. In the relational schema, those were relegated to a separate table. And loading the order's data would require us to join to that table. Here all of the order information, including the collection of line items are included directly in the document.

We'll discuss this at length when we talk about modeling in Chapter 3, but as you can imagine at this early stage, this capability significantly reduces both complexity and cost of getting the data from the database.

```{caption="The orders/827 document" .json }   
{
    "Company": "companies/73",
    "Employee": "employees/7",
    "OrderedAt": "1998-05-06T00:00:00.0000000",
    "RequireAt": "1998-06-03T00:00:00.0000000",
    "ShippedAt": null,
    "ShipTo": {
        "Line1": "VinbÃ¦ltet 34",
        "Line2": null,
        "City": "Kobenhavn",
        "Region": null,
        "PostalCode": "1734",
        "Country": "Denmark"
    },
    "ShipVia": "shippers/2",
    "Freight": 18.44,
    "Lines": [
        {
            "Product": "products/16",
            "ProductName": "Pavlova",
            "PricePerUnit": 17.45,
            "Quantity": 14,
            "Discount": 0.05
        }
    ]
}
```

We'll not be going through all the things that you can do with the studio. Instead, we'll refer back to it whenever we want to show you something new or interesting that has relevancy in the studio as well (the operational monitoring capabilities, visualization of work, etc).

Now that we have a running sytem, feel free to explore it a bit, and then we'll move to the fun part, using RavenDB in our application.

## Coding with RavenDB

Start Visual Studio and create a new Console Application Project named `Northwind`. Then, in the Package Manager Console, issue the following command:

	Install-Package RavenDB.Client

This command uses Nuget to get the RavenDB Client package and add a reference to it to your project. Now we just need to tell the client where the server is located. Add a using statement for `Raven.Client.Document`, and then create a document store, like so:

	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind"
	};

	documentStore.Initialize();

> Note that if your RavenDB server is running on a different port, you'll need to change the document store's url.

The document store is the starting point for all your interactions with RavenDB. If you have used NHibernate in he past, the DocumentStore is very similar to the SessionFactory. We use the document store to create sessions, which is how we usually read and write data from RavenDB.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<dynamic>("products/1");
		Console.WriteLine(p.Name);
	}

You can see that we didn't have to define anything, we can immediately start working with RavenDB. The schema less nature of RavenDB, combined with the dynamic option in C# allows us to work in a completely dynamic world. But for most things, we actually do want some structure. 
Our next step would be to introduce the model classes to our project. In the studio, go to the Tasks tab, then to the Create Sample Data dialog. Press the Show Sample Data Classes button, and copy the resulting text to Visual Studio. Listing 2 shows the Product sample data class.

```{caption="The sample Product class" .cs }   
public class Product
{
	public string Id { get; set; }
	public string Name { get; set; }
	public string Supplier { get; set; }
	public string Category { get; set; }
	public string QuantityPerUnit { get; set; }
	public decimal PricePerUser { get; set; }
	public int UnitsInStock { get; set; }
	public int UnitsOnOrder { get; set; }
	public bool Discontinued { get; set; }
	public int ReorderLevel { get; set; }
}
```

You can see that there really isn't anything special about this class. There is no special base class, attributes or even the requirement that the class would have virtual members. This is a Plain Old C# Object in its purest form. How do we use this class? Here is the same code as before, but using the Product class instead of dynamic.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<Product>("products/1");
		Console.WriteLine(p.Name);
	}

We load the product by id, then print out its name. It Just Works.

## Basic Theory

So far, we have setup RavenDB, explore the studio, wrote some code to connect to RavenDB and pull data out and defined strongly typed classes that allow us to work with RavenDB more easily.
This is all well and good, but as fun as blind experimentation is, we need to understand what is going on in order to do great things with RavenDB.

### The document store

You've already used the document store to talk to RavenDB, but what is its purpose? The document store holds the RavenDB url, the default database we'll talk to and the credentials that will be used. It is the first thing that we create when we need to talk to RavenDB. But its importance extends beyond just knowing who to talk to.

The document store holds all the client side configuration for RavenDB, how we are going to serialize your entities, how to handle failure scenario, what sort of caching strategy to use, and much mode. In typical application, you shall have a single document store instance per application (singleton). Because of that, the document store is thread safe, and a typical initialization pattern looks like Listing 3.

```{caption="Common pattern for initialization of the DocumentStore" .cs }   
public class DocumentStoreHolder
{
	private readonly static Lazy<IDocumentStore> _store = 
		new Lazy<IDocumentStore>(CreateDocumentStore);

	private static IDocumentStore CreateDocumentStore()
	{
		var documentStore = new DocumentStore
		{
			Url = "http://localhost:8080",
			DefaultDatabase = "Northwind",
		};

		documentStore.Initialize();
		return documentStore;
	}

	public static IDocumentStore Store
	{
		get { return _store.Value; }
	}
}
```

The use of Lazy ensures that the document store is only created once, without having to worry about double locking or explicit thread safety issues. And we can configure the document store as we see fit. The rest of the code cas access the document store using `DocumentStoreHolder.Store`. That should be relatively rare, since apart from configuring the document store, the majority of the work is done using the session.
But before we get to that, let us see what sort of configuration we can do with the document store.

#### Conventions

The RavenDB Client API, just like the rest of RavenDB, aims to Just Work. As a result of that, it is based around the notion of conventions. A series of policy decisions that has already been made for you. Those range from deciding which property holds the document id to how the entity should be serialized to a document.

For the most part, we expect that you'll not have to touch the conventions. A lot of thought and effort has gone into ensuring that you'll have no need to do that. But there is simply no way that we can foresee the future, or answer every need, which is what pretty much every part of the client API is customizable.

Most of that is handled via the `DocumentStore.Conventions` property, by registering your own behavior. For example, by default the RavenDB Client API will use a property named `Id` (case sensitive) to store the document id. But there are users who want to use the entity name as part of the property name. So we'll have OrderId for orders, ProductId for products, etc^[I'll leave aside Id vs. ID, since it is handled in the same manner].

Here is how we can tell the RavenDB Client API that it should use this behavior:

	documentStore.Conventions.FindIdentityProperty = 
		prop => prop.Name == prop.DeclaringType.Name + "Id";

I'm not going to go over each option in the conventions since there are literally dozens of them. They are API comments on each of the exposed options, but it is probably worth your time to go and peruse through them, even if for the most part, they aren't really something that you'll touch.

#### Connection strings

#### Document store types

### The session

### Database commands

### Working with async

## Running in Production

## Where is my data stored. 

## Bundles