
# Zero to RavenDB

[zero-to-ravendb]: The very first steps we need to take in our journey to understand RavenDB is to actually getting
it running on our machine, so we can actually get things done. I'm deferring discussion on what it is, how it works,
etc to a later part of this book, because I think that having a live version that you can play with will make it 
much easier to understand RavenDB.

## Setting RavenDB on your machine

For this section, I'm assuming that you are a developer trying to get a RavenDB instance so you can explore it. I'm
going to ignore everything related to actual production deployments in favor of getting your setup in as few steps 
as possible. Full discussion on how to deploy, secure and run RavenDB in product is available in 
[Chapter 19](#prod-deploy).

I'm going ot go over a few quick install scenarios, and you can select whichever one makes the most sense to your
setup. After that, skip to the next section where we'll actually start using RavenDB.

### Running on docker

What is probably the easiest way to get RavenDB is via Docker. If you already have Docker installed, all you need to
do is run:

	docker run -e AllowAnonymousUserToAccessTheServer=true 
	       -p 8080:8080 ravendb/ravendb

And Docker will get the latest RavenDB version and spin a new container to host it. Note that we run it in 
developer mode, without any authentication.

The output of this command should look something like this:

	       _____                       _____  ____
	      |  __ \                     |  __ \|  _ \
	      | |__) |__ ___   _____ _ __ | |  | | |_) |
	      |  _  // _` \ \ / / _ \ '_ \| |  | |  _ <
	      | | \ \ (_| |\ V /  __/ | | | |__| | |_) |
	      |_|  \_\__,_| \_/ \___|_| |_|_____/|____/


	      Safe by default, optimized for efficiency

	 Build 40013, Version 4.0, SemVer 4.0.0-beta-40xxx, Commit ca31ca1
	 PID 6, 64 bits
	 Source Code (git repo): https://github.com/ravendb/ravendb
	 Built with love by Hibernating Rhinos and awesome contributors!
	+---------------------------------------------------------------+
	 Listening to: http://10.0.75.2:8080
	 Server started, listening to requests...
	 Running as Service
	 Tcp listening on 0.0.0.0:38888

The most important piece of information you have there is the `Listening to: http://10.0.75.2:8080`, which tells you
the URL to put in your browser to access the newly installed instance.

### Running on Windows

To setup RavenDB on Windows you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Windows x64, in this case) and download the `zip` file containing the binaries.

Extract the file to a directory and then run the `Start.cmd` script or `Server\Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing:

	Server\Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Running on Linux

To setup RavenDB on Linux you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Linux x64, most likely) and download the `tar.bz2` file containing the binaries.

**TODO: http://issues.hibernatingrhinos.com/issue/RavenDB-7020 ** Need to verify if we need `dotnet` or how to run
directly from the `tar.bz2` file on a brand new machine.

Extract the file to a directory and then run the `run.sh` script or `./Server/Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing:

	./Server/Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Using the live demo instance

Without installing anything, you can point your browser to 
[http://4.live-test.ravendb.net](http://4.live-test.ravendb.net?source=book) and access the public demo instance 
that we have available. This is useful for quick checks and verifications, but it isn't meant for for anything 
more serious than that. 

Obviously, all data in the live instance is public, and there are no guarantees about availability. We use this 
instance to tryout the latest versions, so that is also a consideration. In short, if you need to verify something 
small, go ahead and hit that instance. Otherwise, you'll need your own version.

## Starting to work with RavenDB

By now, you have already setup an instance of RavenDB to work with, and managed to load the RavenDB Studio in 
your browser. For simplicity's sake, I'm going to assume from now on that you are running on the local machine
on port 8080. Point your browser to [http://localhost:8080](http://localhost:8080) and you should be greeted with
an empty RavenDB instance. You can see how it looks in Figure 2.1.

![Empty RavenDB node](./Ch02/img01.png)

What we have right now is a RavenDB node that is a self contained cluster^[Actually, that is not really the case, 
but the details on the state of a new node are a bit complex and covered in the [Chapter 5](#clustering-setup)].
Now that we have a running node, the next stage it to create a new database on this node. 

You can do that by clicking on the `New database` button and naming it `Northwind`, accepting all the defaults for
the dialog. We'll discuss what all of those mean in [Chapter 19](#prod-deploy). Click on the `Create` button and 
that is pretty much it, your new database is ready, you can see how this looks like in Figure 2.2.

![New empty database](./Ch02/img02.png)

Of course, this new database contains no data, which make it a pretty hard to work with it. We'll use the 
`sample data` feature in RavenDB to have some documents that we can work with. On the left menu, go to `Tasks` and the to `Create Sample Data` and then press the `Create` button. 

Pressing this button will populate the database with the sample `Northwind` dataset. If you aren't familiar with 
Northwind, it is a sample dataset of an online store, including such common concepts as orders, customers and 
products. Let's explore this data set inside of RavenDB.

On the left menu, select `Documents` and you'll see a view similar to Figure 2.3. Showing the recently updates 
documents and the collections that were created. 

![Northwind documents view](./Ch02/img03.png)

Collections are the basic building blocks inside RavenDB. Every document belongs to exactly one collection, usually
based on the entity type of the document on the client. It is very similar to tables in a relational database, but 
unlike tables, there is no requirement that documents within the same collection will share the same structure or 
have any sort of schema.

Collections are very important to the way RavenDB organize and optimize the data internally, and the optimization 
opportunities that they provide are discussed at length in [Chapter 26](#stroage-layout). We'll frequently use 
collections to group similar documents together and apply some operation on them (subscribing to changes, indexing,
querying, ETL, etc).

Click on the `Orders` collection and then on the first document in the listing, which should be `orders/830'. The 
result is shown in Figure 2.4. This is the first time we are actually looking at the core reason RavenDb exists, 
a real JSON document.

![An orders document](./Ch02/img04.png)

If you are fammiliar with working with non relational databases, this is pretty obvious and non too exciting, but 
if you are mostly used to relational databases, there are several things to note here.

In RavenDB we are able to store arbitrarily complex data as a single unit. If you will look closely at Figure 2.4 
you'll see that instead of just storing a few columns, we can store rich information. By working with nested 
objects (`ShipTo` property) or arrays of complex types (the `Lines` property). 

This means that we don't have to split our data to statisfy the phyiscal constraints of our storage, we can store 
a whole object graph in a single document. We'll talk about modeling a lot more in [Chapter 3](#crud), but for now
I'll just mention that the basic modeling method in RavenDB is based around Root Aggregates and complete the 
picture in the next chapter.

In the meantime, you can explore the different collections and the sample data in the studio. We spent a lot of 
time and effort on the RavenDB Studio, and while I'll be the first to admit that it is pretty, looking at a 
syntax highlighted text editor isn't really that impressive. So let us see what kind of things we can do with the
data as a database.

## Working with data in RavenDB

This section will cover working the basics of working with data with the RavenDB Studio. If you are a developer, 
you're probably anxious to start seeing code, we'll get into that in the next section, no worries.

The first thing we'll learn to do is how to do bulk operations inside the studio. On the left menu, go to 
`Documents` and then look at the bottom, where you'll find the `Patch` menu, click on it, and you'll see the 
screen shown in Figure 2.5.

![Patching the categories](./Ch02/img05.png)

Patching allows you to write a Javascript function that can modify the matching documents. In Figure 2.5 we are 
going to add support for localization of the categories.

