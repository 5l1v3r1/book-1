
# Zero to RavenDB

[zero-to-ravendb]: The very first steps we need to take in our journey to understand RavenDB is to actually getting
it running on our machine, so we can actually get things done. I'm deferring discussion on what it is, how it works,
etc to a later part of this book, because I think that having a live version that you can play with will make it 
much easier to understand RavenDB.

## Setting RavenDB on your machine

For this section, I'm assuming that you are a developer trying to get a RavenDB instance so you can explore it. I'm
going to ignore everything related to actual production deployments in favor of getting your setup in as few steps 
as possible. Full discussion on how to deploy, secure and run RavenDB in product is available in 
[Chapter 19](#prod-deploy).

I'm going ot go over a few quick install scenarios, and you can select whichever one makes the most sense to your
setup. After that, skip to the next section where we'll actually start using RavenDB.

### Running on docker

What is probably the easiest way to get RavenDB is via Docker. If you already have Docker installed, all you need to
do is run the following command:

	docker run -e AllowAnonymousUserToAccessTheServer=true 
	       -p 8080:8080 ravendb/ravendb

And Docker will get the latest RavenDB version and spin a new container to host it. Note that we run it in 
developer mode, without any authentication.

The output of this command should look something like Listing 2.1.

```{caption="RavenDB Server Output"}   
       _____                       _____  ____
      |  __ \                     |  __ \|  _ \
      | |__) |__ ___   _____ _ __ | |  | | |_) |
      |  _  // _` \ \ / / _ \ '_ \| |  | |  _ <
      | | \ \ (_| |\ V /  __/ | | | |__| | |_) |
      |_|  \_\__,_| \_/ \___|_| |_|_____/|____/


      Safe by default, optimized for efficiency

 Build 40013, Version 4.0, SemVer 4.0.0-beta-40xxx, Commit ca31ca1
 PID 6, 64 bits
 Source Code (git repo): https://github.com/ravendb/ravendb
 Built with love by Hibernating Rhinos and awesome contributors!
+---------------------------------------------------------------+
 Listening to: http://10.0.75.2:8080
 Server started, listening to requests...
 Running as Service
 Tcp listening on 0.0.0.0:38888
 ```

The most important piece of information you have there is the `Listening to: http://10.0.75.2:8080`, which tells you
the URL to put in your browser to access the newly installed instance.

### Running on Windows

To setup RavenDB on Windows you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Windows x64, in this case) and download the `zip` file containing the binaries.

Extract the file to a directory and then run the `Start.cmd` script or `Server\Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing:

	Server\Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Running on Linux

To setup RavenDB on Linux you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Linux x64, most likely) and download the `tar.bz2` file containing the binaries.

**TODO: http://issues.hibernatingrhinos.com/issue/RavenDB-7020 ** Need to verify if we need `dotnet` or how to run
directly from the `tar.bz2` file on a brand new machine.

Extract the file to a directory and then run the `run.sh` script or `./Server/Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing this
command:

	./Server/Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Using the live demo instance

Without installing anything, you can point your browser to 
[http://4.live-test.ravendb.net](http://4.live-test.ravendb.net?source=book) and access the public demo instance 
that we have available. This is useful for quick checks and verifications, but it isn't meant for for anything 
more serious than that. 

Obviously, all data in the live instance is public, and there are no guarantees about availability. We use this 
instance to tryout the latest versions, so that is also a consideration. In short, if you need to verify something 
small, go ahead and hit that instance. Otherwise, you'll need your own version.

## Your first database

By now, you have already setup an instance of RavenDB to work with, and managed to load the RavenDB Studio in 
your browser. For simplicity's sake, I'm going to assume from now on that you are running on the local machine
on port 8080. Point your browser to [http://localhost:8080](http://localhost:8080) and you should be greeted with
an empty RavenDB instance. You can see how it looks in Figure 2.1.

![Empty RavenDB node](./Ch02/img01.png)

What we have right now is a RavenDB node that is a self contained cluster^[Actually, that is not really the case, 
but the details on the state of a new node are a bit complex and covered in the [Chapter 5](#clustering-setup)].
Now that we have a running node, the next stage it to create a new database on this node. 

You can do that by clicking on the `New database` button and naming it `Northwind`, accepting all the defaults for
the dialog. We'll discuss what all of those mean in [Chapter 19](#prod-deploy). Click on the `Create` button and 
that is pretty much it, your new database is ready, you can see how this looks like in Figure 2.2.

![New empty database](./Ch02/img02.png)

### Creating sample data

Of course, this new database contains no data, which make it a pretty hard to work with it. We'll use the 
`sample data` feature in RavenDB to have some documents that we can work with. On the left menu, go to `Tasks` and 
the to `Create Sample Data` and then press the `Create` button. 

Pressing this button will populate the database with the sample `Northwind` dataset. If you aren't familiar with 
Northwind, it is a sample dataset of an online store, including such common concepts as orders, customers and 
products. Let's explore this data set inside of RavenDB.

On the left menu, select `Documents` and you'll see a view similar to Figure 2.3. Showing the recently updates 
documents and the collections that were created. 

![Northwind documents view](./Ch02/img03.png)


Collections are the basic building blocks inside RavenDB. Every document belongs to exactly one collection, usually
based on the entity type of the document on the client. It is very similar to tables in a relational database, but 
unlike tables, there is no requirement that documents within the same collection will share the same structure or 
have any sort of schema.

Collections are very important to the way RavenDB organize and optimize the data internally, and the optimization 
opportunities that they provide are discussed at length in [Chapter 26](#stroage-layout). We'll frequently use 
collections to group similar documents together and apply some operation on them (subscribing to changes, indexing,
querying, ETL, etc).

### Our first real document

Click on the `Orders` collection and then on the first document in the listing, which should be `orders/830'. The 
result is shown in Figure 2.4. This is the first time we are actually looking at the core reason RavenDb exists, 
a real JSON document.

![An orders document](./Ch02/img04.png)

If you are fammiliar with working with non relational databases, this is pretty obvious and non too exciting, but 
if you are mostly used to relational databases, there are several things to note here.

In RavenDB we are able to store arbitrarily complex data as a single unit. If you will look closely at Figure 2.4 
you'll see that instead of just storing a few columns, we can store rich information. By working with nested 
objects (`ShipTo` property) or arrays of complex types (the `Lines` property). 

This means that we don't have to split our data to statisfy the phyiscal constraints of our storage, we can store 
a whole object graph in a single document. We'll talk about modeling a lot more in [Chapter 3](#crud), but for now
I'll just mention that the basic modeling method in RavenDB is based around Root Aggregates and complete the 
picture in the next chapter.

In the meantime, you can explore the different collections and the sample data in the studio. We spent a lot of 
time and effort on the RavenDB Studio, and while I'll be the first to admit that it is pretty, looking at a 
syntax highlighted text editor isn't really that impressive. So let us see what kind of things we can do with the
data as a database.

## Working with the RavenDB Studio

This section will cover working the basics of working with data with the RavenDB Studio. If you are a developer, 
you're probably anxious to start seeing code, we'll get into that in the next section, no worries.

### Creating & Editing documents

When you look at a particular document, you can edit the JSON and click on `Save`, and the document will be saved.
There isn't really much to it, to be honest. Creating new documents is a bit more interesting. Let us create a new
category. 

In them left menu, go to `Documents` then under `Collections` click on `Categories` and then select 
`New document in current collection` as shown in Figure 2.5.

![New document in current collection](./Ch02/img05.png)

This will open the editor on a new document with an empty document based on one of the existing categories. Note
that the document id is set to `categories/`. Complete the contents of the document and save it. RavenDB wiil 
assign the document id automatically for you.

One thing that may not be obvious is that while the studio generates an empty document based on the existing ones,
there is no such thing as schema in RavenDB and you are free to add or remove properties and values and modify the
structure of the document however you feel like. This feature makes evolving your data model and handling more 
complex data much easier.


### Patching documents

The first thing we'll learn to do is how to do bulk operations inside the studio. On the left menu, go to 
`Documents` and then look at the bottom, where you'll find the `Patch` menu, click on it, and you'll see the 
screen shown in Figure 2.5.

![Patching the categories](./Ch02/img06.png)

Patching allows you to write a Javascript function that can modify the matching documents. To try this out, we'll
run a non trivial transformation on the `categories` documents, let us add location support and the ability to 
store the category name in mulitple languages using a patch script.

Put the code in Listing 2.1 in the `Patch script` text box.

```{caption="Patching categories for internationalization support" .js}   
	this.Name = [{"Lang": "en-us", "Text": this.Name }];
	this.Description = [{"Lang": "en-us", "Text": this.Description }];
```

You can click on `Test` and select a specific category document to view the results of running this operation on 
that specific document. The before & after results of running this script `categories/4` is showing in Figure 2.6.

![Internationalizing categories with Javascript patching](./Ch02/img07.png)

Patch scripts allows us to modify our documents en masse, and they are very useful when you need to reshape 
existing data. You can apply them on a specific document, a whole collection or all documents matching a specific
query.

It is important to mention that such bulk operations are not spanning a single transaction, but can be composed of
multiple transactions. For performance reasons, we might break such processing into multiple independnet (and 
concurrent transactions) that each process some portion of the data. Each independent transaction still maintain 
all the ACID properties, but not the patch operation as a whole.

### Deleting documents

Deleting documents in the studio can be done by going to a particular document and hitting the `Delete` button, if
you want to delete a particular document or deleteing a whole collection by going to the collection page (left 
menu, then `Documents` then selecting the relevant collection in the `Collections` menu), selecting all the 
documents in the header row and clicking the `Delete`.

### Querying documents

The previoud sections talked about how to Create, Update and Delete documents. But for full CRUD support, we still 
need to read documents. So far, we looked at documents whose ids were already known to us, or entire collections. 
In this section, we'll focus on querying documents based on their data.

In the left menu, go to `Indexes` and then to `Query`. This is the main screen for querying documents in the 
RavenDB Studio. As the index, select `dynamic/Companies` and in the query text box write `Address.Country: UK` and 
then click the query button. You can see the results of this query in Figure 2.8. 

![All companies in the UK query results](./Ch02/img08.png)

The studio can also guide you in how to compose queries (you probably noticed the `Add filter` helper when you 
wrote the query). We'll discuss indexes and querying at length in [Part III](#map-indexes). 

This section was meant to gigve you the basics of using the RavenDB Studio, not to be a thorough walkthrough of 
all the options. This is mostly here so you are familiar with the basics of using the studio and can see the 
results of what we are doing in code in the _next_ section, where we get to actual coding.

## Your first RavenDB program

We are finally at the good parts, where we can start slinging code around. For simplicity's sake, I'm going to use
a simple console application to explore the RavenDB API. Typically, RavenDB is used in web / backend applications, 
so we'll also explore some of the common patterns of organizing your RavenDB usage in your application later in 
this chapter.

The code in this book is using C#, but the documetnation can guide you on how to achieve the same results in any
supported clients. 

Create a new Console Application and run the command Listing 2.1 on the `Package Manager Console`.

```{caption="Installing RavenDB Client NuGet package" .powershell}   
	Install-Package Raven.Client 
		-Source https://www.myget.org/F/ravendb/api/v3/index.json 
		-IncludePrerelease
```

This will setup the latest client version for RavenDB 4.0 on the project. The next step is to add a namespace
refeence by adding `using Raven.Client.Documents;` to the top of the `Program.cs` file. 

And now we are ready to start working with the RavenDB client API. The first thing we need to do is to setup access
to the RavenDB cluster that we are talking to. This is done by creating an instance of `DocumentStore` and setting
configuring it as showing in Listing 2.3.

```{caption="Creating a document store pointed to a local instance" .cs }   
var store = new DocumentStore
{
    Urls = { "http://localhost:8080" },
    DefaultDatabase = "Tasks"
};

store.Initialize();
```

This code setups a new `DocumentStore` instance and let it know about a single node, the one running on the local
machine, and that we are going to be using the `Tasks` database. The document store is the starting location for 
all communication with the RavenDB cluster. It holds the configuration, caching, any customizations that you might
have applied, etc.

Typically, you'll have a single instance of a document store per application (singleton pattern) and use that same
instance for the lifetime of the application. Before we can continue, however, we need to go ahead and create the 
`Tasks` database in the studio, so we'll have a real database to work with. 

The document store is the starting location for all RavenDB work, but the real work horse that we typically use is
the session. The session is the one that will hold our entities, talk with the server and in general acts as the 
front man to the RavenDB cluster.

### Defining entities and basic CRUD

Before we can actually start using the session, we need _something_ to actually store. It is possible to work with
completely dynamic data in RavenDB, but that is a specific scenario that is covered in the documentation. Most of
the time, you are working with your entities. For the purpose of this chapter, we'll use the notion of tasks to 
build a simple list of things todo. 

Listing 2.4 shows how an class that will be saved as a RavenDB document looks like. 

```{caption="Entity class representing a task" .cs }   
public class ToDoTask
{
    public string Id { get; set; }
    public string Task { get; set; }
    public bool Completed { get; set; }
    public DateTime DueDate { get; set; }
}
```

This is about as simple as you can get, but we are only starting, so that is good. Let us create a new task inside
RavenDB, reminding us that we need to pick up a bottle of milk from the store tomorrow. The code to perform this
task (pun intended) is shown in Listing 2.5.

```{caption="Saving a new task to RavenDB" .cs }   
using (var session = store.OpenSession())
{
    var task = new ToDoTask
    {
        DueDate = DateTime.Today.AddDays(1),
        Task = "Buy milk"
    };
    session.Store(task);
    session.SaveChanges();
}
```

We open a new session and create a new `ToDoTask`. We then store the task in the session and then call 
`SaveChanges` to save all the changes in the session to the server. You can see the results of this in Figure 2.9.

![The newly created task in the studio](./Ch02/img09.png)

As it so happpened, I actually was able to go to the store today and got some milk, so I need to mark this task as
completed. Listing 2.6 shows the code required to handle updates in RavenDB.

```{caption="Loading, modifying and saving a document" .cs }   
using (var session = store.OpenSession())
{
    var task = session.Load<ToDoTask>("ToDoTasks/1");
    task.Completed = true;
    session.SaveChanges();
}
```

You can notice several interesting things even in this very small sample. We load the document and modify it, then
we call `SaveChanges`. We didn't need to call `Store` again. Because the `task` instance was loaded via the session
it was also tracked by the session, and any changes made to it would be sent back to the server when `SaveChanges`
is called. Conversely, if the `Completed` property was already set to `true`, the RavenDB client will detect that
and do nothing, since the state of the server and the client match.

The document session implements the `Unit of Work` and `Unit of Work` design patterns and make it much easier to 
work with complex behaviors, since you don't need to manually track changes to your objects and decide what needs 
to be saved and what shouldn't. It also means that the only time that the RavenDB client will send updates to the 
server is when you call `SaveChanges`. That, in turn, means that you'll experience a reduced number of network 
calls, all of the changes will be sent as a single batch to the server. And because RavenDB is transactional, all those changes will happen as a single transaction, either completing fully or not there at all.

Let us exapnd on that and create a few more tasks, you can see how that works in Listing 2.7.

```{caption="Creating multiple documents in a single transaction" .cs }   
using (var session = store.OpenSession())
{
   for (int i = 0; i < 5; i++)
   {
       session.Store(new ToDoTask
       {
           DueDate = DateTime.Today.AddDays(i),
           Task = "Take the dog for a walk"
       });
   }

   session.SaveChanges();
}
```

You can see the end result of all this playing around in Figure 2.10. We are creating 5 new tasks and saving them in 
the same `SaveChanges` call, so they will be saved as a single transactional unit.

![All the current tasks](./Ch02/img10.png)

### Querying RavenDB

Now that we have all those tasks, we want to start querying on the data. I want to know what kind of tasks I have for
the next couple of days. In order to get that information, I can use the query in Listing 2.8.

```{caption="Querying upcoming tasks using Linq" .cs }   
using (var session = store.OpenSession())
{
    var tasksToDo =
        from t in session.Query<ToDoTask>()
        where t.Completed == false &&
              t.DueDate >= DateTime.Today &&
              t.DueDate <= DateTime.Today.AddDays(2)
        orderby t.DueDate
        select t;

    foreach (var task in tasksToDo)
    {
        Console.WriteLine($"{task.Id} - {task.Task} - {task.DueDate}");
    }
}
```

Running the code in Listing 2.8 code gave the following output:
	
	ToDoTasks/2 - Take the dog for a walk - 5/14/2017 12:00:00 AM
	ToDoTasks/3 - Take the dog for a walk - 5/15/2017 12:00:00 AM
	ToDoTasks/4 - Take the dog for a walk - 5/16/2017 12:00:00 AM

The query code sample show us using Linq to performance queries against RavenDB with very little hassle and no ceremony
whatsoever. There is actually a _lot_ going on behind the covers, but we'll leave all of that to 
[Part III](#map-indexes).

Let us look at an aggregation query, the code in Listing 2.9 giving us the results of all the tasks per day.

```{caption="Aggregation query on tasks" .cs }   
using (var session = store.OpenSession())
{
    var tasksPerDay =
        from t in session.Query<ToDoTask>()
        group t by t.DueDate into g
        select new
        {
            DueDate = g.Key,
            TasksPerDate = g.Count()
        };

    foreach (var tpd in tasksPerDay)
    {
        Console.WriteLine($"{tpd.DueDate} - {tpd.TasksPerDate}");
    }
}
```

If you are familiar with Linq, there isn't much to say about the code in Listing 2.9. It works, and it is very obvious and 
easy to understand. If you _aren't_ familiar with Linq, I strongly recommend learning it. From the consumer side, it is
very beautiful. As someone who had to implement querying using Linq a few times, it is utterly atrocious, but lucky for
you, that isn't _your_ problem, it's mine.

So far, we explored a bit about the RavenDB API, we saved documents, editted a task and queried the tasks in various
ways. This was intended to get you familiarized with the API and how to work with RavenDB. The client API was designed
to be very simple, focusing on the common CRUD scenarios. Deleting a document is as easy as calling `session.Delete` 
and all the complex options that you would need are packed insided the `session.Advanced` property. 

Now that you have a basic understanding of how to write a `Hello World` in RavenDB, we are ready to dig deeper and 
see the client API in all its glory.

## The RavenDB Client API 

You've already used the document store to talk to RavenDB, but what is its purpose? The document store holds the RavenDB 
Cluster urls (so far, we used only a single URL, but in most cases our data will span multiple nodes), the default database
we'll talk to and the API Key that will be used to authenticate ourselves with the cluster. It is the first thing that we
create when we need to talk to RavenDB. But its importance extends beyond just knowing who to talk to.

### The Document Store

The document store holds all the client side configuration for RavenDB, how we are going to serialize your entities, how to 
handle failure scenarios, what sort of caching strategy to use, and much more. In typical application, you shall have a
single document store instance per application (singleton). Because of that, the document store is thread safe, and a typical 
initialization pattern looks like Listing 2.10.

```{caption="Common pattern for initialization of the DocumentStore" .cs }   
public class DocumentStoreHolder
{
	private readonly static Lazy<IDocumentStore> _store = 
		new Lazy<IDocumentStore>(CreateDocumentStore);

	private static IDocumentStore CreateDocumentStore()
	{
		var documentStore = new DocumentStore
		{
			Urls = // urls of the nodes in the RavenDB Cluster
			{
				"https://ravendb-01:8080",
				"https://ravendb-02:8080",
				"https://ravendb-03:8080",
			},
			DefaultDatabase = "Tasks",
		};

		documentStore.Initialize();
		return documentStore;
	}

	public static IDocumentStore Store
	{
		get { return _store.Value; }
	}
}
```

The use of Lazy ensures that the document store is only created once, without having to worry about double locking or 
explicit thread safety issues. And we can configure the document store as we see it. The rest of the code has access to the
document store using `DocumentStoreHolder.Store`. That should be relatively rare, since apart from configuring the document
store, the majority of the work is done using sessions.

You can also create `DocumentStore` using a connection string, as shown in Listing 2.11.

```{caption="Using connection string with the DocumentStore" .cs }

// in real life, read from configuration
// var conString = GetConnectionString(); 
var conString = 
	"Url=https://ravendb-01:8080; Url=https://ravendb-02:8080;" + 
	"Url=https://ravendb-03:8080; Database=Tasks;" 				+
	"ApiKey=tasks.myapp.example/MKGBO59mhw3y8DIP0yqLSKdM";

var documentStore = new DocumentStore();
documentStore.ParseConnectionString(conString)
documentStore.Initialize();
```

Listing 2.11 shows how we configure multiple nodes, setup security and select the appropraite database. We'll learn about how
to work with a RavenDB Cluster in [Part II](#clustering-setup). We still have a lot to cover on the document store without  
getting to clusters, though.


#### Conventions

The RavenDB Client API, just like the rest of RavenDB, aims to Just Work. As a result of that, it is based around the notion 
of conventions. A series of policy decisions that has already been made for you. Those range from deciding which property
holds the document id to how the entity should be serialized to a document.

For the most part, we expect that you'll not have to touch the conventions. A lot of thought and effort has gone into 
ensuring that you'll have little need to do that. But there is simply no way that we can foresee the future, or answer every
need, which is what pretty much every part of the client API is customizable.

Most of that is handled via the `DocumentStore.Conventions` property, by registering your own behavior. For example, by 
default the RavenDB Client API will use a property named `Id` (case sensitive) to store the document id. But there are users
who want to use the entity name as part of the property name. So we'll have OrderId for orders, ProductId for products, etc.
^[I'll leave aside Id vs. ID, since it is handled in the same manner].

Here is how we can tell the RavenDB Client API that it should apply the `TypeName + Id` policy:

	documentStore.Conventions.FindIdentityProperty = 
		prop => prop.Name == prop.DeclaringType.Name + "Id";


I'm not going to go over each option in the conventions since there are quite a few of them. The documentation does a 
good job of going over them in details, and it is probably worth your time to go and peruse through them, even if for the
most part, they aren't really something that you'll touch.

Other options that can be controlled via the document store are request timeout, caching configuration, creating indexes and
transformers, setting up listeners, listening to changes and doing bulk inserts into RavenDB. We'll cover all of those 
further into this book.

#### Authentication

A database holds a lot of information, and usually it is pretty important that you'll have control over who can access that
information and what they can do with that. RavenDB fully supports this notion.

In development mode, you'll usually work with the `Raven/AnonymousUserAccessMode` setting set to `Admin`. In other words, any
access to the database will be considered to be an access by an administrator. This reduces the number of things that you
have to do upfront. But as easy as that is for development, for production, we set that setting to be `None`. This option
requires all access to the database server^[Note that this is a server level option, rather than a database level option] to
be done only by authenticated users.

> **Caution:** unsecured networked databases are bad for you.
> 
> By default, RavenDB will *refuse* to listen to anything but the local host if the `Raven/AnonymousUserAccessMode` is set to
> `Admin`. This is done for security reasons, to prevent admins from accidently exposing RavenDB without authentication over 
> the network. If you attempt to configure a non localhost url with anonymous access set to `Admin`, RavenDB will answer all 
> requests with an error page explaining what happened and how to fix this.
> 
> You can let RavenDB know that this is something that you actually want (if you are running on a secured local network), for
> example. That requires an additional and explicit step to make sure that this is a concious choice and not an admin 
> oversight.

RavenDB uses API Keys for authentication, the good thing about API Keys is that they are _not_ users. They are not tied to a
specific person or need to be managed as such. Instead, they represent specific access that was granted to the database for a
particular reason. I find that this is a much more natural way to handle authentication, and typically API Keys are granted on
a per application / role basis.

A much deeper discussion of authentication, managing API Keys and security in general is the topic of [Chapter 20](#security).

### The Document Session

The session (formally known as document session, but we usually shorten it to just a session) is the primary way your code
interacts with RavenDB. If you are familiar with NHibernate or Entity Framework, you should feel right at home. The RavenDB
session was explicitly modeled to make it easy to work with.

> **Terminology**
>
> We tend to use the term document to refer both to the actual documents on the server, and to manipulating them client side.
> It is common to say: "load that document and then... ". But occasionally we need to be more precise. 
>
> We make a distinction between a document and an entity (or aggregate root). A document is the server side representation,
> while an entity is the client side equivalent. An entity is the deserialized document that you work with client side, and
> save back to the database to become an updated document server side.

We already gone over the basics in `Your first RavenDB program`, so you are familiar with basic CRUD operations using the 
session. Let us look at the session with a bit more scrutiny. One of the main design forces behind RavenDB was the idea that
it should Just Work. And the client API reflect that principle. If you look at the surface API for the session, here are the 
following high level options:

* Load()
* Include()
* Delete()
* Query()
* Store()
* SaveChanges()
* Advanced

Those are the most common operations that you'll run into on a day to day basis. And more options are available under the
`Advanced` property.

> **Disposing the session**
> 
> The .NET implementation of the client API holds resources that _must_ be freed. Whenever you make use of the session, be
> sure to wrap that in a `using` staement or to ensure the session disposal. Not doing so can force us to do cleanup using
> the finalizer thread, which can increase the time it takes to release the acquired resources.

#### Load 

As the name implies, this gives you the option of loading a document or a set of documents into the session. A document
loaded into the session is managed by the session, any changes made to the document would be persisted to the database when
you call `SaveChanges`. A document can only be loaded once in a session. Let's look at the following code:

	var t1 = session.Load<ToDoTask>("ToDoTasks/1");
	var t2 = session.Load<ToDoTask>("ToDoTasks/1");

	Assert.True(Object.ReferenceEquals(t1, t2));

Even though we call `Load<ToDoTask>("ToDoTasks/1")` twice, there is only a single remote call to the server, and only a single
instance of the `ToDoTask` class. Whenever a document is loaded, it is added to an internal dictionary that the session
manages. Whenever you load a document, the session check in that dictionary to see if that document is already there, and if
so, it will return the existing instance immediately. This helps avoid aliasing issues and also generally helps performance.

For those of you who deals with patterns, the session implements the `Unit of Work` and `Identity Map` patterns. This is most
obvious when talking about the `Load` operation, but it also applies to `Query` and `Delete`.

`Load` can also be used to read more than a single document at a time. For example, if I wanted three documents, I could use:

	Dictionary<string, ToDoTask> tasks = session.Load<ToDoTask>(
		"ToDoTasks/1",
		"ToDoTasks/2",
		"ToDoTasks/3"
	);

This will result in an dictionary with all three documents in it, retreived in a single remote call from the server. If a 
document that we tried to load was not found on the server, the dictionary will contain null for that document id.

> **Budgeting remote calls**
> 
> Probably the easiest way to kill your application performance is to make a lot of remote calls. And the common culprit is
> the database. It is common to see application making tens of calls to the database, usually for no good reason. In 
> RavenDB, we have done several things to mitigate that problem. The most important among them is to allocate a budget for
> every session. Typically a session would encompass a single operation in your system. An HTTP request or the processing of 
> a single message is usually the lifespan of a session.
>
> And a session is limited by default to a maximum of 30 calls to the server. If you try to make more than 30 calls to the
> server, an exception is thrown. This serves as an early warning that your code is generating too much load on the system
> and as a Circuit Breaker^[See [Release It!](http://pragprog.com/book/mnee/release-it), a wonderful book that heavily
> influenced the RavenDB design].
> 
> You can increase the budget, of course, but just having that in place ensures that you will think about the number of
>  remote calls that you are making.
>
> The limited number of calls allowed per session also means that RavenDB has a lot of options to _reduce_ the number of
> calls. When you call SaveChanges(), we don't need to make a separate call per changed entity, we can go to the database
>  once. In the same manner, we also allow to batch _read_ calls. We'll discuss it in the next chapter, on the Lazy section.

Just like when you attempt to load an existing document that was already loaded, the session will also remember that couldn't 
load that document, and even if asked again, will immediately return null, rather than attempt to load the document again.

#### Working with multiple documents

We have seen how to work with a single document, and we even saved a batch of several documents into RavenDB in a single
transaction, but we haven't actually worked with anything more complex than a `ToDoTask`. That is pretty limiting in terms
of the amount of complexity we can express. Listing 2.12 us add the notion of people who can be assigned tasks to the model.

```{caption="People and Tasks model in RavenDB" .cs}
 public class Person
 {
     public string Id { get; set; }
     public string Name { get; set; }
 }

 public class ToDoTask
 {
     public string Id { get; set; }
     public string Task { get; set; }
     public bool Completed { get; set; }
     public DateTime DueDate { get; set; }

     public string AssignedTo { get; set; } 
     public string CreatedBy { get; set; } 
 }
```

From looking at the model in Listing 2.12 we can learn a few interesting tidbits. First, we can see that each class stands on
its own. We don't have a `Person` property on `ToDoTask` or `Tasks` collection on `Person`. We'll about modeling more 
extensively in [Chapter 4](#client-api), but the gist of modeling in RavenDB is that each document is independnt, isolated and
coherent. 

What does this mean? We should be able to take a single document and work with it successfully without having to look or load 
at additional documents. The easiest way to think about it is to think about physical documents. With phyiscal documents, I am
able to pick up the document and read it, and it should make sense. References to other locations are frequent, but they'll 
usually also give me enough information in the document itself so I don't _have_ to go and read those references.

In the case of the `ToDoTask`, I can look at my tasks, create new tasks or mark them as completed without having to look the 
`Person` document. This is quite a shift from working with relational database, where traversing between rows and tables in 
very common and frequently required. 

Let us see how we can create a new task and assign it to a person. Listing 2.13 shows an interesting feature of 
RavenDB, take a look and see if you can find the oddity.

```{caption="Creating a new person document" .cs}
using (var session = store.OpenSession())
{
    var person = new Person
    {
        Name = "Oscar Arava"
    };
    session.Store(person);
    Console.WriteLine(person.Id);
    session.SaveChanges();
}
```

RavenDB is transactional, and we only send the request to the server on `SaveChanges`, so how come we can print
the `person.Id` property before we called `SaveChanges`? Document identifier and how they are generated is covered
later in this chapter, but the basic idea is that the moment we returned from `Store`, the RavenDB client already
ensured that you have a valid id to use with this document. As you can see with Listing 2.14, this can be quite
important when you are creating two documents at the same time, with references between them.

```{caption="Creating a new person and assiging him a task at the same time" .cs}
using (var session = store.OpenSession())
{
    var person = new Person
    {
        Name = "Oscar Arava"
    };
    session.Store(person);

    var task = new ToDoTask
    {
        DueDate = DateTime.Today.AddDays(1),
        Task = "Buy milk",
        AssignedTo = person.Id,
        CreatedBy = person.Id
    };
    session.Store(task);
    session.SaveChanges();
}

```

Now that we know how to write multiple documents and create associations between documents, let us see how we read them back,
with a catch, we want to do that efficently.

#### Includes

RavenDB doesn't actually _have_ references in the usual sense, there is no such thing as foreign keys as you might be used to. 
A reference to another document is just a string property that happens to contains the id of another document. What does this
mean for working with the data? Let us say that we want to print the details of a particular task, including the name of the 
person assigned to it. Listing 2.15 shows the obvious way to do this.

```{caption="Displaying the details of a task (and its assigned person)" .cs}
using (var session = store.OpenSession())
{
    string taskId = Console.ReadLine();

    ToDoTask task = session.Load<ToDoTask>(taskId);
    Person assignedTo = session.Load<Person>(task.AssignedTo);

    Console.WriteLine($"{task.Id} - {task.Task} by {assignedTo.Name}");

	// will print 2
    Console.WriteLine(session.Advanced.NumberOfRequests); 
}

```

This code works, but it is inefficient. We are making _two_ calls to the server here, once to fetch the task, and another to
fetch the assigned user. The last line of Listing 2.15 prints how many requests we made to the server. This is part of the 
budgetting and awareness program RavenDB has, to reduce the number of remote calls and speed up your applications.

> **Error handling** 
> 
> Listing 2.15 really bugged me when I wrote it, mostly because there are a lot of error handling that isn't being done. 
> The task id being empty, the task document not existing, the task not being assigned to anyone... you get the drift. I just
> wanted to mention that most code samples in the book will contain as little error handling as possible so as not to distract
> from the code that actually _does_ things.

Having to go to the database twice is a pity, because the server already know what is the value of the `AssignedTo` property, 
and it could send the document that match the value of that property at the same time it is sending us the task. This is a 
favorite feature of mine, because I still remember how excited I was when we finally figured out how to do this in a clean 
fashion. Look at Listing 2.16 to see how it works, and compare it to Listing 2.15.

```{caption="Task and assigned person - single roundtrip" .cs}
using (var session = store.OpenSession())
{
    string taskId = Console.ReadLine();

    ToDoTask task = session.Include<ToDoTask>(x => x.AssignedTo)
    				  .Load(taskId);
    
    Person assignedTo = session.Load<Person>(task.AssignedTo);

    Console.WriteLine($"{task.Id} - {task.Task} by {assignedTo.Name}");

 	// will print 1
    Console.WriteLine(session.Advanced.NumberOfRequests);
}

```

The only difference between the two code listings is that in Listing 2.16 we are calling to `Include` before the `Load`. The 
`Include` method intructs RavenDb that when it loads the document, it should look at the `AssignedTo` property and if there a
document with the document id that is stored in the `AssignedTo` property, it should send it to the client imediately.

However, we didn't change the type of the `task` variable, it remains a `ToDoTask`, so what exactly did this `Include` method 
do here? What happened is that the session got the reply from the server, saw that there are included documents, and put them
in its `Identity Map`. When we request the `Person` instance that was assigned to this task, we already have that information
in the session, and we don't have to go to the server to fetch it.

The API is almost the same, and except for that call everything else remains the same, but we managed to cut the number of 
remote calls we make significantly. You can `Include` multiple properties, to load several referenced documents (or even a
collection of them) efficeintly. This is similar to a `JOIN` in a relational database, but much more efficent, since you don't
have to deal with Cartesian Product and it doesn't modify the shape of the results. 

> **Includes aren't joins**
> 
> It is tempting to think about Includes in RavenDB as similar to a join in a relational database. And there are similarities, 
> but there are fundamental differences.
> A join will modify the shape of the output, it combines each matching row from one side with each matching row on the other, 
> sometimes creating Cartesian Products that are can cause panic attacks for your DBAs.
> 
> And the more complex your model, the more joins you'll have, the wider your result sets become, the slower your application
> will become. In RavenDB, there is very little cost to adding includes. That is because they operate on a different channel
> than the results of the operation and don't change the shape of the returend data.
> 
> Includes are also important in queries, and there they operate _after_ paging has applied, instead of before paging, like
> joins. 
> 
> The end result is that Includes don't modify the shape of the output, don't have a high cost when you use multiple includes
> and don't suffer from problems like Cartesian Products.

`Include` cannot, however, be used to include documents that are referenced by included documents. In other words, `Include` is
not recursive. This is quite intentional, because allowing includes on included documents will lead to very complex requests, 
both for the user to write and understand and for the server to execute. You _can_ actually do recursive includes in RavenDB, 
but that features is exposed differently (via transformers, which we'll cover in [Chapter 18](#advanced-indexes)).

Using multiple `Include` on the same operation however, is just fine. Let us load a task and with it we'll include both the
assigned to person and the one who created the task. This can be done using the following snippet:

  	ToDoTask task = session.Include<ToDoTask>(x => x.AssignedTo)
  						   .Include(x => x.CreatedBy)
    				  	   .Load(taskId);

Now I can load both the `AssignedTo` person and the `CreatedBy` one, and still have just a single round trip to the server. 
What about when both of them are pointing at the same document? RavenDB will return just a single copy of the document, even if
it was included multiple times, and on the session side of things, you'll get the same instance of the entity when you load it
multiple times. 

As powerful as the `Include` feature is, one of _the_ most common issues that we run into with RavenDB is people using 
RavenDB with a relational mindset, trying to use RavenDB as if it was a relational database and modeling their entities
accordingly. `Include` can help push you that way, because they let you get associated documents easily. 

We'll talk about modeling in a lot more depth in [Chapter 4](#client-api) , when you have learned enough about the kind of 
environment that RavenDB offers to make sense of the choices we make.

#### Delete

Deleting a document is done through the appropriately named method `Delete`. This method can accept an entity instance or a
document id. The following are various ways to delete a document:

	var task = session.Load<ToDoTask>("ToDoTasks/1");
	session.Delete(task); // delete by instance

	session.Delete("ToDoTasks/1"); // delete by id

It is important to note that calling `Delete` doesn't actually delete the document. It merely marks that document as deleted
in the session. It is only when `SaveChanges` is called that the document will be deleted.


#### Query

Querying is a large part of what RavenDB does. Not surprisingly, queries strongly relate to indexes, and we'll talk about
those extensively in [Part III](#map-indexes). You already seen some basic queries in this chapter, so you seen how we can 
query to find documents that match a particular predicate, using Linq.

Like documents loaded via the `Load` call, documents that were loaded via a `Query` are managed by the session. Modifying
them and calling `SaveChanges` will result in their update on the server. A document that was returned via a query and was
loaded into the session explicitly via `Load` will still have only a single instance in the session, and will retain all the
changes that were made to it^[You can call `session.Advanced.Refresh` if you want to force the session to update the state of
the document from the server].

Queries in RavenDB do not behave like queries in a relational database. RavenDB does not allow computation during queries, and
it doesn't have problems with table scans or slow queries. We'll touch on exactly why and the details about indexing in the
[Part III](#map-indexes), but for now you can see that most queries will Just Work for you.

#### Store

The `Store` command is how you associate an entity with the session. Usually, this is done because you want to create a new
document. We have already seen that method used several times in this chapter, but here is the relevant part:

	var person = new Person
    {
        Name = "Oscar Arava"
    };
    session.Store(person);

Like the `Delete` command, `Store` will only actually save the document to the database when `SaveChanges` is called. However, 
it will give the new entity an id immediately, so you can refer to it in other documents that you'll save in the same batch. 

Beyond saving a new entity, `Store` is also used to associate entities of existing documents with the session. This is common 
in web applications. You have one endpoint that sends the entity to the user, who modify that entity and then sends it back to
your web application. You have a live entity instance, but it is not loaded by a session or tracked by it. 

At that point, you can call `Store` on that entity, and because it doesn't have a null document id, it will be treated as an
existing document and overwrite the previous version on the database side, instead of first having to load the database 
version, update it and then save it back.

`Store` can also be used in optimistic concurrency scenarios, but we'll talk about this in more details in [Chapter 4](#client-api).

#### SaveChanges

The `SaveChanges` call will check the session state for all deletions and changes, and send all of those to the server as a 
single remote call that will complete transactionally. In other words, either all the changes are saved as a single unit, or
none of them do.

Remember that the session has an internal map of all the loaded entities. When you call `SaveChanges`, those loaded entities 
are checked against the entity as it was when it was loaded from the database. If there are any changes, that entity will be 
saved to the database.

It is important to understand that any change would force the entire entity to be saved. We don't attempt to make partial 
document updated in `SaveChanges`. An entity is always saved to a document as a single full change.

The typical way one would work with the session is:

	using (var session = documentStore.OpenSession())
	{
		// do some work with the session

		session.SaveChanges();
	}

So `SaveChanges` is called usually only once per session, although there is nothing wrong will calling it multiple times. If 
the session detects that there have been no changes to the entities, it will skip calling to the server entirely.

With this, we conclude the public surface area of the session. Those methods allow us to do about 90% of everything that you 
could wish for with RavenDB. For the other 10%, we need to look at the `Advanced` property. 

#### Advanced

The surface area of the session was quite carefully designed so that the common operations were just a method call away from 
the session, and that there would be few of them. But while this covers a lot of the most common scenarios, that isn't enough 
to cover them all. 

All of the extra options are hiding inside the `Advanced` property. You can use that to configure the behavior of optimistic concurrency on a per session basis using:

	session.Advanced.UseOptimisticConcurrency = true;

Or you can define it once globally by modifying the conventions:

	documentStore.Conventions.UseOptimisticConcurrency = true;

Force a re-load an entity from the database to get the changes has been made there since that entity was loaded:

	session.Advanced.Refresh(product);

You can make the session forget about an entity (it won't track it, apply changes, etc):

	session.Advanced.Evict(product);

I'm not going to go over the `Advanced` options here. They are quite a few, and they covered in the documentation quite nicely.
It is worth to take the time to read about it, even if you will rarely have to use that.

### The Async Session

So far, we have shown only synchronous work with the client API. But async support is crucial for high performance 
applications, and RavenDB has full support for that. In fact, that is the recommended mode, and the synchronous is actually 
built on top of the async version. The async API is exposed via the async session.  In all respects, they are identical to the 
sync versions. 

```{caption="Working with the async session" .cs }
using (var session = documentStore.OpenAsyncSession())
{
	var person = new Person
    {
        Name = "Oscar Arava"
    };
    await session.StoreAsync(person);
	await session.SaveChangesAsync();
}

using (var session = documentStore.OpenAsyncSession())
{
	var tasksPerDayQuery =
        from t in session.Query<ToDoTask>()
        group t by t.DueDate into g
        select new
        {
            DueDate = g.Key,
            TasksPerDate = g.Count()
        };
    List<ToDoTask> tasksToDo = await tasksPerDayQuery.ToListAsync();

  	foreach (var task in tasksToDo)
    {
        Console.WriteLine($"{task.Id} - {task.Task} - {task.DueDate}");
    }

}
```

Listing 2.17 shows a few examples of working with the async session. For the rest of the book, we'll the async and synchronous 
sessions both to showcase features and the behavior of RavenDB. 

RavenDB splits the sync and async API because their use cases are quite different, and having separate APIs prevent you from 
doing some operations synchronously and some operations asynchronously. Because of that, you cannot mix and use the 
synchronous session with async calls, or vice versa. You can use either mode in your application, depending on the environment 
you are using. Aside from the minor required API changes, they are completely identical. 

The async support is very deep, all the way to the I/O issued to the server. In fact, as I mentioned earlier, the synchronous 
API is built on top of the async API and async I/O.

We covered the basics of working with the RavendB Client API in this section, but that was mostly the mechanics. We'll dive deeper into using RavenDB in the next chapter, where we'll also learn about the details and how it is all put together.

### Going below the session

"Orges are like onions", said Shrek, and in a way, so is the RavenDB Client API. At the top, and what you'll usually interact
with you will find the document store and the document session. They, in turn, are built on top of the notion of `Operations` 
and `Commands`. An `Operation` is a high level concept, such as loading a document from the server.

> **Deep dive note**
> 
> I'm going to take a small detour to explain how the RavenDB Client API is structured internally, this shouldn't have an
> impact on how you are _using_ the client API, but it might help you better understand how the client is put together. 
> Feel free to skip this section for now and come back to it at a later date.

The `LoadOperation` is the canonical example of this. A session `Load` or `LoadAsync` will translate into a call to the 
`LoadOperation` which will run all the associated logic (`Identity Map`, `Include` tracking, etc) up to the point where it
will call to the server. That portion is handled by the `GetDocumentCommand`, which knows how to ask the server for a document
(or a set of documents) and how to parse the server reply.

The same `GetDocumentCommand` is also used by the `session.Advanced.Refresh` method to get an updated version of the document
from the server. You'll typically not be using any of that directly, only through the session. Occasions to use an `Operation` 
directly usually arise when you are writing some sort of management code, such as Listing 2.18, which create a new database
on the cluster.

```{caption="Creating a datbased named 'Orders' using Operation" .cs}
var dbRecord = new DatabaseRecord("Orders");
var createDbOp = new CreateDatabaseOperation(dbRecord);
documentStore.Admin.Server.Send(createDbOp);
```

A lot of the management functionality (creating and deleting databases, assigning permissions, changing configuration, etc) 
are available as operations that can be invoked in such a manner. 

In other cases, you can use an `Operation` to run something that doesn't make sense in the context of a session. For example,
let us say that I wanted to delete all of the tasks in the database, I could do it with the following code:

	store.Operations.Send(new DeleteCollectionOperation("ToDoTasks"));

The reason that they are exposed to the user is that the RavenDB API, at all levels, is built with the notion of layers. The
expectation is that you'll usually work with the highest layer, the session API. But since we can't predict all things, we
also provide access to the lower level API, on top of which the session API is built, so you can user that if you need 
to.

## Document identifiers in RavenDB

The document id is a unique string that globally identify a document inside a RavenDB database. A document id can be any 
UTF8 string up to 512 bytes, although getting to those sizes is _extremely_ rare. You have already seen document ids used in
this chapter. Those were `people/1-A`, `ToDoTasks/4-A` and the like. Using a `Guid` like `92260D13-A032-4BCC-9D18-10749898AE1C`
is possible, but not recommended because it is opaque and very hard to read / work with.

By convention, we typically use the collection name as the prefix, a slash and then the actual unique portion of the key. But
you can also call your document `hello/world` or 'what-a-wonderful-world'. For the adventerous, Unicode is also a valid 
option. The character `U+1F426` is also a valid document id. Trying to use that in RavenDB is actually possible, as you can 
see in Figure 2.11. Amusingly enough trying to include the raw Emoji character in the book broke the build for this book.

![Unicode gave us Emojis, and the birdie document](./Ch02/img11.png)

While going full on Emoji for document names might be going to far^[Althouh, when you think about it, there is this huge 
untapped market of teenage girls developers...], using Unicode for document ids means that you don't have to worry if you need
to put Unicode character (such as someone's name) in the document id.

> **RavenDB and Unicode**
> 
> I hope that it goes without saying that RavenDB has full support for Unicode. Storing and retrieving document, querying on
> Unicode data and pretty much any and all actions are supported. I haven't talked about it so far because it seems like an
> obvious requirement, but I think it is better to state this support explicitly.

So RavenDB document ids are Unicode strings up to 512 bytes in length, which much be globally unique in the scope of the 
database. Unlike a relational database, where a primary key must only be unique in the scoep of its table. This has never been
a problem, because we typically use the collection name as the prefix to the document key. Usually, but not always, there is no
requirement that a document in a specific collection will use the collection name prefix as the document key, and there are a 
few interesting scenarios that open up because of this feature, discussed later in this section.

> **Human readable document ids**
>
> Usually, we strongly recommend to have document ids that are human readable (`ToDoTasks/123-A`, 
> `people/oscar@arava.example`). We often use identifiers for many purposes. Debugging and troubleshooting are not the least
> of those. 
> 
> A very simple way to generate ids would be by just generating a new `Guid`, such as `92260D13-A032-4BBC-9D18-10749898AE1C`, 
> but if you ever had to read a `Guid` over the phone, or keep track of multiple `Guid`s in a log file, or just didn't realize 
> that the `Guid` in this paragraph and the one at the start of this section aren't in fact the same Guid...
>
> If you are anything like me, you went ahead and compared the two `Guid`s to see that they actually don't match. Given how 
> hard that is, I believe that the point is made. `Guid`s are not friendly, and we want to avoid having to deal with them on
> an ongoing basis if we can avoid it.

So pretty much the only thing we require is some way to generate a unique id as the document id. Let us see the strategies that
RavenDB uses to allow that. 

### Semantic (external) document identifiers

The most obvious way to get an identifier is to ask the user to generate it. This is typically when the identifier is some 
sort of meaningful value. For example, `people/oscar@arava.example` or `accounts/591-192` are two document ids 
that the user (that's you) can choose. Listing 2.18 shows how you can provide an external identifier when creating documents.

```{caption="Saving a new person with an externally defined document id" .cs}
using (var session = store.OpenSession())
{
    var person = new Person
    {
        Name = "Oscar Arava"
    };
    session.Store(person, "people/oscar@arave.example");
    session.SaveChanges();
}
```

The `people/oscar@arava.example` example, using the email in the document id, is a common technique to generate a human 
readable document id and to force uniqueness of a certain value (the uniqueness of the email). The second 
example uses a unique key that is defined in another system. This is very common if you are integrating with existing systems
or have an external feed of data into your database.

### Nested document identifiers

A special case of external document naming is when we want to handle nested documents. Let us consider a financial system, that
needs to track accounts and financial transactions on those accounts. We have our account document `accounts/591-192` but we 
also have all the financial transactions about this account that we need to track. 

We'll discuss this exact scenario in the next chapter, when we'll talk about modeling, but for now I'll just say that it isn't
practical to hold all the transactions directly inside the account document, so we need to put that in separate documents. We
_could_ just name those documents `transactions/1234`, `transactions/1235`, etc. It would work, but there are better ways. 

We are going to store the transactions information on a per day basis, using names that embed both the owner account and the 
time of the transactions: `accocunts/591-192/txs/2017-05-17`. This document holds all the transactions for the `591-192` 
account for May 17th, 2017. 

> **RavenDB doesn't care about your document ids**
> 
> RavenDB treats the document ids as opaque values, and doesn't attach any meaning to a document whose key is the prefix
> of other documents. In other words, as far as RavenDB is concerned the only thing that `accocunts/591-192` and 
> `accocunts/591-192/txs/2017-05-17` have in common is that they are both documents.
> 
> In practice, the document ids are stored in a sorted fashion inside RavenDB, and it allows for efficient scanning of all
> documents with a particular prefix quite cheaply, but this is a secondary conern. What we really are trying to achieve here
> is to make sure that our document ids are very clear about their contents. 

You might recall that I mentioned that RavenDB doesn't require documents within a given collection to be named with the 
collection prefix. This is one of the major reasons why, because it allows you to nest document ids to get yourself a clearer
model of your documents.

### Client side identifier generation (hilo)

External identifier and nesting document ids are nice, but they tend to be the exception rather than the rule. For the most 
part, when we create documents, we don't want to have to think about what ids we should be giving them. We want RavenDB to 
just handle that for us.

> **RavenDB is a distributed database**
> 
> A minor wrinkle with generating identifiers with RavenDB is that the database is distributed and capable of handling writes
> on any of the nodes without require any coordination between them. On the plus side, it means that in the precense of 
> failures we stay up and able to process requests and writes. On the other hand, it can create non trivial complexities. 
> 
> If two clients try to create a new document on two nodes in parallel, we need to ensure that they will not accidently create
> documents with the same id by accident^[If the user explicitly specified the document id, there is nothing that RavenDB
> _can_ do here, but for ids that are being generated by RavenDB (client or server), we can do better than just hope that
> we'll have no collisions].
>
> It is important to note, even at this early date, that such conflcits are part of life in any distributed database, and that
> RavenDB contains several ways to handle them (discussed in [Chapter 6](#clustering-deep-dive)). 

Another wrinkle that we need to consider is that we really want to be able to generate document ids on the client, since that 
allows us to write code that create a new document and uses its id immediately, in the same transaction. Otherwise, we'll need
to call to the server to get the id, then make use of this id in a separate transaction.

RavenDB handles this by using an algorithm called `hilo`. The concept is pretty simple. The first time that you need to 
generate an identifier, you reserve a _range_ of identifiers from the server. The server is responsible for ensuring that it 
will only provide that range to a single client. Multiple clients can ask for ranges at the same time, and they will receive 
different ranges. Each client can then safely generate identifier within the range it was given, without requiring any further
coordination between client and server.

This is extrmely efficient, and it scales nicely. RavenDB uses a dynamic range allocation scheme, in which the ranges provided
to the client can expand if the client is very busy and generates a lot of identifiers very quickly (and thus consuming the 
entire range very quickly).

This is the default approach in RavenDB and the one we have used so far in this book. There is still another wrinkle to deal 
with, though. What happens if two clients request id ranges from two different nodes at the same time? At this point, each 
node is operating independently (indeed, a network failure might mean that we are not _able_ to talk other nodes). In order
to handle this scenario properly, each range is also stamped with the id of the node that assigned that range. This way, even
if those two clients have managed to get the same range from each node, the ids that will be generated will be unique.

Let us assume that the first client got the range `128 - 256` from node `A` and the second client got the same range from node 
`B`. The `hilo` method on the first client will generate document ids like `people/128-A`, `people/129-A`, and on the second
client it will generate `people/128-B`, `people/129-B`, etc. 

It is important to note that in most cases, this is a rarely occuring scenario. Typically the nodes can talk to one another and
share information about the provided id ranges, and even if they can't, all clients will typically try to use the same server
for getting the ranges, so you need multiple concurrent failures to cause this. If it _does_ happen, RavenDB will handle this
smoothly, and the only impact is that you'll have a few documents with similar ids, a minor consideration indeed.

### Server side idenitifer generation

The `hilo` is quite nice and it generates human readable and predictable identifiers. However, it requires both client and 
server to cooperate to get to the end result. This is not an issue if you are using any of the RavenDB client APIs, but if
you are writing documents directly (using the RavenDB Studio, for example) or don't care to assign the ids yourself, there 
are additional options. 

You can ask RavenDB to assign a document id to a new document when it is saved. You do that by providing a document id that 
ends with the pipe symbol (`|`). Go into the RavenDB Studio and create a new document. Name it `tryouts|` and then click on
the `Save` button. The generated document id should look something like Figure 2.12. 
 
![Server side generated document id (tryouts/0000000000000000021-A)](./Ch02/img12.png)

When you save a document whose id ends with a pipe symbol, RavenDB will generate the id for you. It will replace the pipe
character with a slash (`/`) and append a numeric value (the only guarantee you have about this value is that it is always
increasing) and the node id. 

> **Don't generate similar ids manually**
>
> Due to the way we implement server side identifier generation, we can be sure that RavenDB will never generate an id that
> was previously generated. That allows us to skip some checks in the save process (avoid a B+Tree lookup). Since server side
> generation is typically used for large batch jobs, this can have a large impact on performance. 
> 
> What this means is that if you manually generate a document id with a pattern that matches the server side genearted ids, 
> RavenDB will not check for that and will _overwrite_ the existing document. That is partly why we are putting all those
> zeros in the id, to make sure that we aren't conflicting with any existing document by accident.

This kind of id plays very nicely with how RavenDB actually store the information on disk, which is nice. We'll give this 
topic a bit more time further down in the chapter. This is the recommended method if you need to just generate a large number
of documents, such as in bulk insert scenarios, since it will generate the least amount of work for RavenDB.

### Identity generation strategy

All the id generation strategies that we outlined so far have one problem, they don't give you any promise with regards to the 
end result. What it does is give you an id that you can be sure will be unique, but that is all. In the vast majority of the 
cases, this is all you need. But sometimes, you need a bit more. 

If you really need to have consecutive ids, you can use the identity option. Identity, just like in a relational database 
(sometimes called sequence) is a simple always incrementing value. Unlike the hilo option, you always have to go to the server 
to generate such a value. 

Generating identities is very similar to generating server side ids. But instead of using the pipe symbol (`|`) at the end of 
the document, you use a slash (`/`). In the studio, try to save a document with the document id `tryouts/`. This will generate
a document with the id `tryouts/1`, doing so again will generate `tryouts/2`, etc.

> **Invoices, and other tax annoyances**
> 
> For the most part, unless you are using semantics ids (covered earlier in this chapter), you shouldn't care what your
> document id is. The one case you care is when you have an outside requirement to generate absolute consecutive ids. One 
> such common case is when you need to generate invoices.
>
> Most tax authorities have rules about not missing invoice numbers, to make it just a tad easier to actual audit your 
> system. But an invoice document's _identifier_ and the invoice _number_ are two very different things. 
> 
> It is entirely possible to have the document id of `invoices/843-C` for invoice number `523`. And using an identity does
> not protect you from skipping values because documents has been deleted, or a failed transaction consumed the identity
> and now there is a hole in the sequence.

For people coming over from relational database background, this usually seems to be the best option, since it is the one that
they are most familiar with. But update an identity happens in a _separate transaction_ than the current transaction. In other words, if we try to save a document with the name `invoices/`, and the transaction failed, the identity value is still 
incremented. So even though identity generate consecutive numbers, it might still skip ids if a transaction has been 
rollbacked. 

Except for very specific requirements, such as an actual legal obligation to generate consecutive numbers, I would strongly
recommend not using identity. Note my wording here, a legal obligation doesn't arise because someone want consecutive ids 
because they are easier to grasp. Identity has a real cost associated with it.

The biggest problem with idenities is that generating them in a distributed database require us to do a lot more work than one
might think. In order to prevent races such as two clients generating the same identity on two different servers, part of the
process of generating a new identity requires the nodes to coordinate with one another^[This is done using the Raft Consensus
protocol, which we'll cover in [Part III](#clustering-setup).]. 

That means that we need to go over the network and talk to the other members in the cluster to guarantee that we have the next
value of the identity. That can increase the cost of saving a new document with identity. What is worse is that under failure
scenarios we might not be able to communicate with a sufficent number of nodes in our cluster, which means that we'll also be
unable to generate the requested identity. 

Because we _guarantee_ that identities are always consecutive across the cluster, if there is a failure scenario that prevent 
us from talking to a majority of the nodes, we'll not be able to generate the identity at all, and fail to save the new 
document. All the other id generation methods can work without issue when we are disconnected from the cluster, so unless you
truly need consecutive ids, use one of the other options. 

### Performance implications of document identifiers

We have gone over a lot of options for generating document identifiers, and each of them have their own behaviors and costs. 
There are also performance difference between the various methods that I wanted to talk about.

> **Premature optimization warning**
> 
> This section is included because it is important at scale, but for most users, there is no need to consider this at all. 
> RavenDB is going to accept whatever document ids you throw at it, and it is going to be _very_ fast when it is doing so. 
> My strong recommendation is that you'll use whatever document id generation that best match what _you_ need and only consider
> the performance impact if you actually notice an observable difference or have cross the hundreds of millions of documents
> per database mark. 

RavenDB keep track of the document ids by storing them inside a B+Tree. If the keys are very big, it will mean that RavenDB can
fit fewer of them inside a single database page, and that we'll need to do a bit more work to find the right document. The same
is true for saving unsorted document ids, which can cause page splits and increase the depth of the tree. In nearly all cases, that doesn't really matter. 

The `hilo` algorithm generates document ids that are lexically sortable, up to a degree (`people/2` is sorted after 
`people/100`). But except when we add a digit to the number^[Rolling from `99` to `100` or from `999` to `1000`], the values 
are nicely sorted. This means that for the most part, we get nice trees and very efficient searches. It also generates the 
most human readable values.

The server side method using the pipe symbol (`|`) generates the best values in terms of suitability for storage. They are a 
bit bigger than the comparable `hilo` values, but they make up for that by being always lexically sorted and predictable as 
far as the underlying storage is concerned. This is very well suited for large batch jobs, and contain a number of additional
optimizations in its codepath (we can be sure that this is a new value, so we can skip a B+Tree lookup, which matter if you are
doing that a _lot_). 

Semantics ids (`people/oscar@arava.example` or `accocunts/591-192/txs/2017-05-17`) tend to be unsorted, and sometimes that can 
cause people to want to avoid them, but this is very rarely a good reason to do so. RavenDB can very easily handle very large 
number of documents with those ids without any issue. 

> **Running the numbers**
>
> If you are familiar with database terminology then you are familiar with terms like B+Tree and page splits. In the case of 
> RavenDB, we are storing document ids separately from the actual document data, and we are making sure to coalesce the pages
> holding the document keys so we have a good locality of reference. 
> 
> Even with a database that holds a hundred million documents, the whole of the document ids data is likely to be memory 
> resident, which turns the cost of finding a particular document to be extremely cheap. 

The one option that you need to be cautious of is the use of the identity generation method. You need to be careful not to use
it without careful consideration and analysis. Identity requires network roundtrips to generate the next value, and it also 
become unavailable if the node cannot communicate with the other members in the cluster. 

## Documents metadata

The document data is composed of whatever it is that you're storing in the document. For the order document, that would be
the shipping details, the order lines, who the customer is, the order priority, etc. But you also need a place to store 
additional information, not related to the document itself, but _about_ the document. This is where the metadata comes into
place.

The metadata is also a JSON format, just like the document data itself. RavenDB reserves metadata property names that starts
with `@` for its own use, but you are free to use anything else. By convention, the users' custom metdata properties are 
using Pascal-Cased naming convention. In other words, we separate words with a dash and the first letter of each word is
capitalized, everything else is in lower case. RavenDB's internal metadata properties are using `@` prefix, all lower cased
and separating words using a dash (e.g: `@last-modified`).

RavenDB uses the metadata to store several pieces of information about the document that it keeps track of:

* The collection name - stored in the `@collection` metadata property and determine where RavenDB will store the document. 
  If the collection isn't set, the document will be placed in the `@empty` collection. The RavenDB Client API will 
  automatically assign an entity to a collection based on its type (you can control exactly how using the conventions).

* The last modified date - stored in the `@last-modified` metadata property in UTC format.
* The etag - stored in the `@etag` metadata property, and discussed at length in the next chapter.
* The client side type - This is a client side metadata property, so for .NET it will be named `Raven-Clr-Type`, for Java 
  client it will be `Raven-Java-Class`, for Python `Raven-Python-Type` and... you get the point. This is used solely by the
  clients to deserialize the entity into the right client side type.

You can use the metadata to store your own values, for example, `Last-Modified-By` is a common metadata property that is
added when you want to track who changed a document. From the client side, you can access the document metadata using the
code in Listing 2.19.

```{caption="Modifying the metadata of a document" .cs}
using (var session = store.OpenSession())
{
	var task = session.Load<ToDoTask>("ToDoTasks/1");
	var metadata = a.Advanced.GetMetadataFor(task);
	metadata["Last-Modified-By"] = person.Name;
	session.SaveChanges();
}
```

It is important to note that there will be no extra call to the database to fetch the metadata. Whenever you load the 
document, the metadata is fetched as well. The metadata is embedded inside the document and is an integral part of it.

> **Changing a document collection**
>
> RavenDB does _not_ support changing collections, and trying to do so will raise an error. You _can_ delete a document and
> then create a new document with the same name in a different collection, but that tends to be confusing, so it is best
> to be avoided if you can.


Once you have the metadata, you can modify it as you wish, as seen in the last line of code. The session tracks changes to
both the document and its metadata, and changes to either one of those will cause the document to be updated on the server 
once `SaveChanges` has been called.

Modifying the metadata in this fashion is possible, but it is pretty rare to do so explicitly in your code. Instead, you'll
usually use listeners (covered in [Chapter 4](#client-api)) to do this sort of work.

## Testing with RavenDB
