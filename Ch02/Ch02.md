
# Zero to 60 with RavenDB, from installation to usage

In this chapter, we will install RavenDB and start working with it. Before we can get started with RavenDB, we need to have a live instance that we can work with. There are several ways to run RavenDB:

* Development - console mode
* Production
    * Windows Service
    * IIS
* In the cloud - [RavenHQ](http://www.ravenhq.com)

The console mode is very useful for development, because you can see the incoming requests to RavenDB, and you can interact with the server directly. For production usage, you can install RavenDB as a Windows Service or in IIS. We'll discuss the relative merits of each option toward the end of this chapter. 

For running in the cloud, you can use the RavenDB as a Service option provided by [RavenHQ](http://www.ravenhq.com). You can read more on RavenHQ in Chapter TODO, for now, we'll focus on everything you need to get RavenDB running on your own machine.

## Setting up everything

Go to the [RavenDB download page](http://ravendb.net/download), and download the latest version. At the time of this writing, this is version 3.0. You should download the zip archive and extract it. Then go to the Start.cmd file and double click it.
This will start RavenDB in console (debug) mode as well as open your browser to point to the RavenDB Management Studio^[The acronym for the studio is RDBMS.]. 

Note the URL in the browser. By default, RavenDB will try to use http://localhost:8080 as its endpoint. But if you have a service already taking this port, it might select port 8081, etc. 

The studio will ask you to create a database, please name the database Northwind, and press the Create button. You can ignore the bundles selection for now, we'll discuss them at legnth later.
Now that we have a database, go to the Tasks tab and then to Create Sample Data dialog, press the Create Sample Data button. You should see a progress bar running for a short while, and now you have a new database, including data that we can play with.

> The Northwind database is the sample database that came with SQL Server, it has been used for decades as _the_ sample database in the Microsoft community. We choose this database as our sample data because it is likely already familiar to you in its relational format.

Go to the Documents tab and then select the Products collection on the left. You should see something similar to Figure 1.

![The Products collection in the Northwind database](.\Ch02\Figure01.png)

This looks remarkably similar to what you'll see in a relational database. The data is shown in grid format, and we have the "tables" on the left. If you click on one of the products (the link is on the left most column), you'll enter into the actual document view, as shown in Figure 2.

![Editing a product document in the RavenDB Studio](.\Ch02\Figure02.png)

Now we can actually see the JSON data of the documents. But products are pretty simple documents, pretty much a one to one translation from the relational model. Let us look at a more interesting example. Let us go to orders/827, you can use the Go To Document text box at the top of the studio to go directly there. The content of that document is shown is Listing 1.

You can see several interesting things in Listing 1. We no longer have a simple key/value model that matches exactly to the column values in the relational model. We can aggregate related information into a common object, as in the case of the ShipTo property which has all of the shipping information. 

But probably even more important is the way we are handling the line items. In the relational schema, those were relegated to a separate table. And loading the order's data would require us to join to that table. Here all of the order information, including the collection of line items are included directly in the document.

We'll discuss this at length when we talk about modeling in Chapter 3, but as you can imagine at this early stage, this capability significantly reduces both complexity and cost of getting the data from the database.

```{caption="The orders/827 document" .json }   
{
    "Company": "companies/73",
    "Employee": "employees/7",
    "OrderedAt": "1998-05-06T00:00:00.0000000",
    "RequireAt": "1998-06-03T00:00:00.0000000",
    "ShippedAt": null,
    "ShipTo": {
        "Line1": "VinbÃ¦ltet 34",
        "Line2": null,
        "City": "Kobenhavn",
        "Region": null,
        "PostalCode": "1734",
        "Country": "Denmark"
    },
    "ShipVia": "shippers/2",
    "Freight": 18.44,
    "Lines": [
        {
            "Product": "products/16",
            "ProductName": "Pavlova",
            "PricePerUnit": 17.45,
            "Quantity": 14,
            "Discount": 0.05
        }
    ]
}
```

We'll not be going through all the things that you can do with the studio. Instead, we'll refer back to it whenever we want to show you something new or interesting that has relevancy in the studio as well (the operational monitoring capabilities, visualization of work, etc).

Now that we have a running sytem, feel free to explore it a bit, and then we'll move to the fun part, using RavenDB in our application.

## Coding with RavenDB

Start Visual Studio and create a new Console Application Project named `Northwind`. Then, in the Package Manager Console, issue the following command:

	Install-Package RavenDB.Client

This command uses Nuget to get the RavenDB Client package and add a reference to it to your project. Now we just need to tell the client where the server is located. Add a using statement for `Raven.Client.Document`, and then create a document store, like so:

	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind"
	};

	documentStore.Initialize();

> Note that if your RavenDB server is running on a different port, you'll need to change the document store's url.

The document store is the starting point for all your interactions with RavenDB. If you have used NHibernate in he past, the DocumentStore is very similar to the SessionFactory. We use the document store to create sessions, which is how we usually read and write data from RavenDB.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<dynamic>("products/1");
		Console.WriteLine(p.Name);
	}

You can see that we didn't have to define anything, we can immediately start working with RavenDB. The schema less nature of RavenDB, combined with the dynamic option in C# allows us to work in a completely dynamic world. But for most things, we actually do want some structure. 
Our next step would be to introduce the model classes to our project. In the studio, go to the Tasks tab, then to the Create Sample Data dialog. Press the Show Sample Data Classes button, and copy the resulting text to Visual Studio. Listing 2 shows the Product sample data class.

```{caption="The sample Product class" .cs }   
public class Product
{
	public string Id { get; set; }
	public string Name { get; set; }
	public string Supplier { get; set; }
	public string Category { get; set; }
	public string QuantityPerUnit { get; set; }
	public decimal PricePerUser { get; set; }
	public int UnitsInStock { get; set; }
	public int UnitsOnOrder { get; set; }
	public bool Discontinued { get; set; }
	public int ReorderLevel { get; set; }
}
```

You can see that there really isn't anything special about this class. There is no special base class, attributes or even the requirement that the class would have virtual members. This is a Plain Old C# Object in its purest form. How do we use this class? Here is the same code as before, but using the Product class instead of dynamic.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<Product>("products/1");
		Console.WriteLine(p.Name);
	}

We load the product by id, then print out its name. It Just Works.

## Basic Theory

So far, we have setup RavenDB, explore the studio, wrote some code to connect to RavenDB and pull data out and defined strongly typed classes that allow us to work with RavenDB more easily.
This is all well and good, but as fun as blind experimentation is, we need to understand what is going on in order to do great things with RavenDB.

### The document store

You've already used the document store to talk to RavenDB, but what is its purpose? The document store holds the RavenDB url, the default database we'll talk to and the credentials that will be used. It is the first thing that we create when we need to talk to RavenDB. But its importance extends beyond just knowing who to talk to.

The document store holds all the client side configuration for RavenDB, how we are going to serialize your entities, how to handle failure scenario, what sort of caching strategy to use, and much mode. In typical application, you shall have a single document store instance per application (singleton). Because of that, the document store is thread safe, and a typical initialization pattern looks like Listing 3.

```{caption="Common pattern for initialization of the DocumentStore" .cs }   
public class DocumentStoreHolder
{
	private readonly static Lazy<IDocumentStore> _store = 
		new Lazy<IDocumentStore>(CreateDocumentStore);

	private static IDocumentStore CreateDocumentStore()
	{
		var documentStore = new DocumentStore
		{
			Url = "http://localhost:8080",
			DefaultDatabase = "Northwind",
		};

		documentStore.Initialize();
		return documentStore;
	}

	public static IDocumentStore Store
	{
		get { return _store.Value; }
	}
}
```

The use of Lazy ensures that the document store is only created once, without having to worry about double locking or explicit thread safety issues. And we can configure the document store as we see fit. The rest of the code cas access the document store using `DocumentStoreHolder.Store`. That should be relatively rare, since apart from configuring the document store, the majority of the work is done using the session.
But before we get to that, let us see what sort of configuration we can do with the document store.

#### Conventions

The RavenDB Client API, just like the rest of RavenDB, aims to Just Work. As a result of that, it is based around the notion of conventions. A series of policy decisions that has already been made for you. Those range from deciding which property holds the document id to how the entity should be serialized to a document.

For the most part, we expect that you'll not have to touch the conventions. A lot of thought and effort has gone into ensuring that you'll have no need to do that. But there is simply no way that we can foresee the future, or answer every need, which is what pretty much every part of the client API is customizable.

Most of that is handled via the `DocumentStore.Conventions` property, by registering your own behavior. For example, by default the RavenDB Client API will use a property named `Id` (case sensitive) to store the document id. But there are users who want to use the entity name as part of the property name. So we'll have OrderId for orders, ProductId for products, etc^[I'll leave aside Id vs. ID, since it is handled in the same manner].

Here is how we can tell the RavenDB Client API that it should use this behavior:

	documentStore.Conventions.FindIdentityProperty = 
		prop => prop.Name == prop.DeclaringType.Name + "Id";

I'm not going to go over each option in the conventions since there are literally dozens of them. There are API comments on each of the exposed options, and it is probably worth your time to go and peruse through them, even if for the most part, they aren't really something that you'll touch.

Other options that can be controlled via the document store are request timeout, caching configuration, creating indexes and transformers, setting up listeners, listening to changes and doing bulk inserts into RavenDB. We'll cover those futher into this book.

#### Connection strings

You might have noticed that when we defined the document store so far, we have done so using hard code url and database, like so:

	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind",
	};

This is great when we just want to play around, but it isn't really suitable for actually working with RavenDB on a day to day basis. Different environment has different urls, databases and credentials. In here, RavenDB make no attempt to invent the wheel and it uses connection strings to specify all the details. The following code snippet show how to configure RavenDB using a connection string:

	var documentStore = new DocumentStore
	{
		ConnectionStringName = "RavenDB"
	};

This code instructs the document store to go and look at the <connectionStrings> element in the web.config (or app.config) files. Listing 4 shows a sample of a few such connection strings:

```{caption="RavenDB Connection Strings" .xml }   
<connectionStrings>

    <add name="RavenDB" connectionString="Url=http://localhost:8080;
Database=Northwind;ApiKey=MyApp/1hjd14hdfs" />

	<add name="Another" connectionString="Url=http://localhost:8080;
User=beam;Password=up;Database=Scotty" />

	<add name="Embedded" connectionString="DataDir=~\Northwind" />

</connectionStrings>
```

In this manner, you can modify which server and database your client application will talk to by just modifying the configuration. You might also have noticed that we have an embedded connection string as well, what is that?

#### Document store types

RavenDB can run in several modes. The most obvious one is when you run it as a console application and communicate with it over the network. In production, you do pretty much the same thing, except that you'll run RavenDB in IIS or as a Windows Service. This is great for building server applications, where you want independent access to your database, but there are other options with RavenDB.

You can run RavenDB as part of your application, embedded inside your own process. If you want to do that, just use the `EmbeddableDocumentStore` class, instead of `DocumentStore`. You can even configure the `EmbeddableDocumentStore` to talk to a remote server or an embedded database just by changing the connection string.
The main advantage of using an embedded RavenDB instance is that you don't need separate deployment or administration. There is also no need to traverse the network to access the data, since it lives inside the same process as you own application.

This option is particularly attractive for teams building low overhead system or business applications that are deployed client side. [Octopus Deploy](https://octopusdeploy.com/) is an automated deployment system that make use of RavenDB in just such a manner. Even if you use it, you're probably not aware that it is using RavenDB behind the scenes, since that is all internal to the application.

On the other side, you have [NServiceBus](http://www.NServiceBus.com), which also make heavy use of RavenDB, but usually does so in a server mode. So you'll install RavenDB as part of your NServiceBus deployment and manage it as an independent service. 

From coding perspective, there is very little difference between the two. In fact, even in embedded mode, you are going through the same exact code paths you'll be going when talking to a remote database, except that there is no networking involved.

#### Authentication

A database holds a lot of information, and usually it is pretty important that you'll have control over who can access that information and what they can do with that. RavenDB fully supports this notion.

In development mode, you'll usually work with the `Raven/AnonymousAccess` setting set to `Admin`. In other words, any access to the database will be considered to be an access by an administrator. This reduce the number of things that you have to do upfront. But as easy as that is for development, for production, we set that setting to be `None`. This option require all access to the database server^[Note that this is a server level option, rather than a database level option] to be done only by authenticated users.

Users can be authenticated in one of two ways. Either using Windows Authentication via user/pass/domain credentials or using OAuth via an API Key^[You can think about this as Windows Authentication and SQL Authentication in SQL Server]. You can configure access to RavenDB by going to the Databases page in the Studio (click on the link at the top right corner), then selecting the System Database (on the right of the page). Now got to the Settings tab.

Here you can see the options for configuring access. In large organizations, it is very common to want to run all authentication through Active Directory, because that lets the operations team centralized control over all the users.
You can select Windows Authentication and then add a new user or group, and grant them access to specific databases. You can also grant access to all databases by using an asterisk (*) as the database name.

Even though using Windows Authentication is quite common, I really like using API Keys, instead. You can see how we configure API Keys in Figure 3. I've had quite a few issues with relying on Active Directory to really feel comfortable with it. Mostly because of... interesting policies that the organization defined. From password expiration every 3 months that take down systems that hasn't been updated to deleting "inactive" user accounts that take down systems to... I'm sure you get the point.

![Configuring API Keys access](.\Ch02\Figure03.png)

The good thing about API Keys is that they are _not_ users. They are not tied to a specific person or need to be managed as such. Instead, they represent specific access that was granted to the database for a particular reason. On Figure 3 you can see that read/write access was granted to the Northwind database for the OrdersApp API Key. I find that this is a much more natural way to handle authentication.

Regardless of the authentication method that was choosen, you can control the level of access to a database by granting read-only, read/write or admin permissions. Read-only and read/write are quite obvious, but what does it mean, to have admin privileges on a database?

#### Administrators

Being an administrator means that you can perform operational actions such as perform a backup, stop/resume indexing, kill queries or background tasks, compact the database or force index optimizations. Those are all admin actions at the single database level. A user or API Key can be granted an admin level on a single database, or all of them (by specifing asterisk as the database name). That does not make them the _server_ administrators.

The server administrators are anyone in the Administrators group for the domain or for the local machine RavenDB is running on. In addition to those, the user account who is running RavenDB also have a server administrator permission for RavenDB. This last is done so you can run RavenDB on a least privilege account and still do administration work on the server without requiring you to be a system administrator.

You can also configure specific users or API Keys as the server administrators. That can be done by granting them admin permission on the <system> database. A server administrator can create or delete databases, change database settings, force garbage collection, collect stats from all databases and in general watch over everything that happens.

It is possible to define a server administrator that can manage the server, but has no access to the actual databases on that server. This is usually used in scenarios where regulatory compliance forbid even the administrators from being able to access the data on the server. Usually in such scenarios, the Encryption bundle is also used, but that will be discussed later in the book. (TODO: reference)

We have gone over all the major aspects of the document store, but we have neglect one small detail. The reason that the document store even exists is that we use it to create sessions, which actually interact with RavenDB. It's a good thing that this is what our next section is talking about.

### The session

The session (formally known as document session, but we usually shorten it to just a session) is the primary way that your code interacts with RavenDB.

### Database commands

### Working with async

## Running in Production

## Where is my data stored. 

## Bundles