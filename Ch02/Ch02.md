
# Zero to RavenDB

[zero-to-ravendb]: The very first steps we need to take in our journey to understand RavenDB is to actually getting
it running on our machine, so we can actually get things done. I'm deferring discussion on what it is, how it works,
etc to a later part of this book, because I think that having a live version that you can play with will make it 
much easier to understand RavenDB.

## Setting RavenDB on your machine

For this section, I'm assuming that you are a developer trying to get a RavenDB instance so you can explore it. I'm
going to ignore everything related to actual production deployments in favor of getting your setup in as few steps 
as possible. Full discussion on how to deploy, secure and run RavenDB in product is available in 
[Chapter 19](#prod-deploy).

I'm going ot go over a few quick install scenarios, and you can select whichever one makes the most sense to your
setup. After that, skip to the next section where we'll actually start using RavenDB.

### Running on docker

What is probably the easiest way to get RavenDB is via Docker. If you already have Docker installed, all you need to
do is run the following command:

	docker run -e AllowAnonymousUserToAccessTheServer=true 
	       -p 8080:8080 ravendb/ravendb

And Docker will get the latest RavenDB version and spin a new container to host it. Note that we run it in 
developer mode, without any authentication.

The output of this command should look something like Listing 2.1.

```{caption="RavenDB Server Output"}   
       _____                       _____  ____
      |  __ \                     |  __ \|  _ \
      | |__) |__ ___   _____ _ __ | |  | | |_) |
      |  _  // _` \ \ / / _ \ '_ \| |  | |  _ <
      | | \ \ (_| |\ V /  __/ | | | |__| | |_) |
      |_|  \_\__,_| \_/ \___|_| |_|_____/|____/


      Safe by default, optimized for efficiency

 Build 40013, Version 4.0, SemVer 4.0.0-beta-40xxx, Commit ca31ca1
 PID 6, 64 bits
 Source Code (git repo): https://github.com/ravendb/ravendb
 Built with love by Hibernating Rhinos and awesome contributors!
+---------------------------------------------------------------+
 Listening to: http://10.0.75.2:8080
 Server started, listening to requests...
 Running as Service
 Tcp listening on 0.0.0.0:38888
 ```

The most important piece of information you have there is the `Listening to: http://10.0.75.2:8080`, which tells you
the URL to put in your browser to access the newly installed instance.

### Running on Windows

To setup RavenDB on Windows you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Windows x64, in this case) and download the `zip` file containing the binaries.

Extract the file to a directory and then run the `Start.cmd` script or `Server\Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing:

	Server\Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Running on Linux

To setup RavenDB on Linux you'll need to go to [https://ravendb.net/download](https://ravendb.net/download) and 
select the appropriate platform (Linux x64, most likely) and download the `tar.bz2` file containing the binaries.

**TODO: http://issues.hibernatingrhinos.com/issue/RavenDB-7020 ** Need to verify if we need `dotnet` or how to run
directly from the `tar.bz2` file on a brand new machine.

Extract the file to a directory and then run the `run.sh` script or `./Server/Raven.Server.exe` executable. This 
will run RavenDB in interactive mode, inside a console application, and you can access the server by going to 
[http://localhost:8080](http://localhost:8080) in your browser. 

If you already have port 8080 taken by something else, RavenDB will fail to start with an address in use error 
(more specifically `EADDRINUSE`). You can customize the port and host from the command line by issuing this
command:

	./Server/Raven.Server.exe --Raven/ServerUrl=http://localhost:8081

That will run RavenDB on port 8081, avoiding the conflicting port issue.

### Using the live demo instance

Without installing anything, you can point your browser to 
[http://4.live-test.ravendb.net](http://4.live-test.ravendb.net?source=book) and access the public demo instance 
that we have available. This is useful for quick checks and verifications, but it isn't meant for for anything 
more serious than that. 

Obviously, all data in the live instance is public, and there are no guarantees about availability. We use this 
instance to tryout the latest versions, so that is also a consideration. In short, if you need to verify something 
small, go ahead and hit that instance. Otherwise, you'll need your own version.

## Your first database

By now, you have already setup an instance of RavenDB to work with, and managed to load the RavenDB Studio in 
your browser. For simplicity's sake, I'm going to assume from now on that you are running on the local machine
on port 8080. Point your browser to [http://localhost:8080](http://localhost:8080) and you should be greeted with
an empty RavenDB instance. You can see how it looks in Figure 2.1.

![Empty RavenDB node](./Ch02/img01.png)

What we have right now is a RavenDB node that is a self contained cluster^[Actually, that is not really the case, 
but the details on the state of a new node are a bit complex and covered in the [Chapter 5](#clustering-setup)].
Now that we have a running node, the next stage it to create a new database on this node. 

You can do that by clicking on the `New database` button and naming it `Northwind`, accepting all the defaults for
the dialog. We'll discuss what all of those mean in [Chapter 19](#prod-deploy). Click on the `Create` button and 
that is pretty much it, your new database is ready, you can see how this looks like in Figure 2.2.

![New empty database](./Ch02/img02.png)

Of course, this new database contains no data, which make it a pretty hard to work with it. We'll use the 
`sample data` feature in RavenDB to have some documents that we can work with. On the left menu, go to `Tasks` and 
the to `Create Sample Data` and then press the `Create` button. 

Pressing this button will populate the database with the sample `Northwind` dataset. If you aren't familiar with 
Northwind, it is a sample dataset of an online store, including such common concepts as orders, customers and 
products. Let's explore this data set inside of RavenDB.

On the left menu, select `Documents` and you'll see a view similar to Figure 2.3. Showing the recently updates 
documents and the collections that were created. 

![Northwind documents view](./Ch02/img03.png)

Collections are the basic building blocks inside RavenDB. Every document belongs to exactly one collection, usually
based on the entity type of the document on the client. It is very similar to tables in a relational database, but 
unlike tables, there is no requirement that documents within the same collection will share the same structure or 
have any sort of schema.

Collections are very important to the way RavenDB organize and optimize the data internally, and the optimization 
opportunities that they provide are discussed at length in [Chapter 26](#stroage-layout). We'll frequently use 
collections to group similar documents together and apply some operation on them (subscribing to changes, indexing,
querying, ETL, etc).

Click on the `Orders` collection and then on the first document in the listing, which should be `orders/830'. The 
result is shown in Figure 2.4. This is the first time we are actually looking at the core reason RavenDb exists, 
a real JSON document.

![An orders document](./Ch02/img04.png)

If you are fammiliar with working with non relational databases, this is pretty obvious and non too exciting, but 
if you are mostly used to relational databases, there are several things to note here.

In RavenDB we are able to store arbitrarily complex data as a single unit. If you will look closely at Figure 2.4 
you'll see that instead of just storing a few columns, we can store rich information. By working with nested 
objects (`ShipTo` property) or arrays of complex types (the `Lines` property). 

This means that we don't have to split our data to statisfy the phyiscal constraints of our storage, we can store 
a whole object graph in a single document. We'll talk about modeling a lot more in [Chapter 3](#crud), but for now
I'll just mention that the basic modeling method in RavenDB is based around Root Aggregates and complete the 
picture in the next chapter.

In the meantime, you can explore the different collections and the sample data in the studio. We spent a lot of 
time and effort on the RavenDB Studio, and while I'll be the first to admit that it is pretty, looking at a 
syntax highlighted text editor isn't really that impressive. So let us see what kind of things we can do with the
data as a database.

## Working with the RavenDB Studio

This section will cover working the basics of working with data with the RavenDB Studio. If you are a developer, 
you're probably anxious to start seeing code, we'll get into that in the next section, no worries.

### Creating & Editing documents

When you look at a particular document, you can edit the JSON and click on `Save`, and the document will be saved.
There isn't really much to it, to be honest. Creating new documents is a bit more interesting. Let us create a new
category. 

In them left menu, go to `Documents` then under `Collections` click on `Categories` and then select 
`New document in current collection` as shown in Figure 2.5.

![New document in current collection](./Ch02/img05.png)

This will open the editor on a new document with an empty document based on one of the existing categories. Note
that the document id is set to `categories/`. Complete the contents of the document and save it. RavenDB wiil 
assign the document id automatically for you.

One thing that may not be obvious is that while the studio generates an empty document based on the existing ones,
there is no such thing as schema in RavenDB and you are free to add or remove properties and values and modify the
structure of the document however you feel like. This feature makes evolving your data model and handling more 
complex data much easier.


### Patching documents

The first thing we'll learn to do is how to do bulk operations inside the studio. On the left menu, go to 
`Documents` and then look at the bottom, where you'll find the `Patch` menu, click on it, and you'll see the 
screen shown in Figure 2.5.

![Patching the categories](./Ch02/img06.png)

Patching allows you to write a Javascript function that can modify the matching documents. To try this out, we'll
run a non trivial transformation on the `categories` documents, let us add location support and the ability to 
store the category name in mulitple languages using a patch script.

Put the code in Listing 2.2 in the `Patch script` text box.

```{caption="Patching categories for internationalization support" .js}   
	this.Name = [{"Lang": "en-us", "Text": this.Name }];
	this.Description = [{"Lang": "en-us", "Text": this.Description }];
```

You can click on `Test` and select a specific category document to view the results of running this operation on 
that specific document. The before & after results of running this script `categories/4` is showing in Figure 2.6.

![Internationalizing categories with Javascript patching](./Ch02/img07.png)

Patch scripts allows us to modify our documents en masse, and they are very useful when you need to reshape 
existing data. You can apply them on a specific document, a whole collection or all documents matching a specific
query.

It is important to mention that such bulk operations are not spanning a single transaction, but can be composed of
multiple transactions. For performance reasons, we might break such processing into multiple independnet (and 
concurrent transactions) that each process some portion of the data. Each independent transaction still maintain 
all the ACID properties, but not the patch operation as a whole.

### Deleting documents

Deleting documents in the studio can be done by going to a particular document and hitting the `Delete` button, if
you want to delete a particular document or deleteing a whole collection by going to the collection page (left 
menu, then `Documents` then selecting the relevant collection in the `Collections` menu), selecting all the 
documents in the header row and clicking the `Delete`.

### Querying documents

The previoud sections talked about how to Create, Update and Delete documents. But for full CRUD support, we still 
need to read documents. So far, we looked at documents whose ids were already known to us, or entire collections. 
In this section, we'll focus on querying documents based on their data.

In the left menu, go to `Indexes` and then to `Query`. This is the main screen for querying documents in the 
RavenDB Studio. As the index, select `dynamic/Companies` and in the query text box write `Address.Country: UK` and 
then click the query button. You can see the results of this query in Figure 2.8. 

![All companies in the UK query results](./Ch02/img08.png)

The studio can also guide you in how to compose queries (you probably noticed the `Add filter` helper when you 
wrote the query). We'll discuss indexes and querying at length in [Part III](#map-indexes). 

This section was meant to gigve you the basics of using the RavenDB Studio, not to be a thorough walkthrough of 
all the options. This is mostly here so you are familiar with the basics of using the studio and can see the 
results of what we are doing in code in the _next_ section, where we get to actual coding.

## Your first RavenDB program

We are finally at the good parts, where we can start slinging code around. For simplicity's sake, I'm going to use
a simple console application to explore the RavenDB API. Typically, RavenDB is used in web / backend applications, 
so we'll also explore some of the common patterns of organizing your RavenDB usage in your application later in 
this chapter.

The code in this book is using C#, but the documetnation can guide you on how to achieve the same results in any
supported clients. 

Create a new Console Application and run the following command on the `Package Manager Console`:

	Install-Package Raven.Client 
		-Source https://www.myget.org/F/ravendb/api/v3/index.json 
		-IncludePrerelease

This will setup the latest client version for RavenDB 4.0 on the project. The next step is to add a namespace
refeence by adding `using Raven.Client.Documents;` to the top of the `Program.cs` file. 

And now we are ready to start working with the RavenDB client API. The first thing we need to do is to setup access
to the RavenDB cluster that we are talking to. This is done by creating an instance of `DocumentStore` and setting
configuring it as showing in Listing 2.3.

```{caption="Creating a document store pointed to a local instance" .cs }   
var store = new DocumentStore
{
    Urls = { "http://localhost:8080" },
    DefaultDatabase = "Tasks"
};

store.Initialize();
```

This code setups a new `DocumentStore` instance and let it know about a single node, the one running on the local
machine, and that we are going to be using the `Tasks` database. The document store is the starting location for 
all communication with the RavenDB cluster. It holds the configuration, caching, any customizations that you might
have applied, etc.

Typically, you'll have a single instance of a document store per application (singleton pattern) and use that same
instance for the lifetime of the application. Before we can continue, however, we need to go ahead and create the 
`Tasks` database in the studio, so we'll have a real database to work with. 

The document store is the starting location for all RavenDB work, but the real work horse that we typically use is
the session. The session is the one that will hold our entities, talk with the server and in general acts as the 
front man to the RavenDB cluster.

Before we can actually start using the session, we need _something_ to actually store. It is possible to work with
completely dynamic data in RavenDB, but that is a specific scenario that is covered in the documentation. Most of
the time, you are working with your entities. For the purpose of this chapter, we'll use the notion of tasks to 
build a simple list of things todo. 

Listing 2.4 shows how an class that will be saved as a RavenDB document looks like. 

```{caption="Entity class representing a task" .cs }   
public class ToDoTask
{
    public string Id { get; set; }
    public string Task { get; set; }
    public bool Completed { get; set; }
    public DateTime DueDate { get; set; }
}
```

This is about as simple as you can get, but we are only starting, so that is good. Let us create a new task inside
RavenDB, reminding us that we need to pick up a bottle of milk from the store tomorrow. The code to perform this
task (pun intended) is shown in Listing 2.5.

```{caption="Saving a new task to RavenDB" .cs }   
using (var session = store.OpenSession())
{
    var task = new ToDoTask
    {
        DueDate = DateTime.Today.AddDays(1),
        Task = "Buy milk"
    };
    session.Store(task);
    session.SaveChanges();
}
```

We open a new session and create a new `ToDoTask`. We then store the task in the session and then call 
`SaveChanges` to save all the changes in the session to the server. You can see the results of this in Figure 2.9.

![The newly created task in the studio](./Ch02/img09.png)

As it so happpened, I actually was able to go to the store today and got some milk, so I need to mark this task as
completed. Listing 2.6 shows the code required to handle updates in RavenDB.

```{caption="Loading, modifying and saving a document" .cs }   
using (var session = store.OpenSession())
{
    var task = session.Load<ToDoTask>("ToDoTasks/1");
    task.Completed = true;
    session.SaveChanges();
}
```

You can notice several interesting things even in this very small sample. We load the document and modify it, then
we call `SaveChanges`. We didn't need to call `Store` again. Because the `task` instance was loaded via the session
it was also tracked by the session, and any changes made to it would be sent back to the server when `SaveChanges`
is called. 

The document session implements the `Unit of Work` design pattern and make it much easier to work with complex 
behaviors, since you don't need to manually track changes to your objects and decide what needs to be saved and what
shouldn't. It also means that the only time that the RavenDB client will send updates to the server is when you call 
`SaveChanges`. That, in turn, means that you'll experience a reduced number of network calls, all of the changes 
will be sent as a single batch to the server. And because RavenDB is transactional, all those changes will happen as
a single transaction, either completing fully or not there at all.

Let us exapnd on that and create a few more tasks, you can see how that works in Listing 2.7.

```{caption="Creating multiple documents in a single transaction" .cs }   
using (var session = store.OpenSession())
{
   for (int i = 0; i < 5; i++)
   {
       session.Store(new ToDoTask
       {
           DueDate = DateTime.Today.AddDays(i),
           Task = "Take the dog for a walk"
       });
   }

   session.SaveChanges();
}
```

You can see the end result of all this playing around in Figure 2.10. We are creating 5 new tasks and saving them in 
the same `SaveChanges` call, so they will be saved as a single transactional unit.

![All the current tasks](./Ch02/img10.png)

Now that we have all those tasks, we want to start querying on the data. I want to know what kind of tasks I have for
the next couple of days. In order to get that information, I can use the query in Listing 2.8.

```{caption="Querying upcoming tasks using Linq" .cs }   
using (var session = store.OpenSession())
{
    var tasksToDo =
        from t in session.Query<ToDoTask>()
        where t.Completed == false &&
              t.DueDate >= DateTime.Today &&
              t.DueDate <= DateTime.Today.AddDays(2)
        orderby t.DueDate
        select t;

    foreach (var task in tasksToDo)
    {
        Console.WriteLine($"{task.Id} - {task.Task} - {task.DueDate}");
    }
}
```

Running the code in Listing 2.8 code gave the following output:
	
	ToDoTasks/2 - Take the dog for a walk - 5/14/2017 12:00:00 AM
	ToDoTasks/3 - Take the dog for a walk - 5/15/2017 12:00:00 AM
	ToDoTasks/4 - Take the dog for a walk - 5/16/2017 12:00:00 AM

The query code sample show us using Linq to performance queries against RavenDB with very little hassle and no ceremony
whatsoever. There is actually a _lot_ going on behind the covers, but we'll leave all of that to 
[Part III](#map-indexes).

Let us look at an aggregation query, the code in Listing 2.9 giving us the results of all the tasks per day.

```{caption="Aggregation query on tasks" .cs }   
using (var session = store.OpenSession())
{
    var tasksPerDay =
        from t in session.Query<ToDoTask>()
        group t by t.DueDate into g
        select new
        {
            DueDate = g.Key,
            TasksPerDate = g.Count()
        };

    foreach (var tpd in tasksPerDay)
    {
        Console.WriteLine($"{tpd.DueDate} - {tpd.TasksPerDate}");
    }
}
```

If you are familiar with Linq, there isn't much to say about the code in Listing 2.9. It works, and it is very obvious and 
easy to understand. If you _aren't_ familiar with Linq, I strongly recommend learning it. From the consumer side, it is
very beautiful. As someone who had to implement querying using Linq a few times, it is utterly atrocious, but lucky for
you, that isn't _your_ problem, it's mine.

So far, we explored a bit about the RavenDB API, we saved documents, editted a task and queried the tasks in various
ways. This was intended to get you familiarized with the API and how to work with RavenDB. The client API was designed
to be very simple, focusing on the common CRUD scenarios. Deleting a document is as easy as calling `session.Delete` 
and all the complex options that you would need are packed insided the `session.Advanced` property. 

Now that you have a basic understanding of how to write a `Hello World` in RavenDB, we are ready to dig deeper and 
see the client API in all its glory.


## The RavenDB Client API 


## Testing with RavenDB