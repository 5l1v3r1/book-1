	
## Counters and Time Series in RavenDB

The previous chapter covered the RavenDB client API and focused on using RavenDB as a document database. This is the 
most common usage scenario for RavenDB, but it isn't the only one. We looked into attachments
in the previous chapter, as a way to add binary data to documents. In this chapter, we are going to talk about using
RavenDB to store counters and timeseries.

Like attachments, counters and time series are strongly tied to a docuemnt. Unless attachments, we aren't talking about
just storing binary data and calling a day. With both counters and time series, RavenDB support complex operation and 
the ability to understand and work with the data in non trivial ways.

But before we get to the gist of these features, let's talk about why does RavenDB even need to have dedicated features
such as these? Surely we can just store the data in the document itself and call it a day, no?

Consider the document fragement shown in Figure 5.1, in the image, you can see how we can store counters and time series
data directly in the document. So why do we need a dedicated feature for something that is already there?

![Document fragement storing counters and time series data](./Ch05/img01.png)

The answer is quite simple. If the data is inside the document, any change to the data means changing the document as a
whole. Consider the case of the `DownloadsCount` that we have in Figure 5.1. If we need to update it whenever a user 
click on a download link, what are the implications?

We can load the document, increment the count and save it back. This works, unless there are two users who click on the 
link at the same time. We can use a `Patch` operation to avoid concurrency issues, of course, but at the database's side
of things, RavenDB will still need to load/modify/store the document. 

Another important aspect is what happens when we have _other_ changes to the document while we are incrementing the 
value. Similar concerns apply to the `DailyDownloads` field as well. But in addition to the concurrency aspect of 
counters, with time series we have to take into account that the _size_ of the data might grow very big. To the point
where most of the document's data would be the time series data. And while we certainly want to keep track of that, we 
don't want to keep it in the same place as the document itself.

We have talked about diffrent ways to handle that, with splitting the logical document into separate phyiscal 
documents in the previous chapter. But a much better option is to have support for these scenarios directly inside 
RavenDB, which is why we have these features.

### Counters

Counters in RavenDB are pretty simple. They are just a named 64 bits signed value that can be attached to a document. 
At first glance, they don't look like much. But the concept of counting is so pervasive that it turns out that they 
are quite useful in many scenarios. 

Figure 5.2 shows a counter in the Studio. As you can see, this is quite similar to the way you would use this value if
it was embedded inside the document. The only thing we have done so far is just move it aside a bit. 

![A document counter in the Studio](./Ch05/img02.png)

Moving the counter to the side is actually the whole point. Because now we can treat the counter in several special 
ways. To start with, changing the counter does _not_ require us to change the document. This means that when we want
to increment or decrement the value, we don't need to load / modify / store the document. That reduce the cost of 
changing the value of the counter. 

#### Writing counter values

Updating a counter value is cheap, _very_ cheap. This fact allows us to nicely handle many interesting cases. 
Consider the scenario of two users clicking on the download link at the same time. Listing 5.1 has the code that 
will increment the number of downloads for the document.

```{caption="Incrementing the number of downloads of a document" .cs}
using (var session = store.OpenSession())
{
    session.CountersFor("packages/393-A")
    	.Increment("DownloadsCount", delta: 1);
    session.SaveChanges();
}
```

The code in Listing 5.1 has a few interesting implications. First, as usual, a change to counter is part of the session
and has the same transactional guarantees as other operations in RavenDB. You can have a document change and a counter
increment (to the same document or different documents) that will all be part of the same transaction.
Second, concurrent operations on the counter are safe to perform and will simply resolve to the right value after 
taking into account all the operations on that particular counter. Third, we don't need to create our counter ahead
of time. The first operation on a counter on a document will create the counter. This reduce the amount of work you 
have to deal with when working with counters.


> **Counters are natively distributed**
> 
> Counters not only handle concurrent modifications to the counter safely and correctly, they also handle the problem
> of _distributed_ writes. Two clients may update the same counter on the same document on two separate nodes in a 
> RavenDB cluster, and RavenDB will know how to resolve all those writes to get to the right value in the end.
>
> RavenDB uses a data structure called CRDT^[Conflict-free replicated data type] for this purpose, which allow us to merge multiple writes and reach the 
> correct tally without the need for syncronization or complexity on the part of the users. 

These features make RavenDB counters highly suitable for tasks that require high level of concurrency in counting. The 
example of `DownloadsCount` is a good representation of the kind of usage you'll get from counters. Counters are used
for capturing ad impressions, page views and tracking the number of API calls across your system.

> **Decrementing a counter value**
> 
> RavenDB doesn't provide an API call to `Decrement` a value. You can simply pass a negative value to `Increment`
> to reduce the counter value.

#### Reading counter values

After look at writing counter values, let's see how we can read them. In Listing 5.2 you can _read_ counters values.

```{caption="Reading a counter value via the Session API" .cs}
using (var session = store.OpenSession())
{
    long? downloads = session.CountersFor("packages/393-A")
    	.Get("DownloadsCounter");
}
```

The API is fairly simple, all you need to state is what document you are operating on and what counter's value you want
to get. You get the value back as a 64 bits number, and that is pretty much it. Well, almost.

In order to get the counter value, you need to make a remote call to the server. In Chapter 2, we talked about the 
high costs of remote calls and how RavenDB has the notion of Includes specifically to avoid these costs. Counters can
also be included, as you can see in Listing 5.3.

```{caption="Including a counter value during document load to reduce remote calls" .cs}
using (var session = store.OpenSession())
{
	var package = session.Load<Package>(
		"packages/393-A", 
		i => i.IncludeCounter("DownloadsCount")
	);
    long? downloads = session.CountersFor("packages/393-A")
    	.Get("DownloadsCounter");
}
```

The `Get` call in Listing 5.3 will not trigger a remote call to the server. The data has already been been gathered by
the session in the `Load` call, because we explicitly asked for it. The RavenDB Client API has various overloaded to 
get all the counters for a document, a specific counter or a set of them. The end result in all cases is that you can
reduce the number of roundtrips that you have to pay for and gain better overall perfromance.

> **Including counters in queries**
> 
> We have barely talked about queries so far (we'll do so quite extensively in the 3rd part of this book). But as a 
> sneak peak, you can also include counters during queries, like so: 
> 
> `from Packages include counters('DownloadsCount')`

#### Counters metadata and data modeling

Counters are stored outside of the document itself, as we previously explored. However, the document itself does 
contain some information about the counters. More importantly, the document's metadata contains two important
properties relating to counters, as you can see in Figure 5.3.

![Looking at counters metadata in the studio](./Ch05/img03.png)

The first property of interest is the `@flags` property. You can see that in the case of Figure 5.3, its value is 
`HasCounters`. The `@flags` property is used by RavenDB to surface a lot of the internal state of the document and
you can make use of it in your code to make decisions about the document.

The second property of interest here is the `@counters` property. This is a metadata property that holds a list 
of all the counters names that exists on this document. In other words, merely the act of loading a document 
will give you access to all the counter names that this document posseses. If the only thing you use counters for
are for things like download metrics, the `@counters` property isn't particularly interesting. 

There are far more interesting scenarios for using counters, however. To the point where we need to talk about 
data modeling with counters. On initial consideration, data modeling with counters seems... odd. There isn't much
to _do_ with counters. Each counter represent a 64 bits number, which can range between negative 
9,223,372,036,854,775,808 to positive 9,223,372,036,854,775,807. What kind of data modeling do we have in this case?

The data modeling part isn't so much for the values, but for the counters _names_. Consider a scenario where I want
to track downloads not just globally, but also by location. I can use a `DownloadsCount` to track the global number
but also have `Downloads/EU` and `Downloads/USA` as counters and increment them as well, based on the source of the 
download. 

Another good example would be to track the number of requests to a 3rd party service. We may want to keep track not 
just on the number of requests, but also their results. Figure 5.4 shows a simple way to handle this task.

![Tracking request HTTP statuses via counters](./Ch05/img04.png)

The advantage here is that counters are small and efficeint, designed to be used in scenarios that demand high 
throughput. Using them to track high frequency events, and using different counters to track different statuses of 
the event can simplify such tasks greatly.

> **How many counters?**
>
> A document can have any number of counters attached to it. We have tested documents that had hundreds of thousands
> of counters, so there isn't a _hard_ limit. However, you should be aware of practical realities. 
>
> The names of counters on a document are stored in the document metadata. If you have a document that have a _lot_
> of counters, the size of the document metadata might grow to be a significant portion of the document size. That
> is not a desired scenario. Things would still work, but you can do better by splitting the data to multiple 
> physical documents at that point.

You can also use counters in queries, as you can see in Listing 5.4.

```{caption="Getting the values of counters during queries" .sql}
from Services as service
select service.Name, 
	counter(service, "status/500") as Errors
```

We'll cover queries in depth in Part III of this book, so I won't go over these in detail. But you can probably already
see how useful such a feature can be. In this case, you don't need any special API calls, the resulting value is sent
as part of the result set of the query.

> **Consistency properties of counters**
> 
> Counters in RavenDB are resilient to concurrency and distribution issues. You can increment or decrement a counter 
> at the same time on multiple nodes that are wildly separated from one another and RavenDB will gather all the 
> operations on the counter and reconcile them to a single final value. This property of counters is valuable and 
> useful in many scenarios, but it come at a cost.
> 
> RavenDB gurantees that writes to counters are ACID. That is, if you make a write to a counter, we'll accept the write
> and persist it. Even in the precense of failure. If the counter write is part of a larger transaction (such as 
> modifying multiple counters and / or documents), we also gurantee that the whole transaction (including the counter 
> writes) is committed or rolled back as a whole. 
> 
> However, the counter value itself is using an eventual consistency mode. This is because even though you might have
> incremented the value in a transaction (and gotten the modified value back), you can't be sure that the value hasn't
> also been modified in another node. Eventually that other write will reach all the nodes in the cluster, but certain
> failure modes can cause it to take quite a while. 
> 
> If you need to _rely_ on the counter value for operational reasons, you might want to consider either a property 
> inside the document or use a compare exchange value, as we discussed in Chapter 2. Most usages of counters in 
> RavenDB are resilient to the eventual consistency inherint to using them.

#### Deleting counters

Counters can be deleted using the Studio or the RavenDB Client API, as you can see in Listing 5.5. 

```{caption="Including a counter value during document load to reduce remote calls" .cs}
using (var session = store.OpenSession())
{
	var package = session.Load<Package>("packages/393-A");
    session.CountersFor("packages/393-A").Delete("DownloadsCounter");
    session.SaveChanges();
}
```

A counter deletion will be sent to the server when `SaveChanges` is called, as expected. One thing to note about the 
act of deleting a counter. Like all other operations on counters, we need to consider what will happen when there are
concurrent operations. One for deleting a counter and another to increment it. In this case, a lot depend on the actual
order of operations.

If the increment operation runs first, the counter will be deleted. However, if the delete happens to win the race, the
counter will be deleted, and then recreated by the increment operation. In a distributed setting, a delete on one node
and an update on another node will always resolve in favor of the update. 

If you need to delete counters, the usual way to do so it to ensure that in your application,
you aren't going to also try to write to them at the same time. 
But for the most part, counter deletions are relatively rare operation for most applications. 

It is common to want to _reset_ a counter to zero, however. For example, if you are tracking services' status codes, 
you might want to reset the counter whenever a new version of the service has been deployed. This is usually better
to handle explicitly, as you can see in Listing 5.6.

```{caption="Resetting a counter value" .cs}
using (var session = store.OpenSession())
{
	var serviceCounters = session.CountersFor("services/2338-C");
	long failures = serviceCounters.Get("status/500") ?? 0;
    serviceCounters.Increment("status/500", -failures);
    session.SaveChanges();
}
```

In Listing 5.6, we reset the counter value to zero by getting the value and decrementing the current value. Other 
operations that might be modifying the counter at the same time can run concurrently without any issue.

Alternatively, you might have a different counter for each version of the service. So when you deploy a new version
your code will start incrementing the `status/3.190527.11/500` counter and no longer modify the `status/3.190521/500`
counter, which an now be safely deleted. This is a simple example of how you can ensure that there won't be concurrent
delete and increment operations on a counter.

#### Deleting a document with counters

A counter is attached to a document, and the deletion of a document will delete all the counters of a document. This 
might seems obvious, but I wanted to call it out explicitly. Deleting a document and then creating a new document
with the same name isn't going to restore the old counters.

In the same manner, an increment operation on a counter will create the counter if it doesn't already exists. However,
an increment operation on a counter of a _document_ that doesn't exists will fail. Counters can be created on the fly
but the documents that they belong to must already exist beforehand.

#### Patching counters

In Chapter 4, we talked about patching documents. The patching feature allow you to run a script that will run at 
the server side and modify documents based on your own logic. Patch operations also allow you to modify counters and
their values. 

For example, let's assume that we have an existing document with some properties that I want to turn into counters.
The code in Listing 5.7 shows how this can be done.

```{caption="Creating a counter from a document property" .cs}
using (var session = store.OpenSession())
{
	var script = @"
if (this.DownloadCount !== undefined){
	incrementCounter(this, "DownloadCount", 
		this.DownloadCount);
	delete this.DownloadCount;
}";
	session.Advanced.Defer(new PatchCommandData(
	    id: "packages/393-A",
	    changeVector: null,
	    patch: new PatchRequest
	    {
	        Script = script
	    }, patchIfMissing: null));
    session.SaveChanges();
}
```

The only items of interest in the patch in Listing 5.7 is the call to `incrementCounter`, which will create the counter
if it doesn't already exists. The rest of the code is identical to the patch operations that we already covered in 
Chapter 4. 

The patch API provides a few methods to work with counters:

* `incrementCounter(document, counterName, value);`
* `counter(document, counterName);`
* `deleteCounter(document, counterName);`

If you want to get the list of counters on a document, you can use the metadata property `@counters` to get the list
of all the counter names for a document.

You can use these methods and the `@counters` metadata property to programatically modify documents and their counters
freely. 

