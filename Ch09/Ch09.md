
## Querying with RavenDB

[Querying]:(#queries)

Queries in RavenDB are using a SQL-like language called^[Aren't you surprised?] RavenDB Query Language, henceforth known as RQL^[Pronounced
Rachel, like my wife and because it is funny.]. 

You already run into the RavenDB Query Language before, even if I didn't explicitly called it out as such, when using subscriptions. Both
subscriptions and queries are using RQL, although there are a few differences between the supported options between the two. The idea with 
RQL is to expose directly the inner working of the RavenDB query pipeline in a way that isn't going to overwhelme users.

Therefor, we'll first take a brief look at how RavenDB is actually processing queries, then get started on actually _running_ queries. We'll
start from the simplest scenarios and explore all the nooks and cranies of what you can do with RavenDB queries.
And the first place to is the query optimizer.

### The query optimizer

When a RavenDB instance gets a query, the very first thing that happens is that the query optimizer analyzes it. The role of the query
optimizier is to determine what indexes should be used by this particular query. This is pretty much par the course for databases. However,
with RavenDB, there are two types of queries. You may have a dynamic query, such as `from Orders where ...`, which give the query optimizer
full freedom with regards to which index that query will use. Alternatively, a query can specify a specific index to be used, such as: 
`from index "Orders/ByCompany" where ...`, which instructs RavenDB to use the `Orders/ByCompany` index.

> **Queries are always going to use an index**
> 
> You might have noticed that we are talking about index selection for the query as primarily the _selection_ of the index to use. 
> However, you might be familiar with query plans that couldn't find an appropriate index and fell back into querying using a full
> scan. 
>
> RavenDB doesn't include support for full scans, by design. Queries in RavenDB are _fast_, and they will _always_ use an index. Using
> full scans is an excellent method when the size of your data is very small, but as it starts to grow, you are going to experience
> ever-increasing query times. In contrast, RavenDB queries are always using an index and can return results with the same speed regardless
> of the size of the data.

What happens when the query optimizer is unable to find an index that can satistfy this query? Instead of scanning all of the documents,
inspecting each one in turn and including it in the query or discarding it as an unsuccessful match, the query optimizer go in a different
route. It will _create_ an index for this query, on the fly. 

If you are familiar with relational database, you might want to take a deep breath and watch your pulse. Adding an index to a relational
database in production is fraught with danger, it is _possible_, but it needs to be handled very carefully. In contrast, RavenDB indexes
will not lock the data and they are designed so they will not consume all the system resources while they running. This means that adding
a new index isn't the world shattering spectacle that you might used to. RavenDB has gotten it to be such routine event that we let the 
query optimizer run it on its own, as needed. 

Now, creating an index per query is going to result in quite a few indexes in your database, which is still not that good an idea. It's a 
good thing that the query optimizer doesn't do that. Instead, when it gets a query, it analyzes it and see what index can answer this query
and if there isn't one, it creates an index that can answer this query and _all previous queries_ on that collection.

Indexing in RavenDB is a background operation, which means that the new query is going to be waiting for the index to complete indexing
(or a timeout), but at the same time, any existing queries will proceed normally using the existing indexes. When the new index has caught
up, RavenDB will cleanup all the old indexes that are now superceded by the new one. 

In short, over time the query optimizier will analyze the set of queries that you are making to your database and will generate the optimal
set of indexes to answer those queries. Changes in your queries will also trigger a change in the indexes on your database, as it adjusts to
the new requirements. 
Practically speaking, this means that a new version of your application being deployed will not invalidate all the hard work the DBA put in 
to make sure that all the queries are optimized. 

> **Learning on the side**
>
> You don't have to do the new version adjustment on the production systems. You can run the new version of your system on a test instance
> of RavenDB and let it learn what kind of queries are going to be performed. Then, you can export that knowledge into the production 
> system during quite time, so by the time the new system is actually deployed, the database is already familiar and ready for the new
> workload.

#### What queries can do

The obvious result of RavenDB using an index for all queries is that queries are _extremely_ fast. Another aspect of this decision is that 
RavenDB only support query operations that _can_ be answered quickly using an index. For example, consider the following query:

```
from Customers where Address.City = 'London'
```

This kind of query is very easy to answer using an index, because we can seek to the `London` token and get all the documents that are a match
to that. However, a query such as this is not permitted:

```
from Customers where years(now() - Birthday) > 18
```

This query would require us to perform computation during the query, forcing us to do a full scan of the results and evaluate each one in turn. 
That isn't a good idea if you want fast queries, and RavenDB has no support for that. You can re-write the previous query to efficently use the
index:

`from Customers where Birthday < $eighteenYearsAgo`

The `$eighteenYearsAgo` variable would be set for the proper time and that would allow the database to find the results by merely seeking in the 
index and then returning all the results smaller then the given date. That is very efficient and the proper way to run such queries. 
In general, you can usually do a straightforward translation between queries that require computations and queries that do not, as above. Sometimes
you can't just modify the query, and you need to tell RavenDB that it needs to do some computation during the indexing process. We'll see how that
can be done in the chapter about ["Static Indexes"](#static-indexes).

Queries can also use more then a single field, for example:

`from Customers where Address.City = 'London' and Birthday < $eighteenYearsAgo`



> **RavenDB indexes aren't your typical B+Tree**
>
> 


> ** Deep paging is discouraged **


#### Aggregation queries

#### Exact matches

#### Full text search

#### Lucene

#### Spatial queries 

#### Recursive map/reduce


#### Suggetsions

#### Side by side