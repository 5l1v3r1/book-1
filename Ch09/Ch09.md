
## Querying in RavenDB

[Querying in RavenDB]:(#query-engine)

Queries in RavenDB are using a SQL-like language called^[Aren't you surprised?] RavenDB Query Language, henceforth known as RQL^[Pronounced
Rachel, like my wife,  and because it is funny.]. 

You already run into the RavenDB Query Language before, even if I didn't explicitly called it out as such, when using subscriptions. Both
subscriptions and queries are using RQL, although there are a few differences between the supported options between the two. The idea with 
RQL is to expose directly the inner working of the RavenDB query pipeline in a way that isn't going to overwhelme users.

If you are interested in a simple listing of the query capabilities and how to do certain queries, head over to the online documentation, where
all of that information is found. I find it incredibly boring to go through that stuff, so we are going to through the same material, but do so
in a way that will give you insight not into just how to query RavenDB, but what RavenDB actually need to do to answer the query.

> **Where is the code?**
>
> This entire chapter is going to focus on solely the query behavior of RavenDB, as such, we'll be working in the studio, generating 
> queries and looking at documents. We'll look at code to consume such queries from the client API later in later chpaters.

Therefor, we'll first take a brief look at how RavenDB is actually processing queries, then get started on actually _running_ queries. We'll
start from the simplest scenarios and explore all the nooks and cranies of what you can do with RavenDB queries.
And the first place to is the query optimizer.

### The query optimizer

When a RavenDB instance gets a query, the very first thing that happens is that the query optimizer analyzes it. The role of the query
optimizier is to determine what indexes should be used by this particular query. This is pretty much par the course for databases. However,
with RavenDB, there are two types of queries. You may have a dynamic query, such as `from Orders where ...`, which give the query optimizer
full freedom with regards to which index that query will use. Alternatively, a query can specify a specific index to be used, such as: 
`from index "Orders/ByCompany" where ...`, which instructs RavenDB to use the `Orders/ByCompany` index.

> **Queries are always going to use an index**
> 
> You might have noticed that we are talking about index selection for the query as primarily the _selection_ of the index to use. 
> However, you might be familiar with query plans that couldn't find an appropriate index and fell back into querying using a full
> scan. 
>
> RavenDB doesn't include support for full scans, by design. Queries in RavenDB are _fast_, and they will _always_ use an index. Using
> full scans is an excellent method when the size of your data is very small, but as it starts to grow, you are going to experience
> ever-increasing query times. In contrast, RavenDB queries are always using an index and can return results with the same speed regardless
> of the size of the data.

What happens when the query optimizer is unable to find an index that can satistfy this query? Instead of scanning all of the documents,
inspecting each one in turn and including it in the query or discarding it as an unsuccessful match, the query optimizer go in a different
route. It will _create_ an index for this query, on the fly. 

If you are familiar with relational database, you might want to take a deep breath and watch your pulse. Adding an index to a relational
database in production is fraught with danger, it is _possible_, but it needs to be handled very carefully. In contrast, RavenDB indexes
will not lock the data and they are designed so they will not consume all the system resources while they running. This means that adding
a new index isn't the world shattering spectacle that you might used to. RavenDB has gotten it to be such routine event that we let the 
query optimizer run it on its own, as needed. 

Now, creating an index per query is going to result in quite a few indexes in your database, which is still not that good an idea. It's a 
good thing that the query optimizer doesn't do that. Instead, when it gets a query, it analyzes it and see what index can answer this query
and if there isn't one, it creates an index that can answer this query and _all previous queries_ on that collection.

Indexing in RavenDB is a background operation, which means that the new query is going to be waiting for the index to complete indexing
(or a timeout), but at the same time, any existing queries will proceed normally using the existing indexes. When the new index has caught
up, RavenDB will cleanup all the old indexes that are now superceded by the new one. 

In short, over time the query optimizier will analyze the set of queries that you are making to your database and will generate the optimal
set of indexes to answer those queries. Changes in your queries will also trigger a change in the indexes on your database, as it adjusts to
the new requirements. 
Practically speaking, this means that a new version of your application being deployed will not invalidate all the hard work the DBA put in 
to make sure that all the queries are optimized. 

> **Learning on the side**
>
> You don't have to do the new version adjustment on the production systems. You can run the new version of your system on a test instance
> of RavenDB and let it learn what kind of queries are going to be performed. Then, you can export that knowledge into the production 
> system during quite time, so by the time the new system is actually deployed, the database is already familiar and ready for the new
> workload.

Lets get started with actual queries. In the studio, create a new database and then go to `Settings` and then to `Create Sample Data` and 
click on the big `Create` button. This will create a sample database (the Northwind online shop data) that we can query.
Now, go to `Indexes` and then `List of Indexes`, you'll note that there are three indexes that are defined in the sample database. 
We are going to switch back and forth between `List of Indexes` and `Query` quite often for the next part, so you might want to open the 
`Query` in a separate tab and switch between the two. 

Go to 'Query' and issue the following query:

```{.sql}
from Employees
```

You will get a list of employees in the studio, which you can inspect. You can view the full document JSON by clicking on the eye icon.
If you'll look at the list of indexes, you'll see that no new index was created, even though there are no existing indexes on the 
`Employees` collection. This is because there isn't any filtering used in this query, so the query optimizer can just use the raw 
collection documents as the source for this query, no need to do any work. 

The same is true for querying by document id or ids, as you can see in Listing 9.1. 
 The query optimizer doesn't need any index to handle these queries and can answer them directly. 


```{caption="Querying based on the document id will not create an index" .sql}
from Employees 
where id() = 'employees/1'

from Employees
where id() in ('employees/1','employees/2')
``` 

However, what happens when we start querying on the data itself? You can see the result in Figure 9.1. In particular, you'll note that 
RavenDB reports that this query used the `Auto/Employees/ByFirstName` index. 

![RQL query for employees named Andrew](./Ch09/img01.png)

Switching over to the indexes listing will show you that indeed, a new auto index was created for us to answer these kinds of queries. 
Let us test this further and query by _last_ name now, using: 

```{.sql}
from Employees where LastName = 'Fuller'
````

You can see the results of running this query in Figure 9.2. 

![The merged auto index can answer queries by first name or last name, or both](./Ch09/img02.png)

The query optimizer has detected that there is no index for this query, looked at the previous history of queries on the `Employees`
collection and create an index that can satisfy all such queries in the future. If you were fast enough, you might have managed to 
catch the `Auto/Employees/ByFirstName` index disappearing as it was superceded by the new index. 

Now that you have experienced the query optimizer first hand, let us give it a bit of workout, shall we? Let us see what kind of queries
we can do with RavenDB.

### How queries work?

Requiring that all queries will always use an index has a few interesting results. It means that it queries tend to be _really_ fast, because
there is always an index backing the query and we don't need to go through full scans.  Another aspect of this decision is that 
	RavenDB only support query operations that _can_ be answered quickly using an index. For example, consider the following query:

```{.sql}
from Employees where FirstName = 'Andrew'
```

This kind of query is very easy to answer using an index that has indexed the `FirstName` field, because we can find the `Andrew` 
entry and get all the documents that has this value. However, a query like the following is not permitted:

```{.sql}
from Employees where years(now() - Birthday) > 18
```

This query would require RavenDB to perform computation during the query, forcing us to do a full scan of the results and evaluate each one in turn. 
That isn't a good idea if you want fast queries, and RavenDB simply does not allow these type of queries. You can re-write the previous query to
efficently use the index by slightly modifying what you are searching for:

```{.sql}
from Employees where Birthday < $eighteenYearsAgo
```

The `$eighteenYearsAgo` variable would be set for the proper time and that would allow the database to find the results by merely seeking in the 
index and then returning all the results smaller then the given date. That is cheap to do and the proper way to run such queries. 
In general, you can usually do a straightforward translation between queries that require computations and queries that do not, as above. Sometimes
you can't just modify the query, and you need to tell RavenDB that it needs to do some computation during the indexing process. We'll see how that
can be done in the chapter about ["Static Indexes"](#static-indexes).

Queries can also use more then a single field, as you can see in Listing 9.2.

```{caption="Querying over several fields at the same time" .sql}
from Employees 
where 	(FirstName = 'Andrew' or LastName = 'Callahan') 
and 	Address.Country = 'USA'
```

Using the sample data set, this should give two results, as shown in Figure 9.3, where you can also see some of the options available to inspect
the index behavior. Viewing the index definition will tell you what is indexed and how, and the indexing performance statistics
will give you all the details about the costs of indexing, broken down by step and action. This is very important if you are trying to unerstand
what is consuming system resources, but that will be covered in the next part of the book, discussing 
["Prouction Deployments'](#production-deployments) and how to monitor and manage RavenDB in production. 

![Available operations for inspect index state](./Ch09/img03.png)

Far more important for us at this point is the `View index terms` page, which can expose the internal structure of the index to you. This is very
helpful when you need to understand how RavenDB is processing a query. 
If you'll click on that link, you'll be taken to the index terms page, where you'll see the index fields. Clicking on this will show you what was
actually indexed, this is shown in Figure 9.4.

![The indexed terms for the various fields in the index](./Ch09/img04.png)

Why is this so important? Even though Figure 9.4 doesn't show all the values, it is enough to explain how RavenDB is actually going to process 
the query. The first thing to understand is that RavenDB is going to treat each field in the query separately. The query is broken into three
clauses, and you can see the result of each in Table 9.1.

|           Query           |                    Results                   |
|---------------------------|----------------------------------------------|
| `FirstName = 'Andrew'`    |  `employees/2`                               |
|							|											   |
| `LastName = 'Callahan'`   |  `employees/8`                               |
|							|											   |
| `Address.Country = 'USA'` |  `employees/1`, `employees/2`, `employees/3`,|
|                           |  `employees/4`, `employees/8`                |


Table: Query clauses and their individual results

The reason that RavenDB deals with each field separately is that the way we store the indexed data for each field independently. This allows us
a lot more freedom at query time, at expense of having to do a bit more work at query time.

> **RavenDB's indexes aren't single purpose**
>
> If you are familiar with common indexing techniques in databases, you know that there is a _major_ importance to
> the order of the fields in the index. The simplest example I can think of is the phone book, which is basically an index to search 
> for people by "LastName, FirstName".
>
> If your search has both the last name and the first name, then the phone book is very easy to search. If you need to search just by the 
> last name, the phone book is still very useful.
> If you only have the first name, however, the phone book is basically useless since you'll have to go through the entire thing
> to find any results. 
>
> In the same way, indexes that mash all the fields together into a single key and then allow searching on the result are very efficent in
> answering that particular kind of query, but cannot really be used for anything else. With RavenDB, we index each field independently and
> merge the results at query time. That means that our indexes can be used in a more versatile manner and are able to answer a much wider
> range of queries at a small cost of additional work to merge them at query time.

To answer the the query in Listing 9.2 RavenDB will find the match documents for each of the clauses, as shown in Table 9.1. At that point, 
we can use set operations to find the final result of the query. We have an `OR` between the `FirstName` and `LastName` query, so the result
of both clauses is the union of their results. In other words, the answer to `FirstName = 'Andrew' or LastName = 'Callahan'` is (`employees/2`,
`employees/8`). 

The next step in the query is to evaluate the `and` with the `Address.Country = 'USA'` clause. Because we have an `and` here, we'll use set 
intersection, instead of a union (which we use for `or`). The result of that will be (`employees/2`,`employees/8`), which appear in both 
sides of the `and`. Similarly, `and not` is using set difference.

The end result is that a single index in RavenDB is able to be used far more types of queries then a similar index in a relational database, at 
the cost of doing set operations on queries that have multiple clauses. Since set operations are very cheap and have been carefully optimized,
that is a pretty good tradeoff to make. 

### Operations in queries

Queries in RavenDB do not allow computation, I mentioned, and we saw some pretty simple queries using equality and range queries at a
glance. In this section, I want to talk about what kind of queries you can make in RavenDB and dig a bit into how they are actually implemented.

The stadnard query operations you would expect are here, of course, as well as a few more, as shown in Table 9.2.

|   Operation   |             Operators / Methods                       |
|---------------|-------------------------------------------------------|
| Equality      | `=`, `==`, `!=`, `<>`, `IN`, `ALL IN`                 |
| Range queries | `>`, `<`, `>=`, `<=`, `BETWEEN`                       |
| Text search   | `Exact`, `StartsWith`, `EndsWith`, `Search`           |
| Aggregation   | `Count`, `Sum`, `Avg`                                 |
| Spatial       | `Contains`, `Within`, `Intersects`                    |
| Other         | `Exists`, `Lucene`, `Boost`                           |


Table: Operators and methods that can be used in queries

#### Equality comprisons

The first and most obvious ones are equality comparisons ('=' or '=='). As you can imagine, these are easiest one for us to find since we can 
just check the index for the value we compare against. It is important to note that we only allow comparison of fields against values or 
parameters. This kind of query is fine: `where FirstName = 'Andrew'` as well as this: `where FirstName = $name`. However, this is not allowed:
`where FirstName = LastName`. 

These type of queries fall under the computation during query and cannot be expressed directly in RQL. You don't have to worry, you can still 
make such queries, but you need to use a static index to do that, which we'll discuss in the ["Static Indexes"](#static-indexes) chapter 
dedicated to just that topic.

Inequality queries are more interesting. Remember that RavenDB use set operations to compute query results. A query such as 
`where FirstName != 'Andrew'` is actuall translated into: `where exists(FirstName) and not FirstName = 'Andrew'`. In other words, find all the
documents that have a `FirstName` field and exclude all the documents where that `FirstName` is set to `'Andrew'`.

There is also `IN`, which can be used in queries such as `where Address.City IN ('London', 'New York')` which a shorter way to write 
`where Address.City = 'London' or Address.City = 'New York'`. However, an `IN` also allow you send an array argument and write the query simply
as `where Address.City IN ($cities)`, which is quite nice. The `ALL IN`, on the other hand, is much stranger beast. Quite simply, if we would use
`ALL IN` instead of `IN`, the query it would match would be `where Address.City = 'London' and Address.City = 'New York'`. In other words, it will
use an `and` instead of an `or`.
This is very strange and seemingly useless feature, how can a value be equal to multiple different values?

The answer is that _a_ value cannot, but an array most certainly can. Consider the document shown in Figure 9.5, showing a document that has an
array of Territories. We can use `ALL IN` in our query to find all the regions that have multiple territories in them, like so:
`from Regions where Territories[].Name ALL IN ('Wilton', 'Neward')`

![The `regions/1` document contains an array of `Territories`](./Ch09/img05.png)

This query shows two new features, first, we have the `ALL IN` that shows how we can match multiple values against an array. A very common usage
of this feature is to allow you to filter documents by tags, the user can select what tags they are interested in, and you use `ALL IN` to find
all the documents that match the requested tags.

The second new feature is the usage of the `Territories[].Name` path and in particular the use of `[]` in the path. Withing RQL, the use of the 
`[]` suffix in a property indicates that this is an array, and that the rest of the expression is nested into the values of the array. This is 
useful both in the `where` clause and when doing projections doing `select`, as we'll see later in this chapter. 

#### Range queries

For range queries, things like `>` or `<=` are fairly self explanatory, with `BETWEEN` as a nicer mechanism for actually querying over a specific
range. `BETWEEN` is inclusive on the low and high ends. In other words, consider the query in Listing 9.3. 

```{caption="Querying date ranges using BETWEEN" .sql}
from Employees 
where year(HiredAt) BETWEEN 1992 AND 1994
```

The results of the query in Listing 9.3 are going to include employees hired in 1992, 1993 and 1994. We could have also written the same query 
with string matches, as shown in Listing 9.4. 

```{caption="Querying date ranges using BETWEEN with string prefixes" .sql}
from Employees 
where HiredAt BETWEEN `1992` AND `1995`
```

The query in Listing 9.4 is going to also match all the employees hired in 1992, 1993 and 1994, but why? This is because of a minor trick that 
we use here. The actual date format used by RavenDB is `ISO 8601`, so techically speaking, the query in Listing 9.4 is supposed to look like: 
`HiredAt BETWEEN '1992-01-01T00:00:00.0000000' AND '1995-01-01T00:00:00.0000000'`. In practice, RavenDB consider such queries as string operations
and allow us to do the `BETWEEN` operation using just the prefix.

This is because of the way RavenDB will process range queries. For non numeric values, range queries are using lexical comparisons, which means 
that just specifying the prefix is enough for us to get the required results. This is the reason RavenDB uses ISO 8601 dates,as they sort lexically,
which makes things easier all around at querying time.

For numeric values, we use the actual number, of course. That, too, however, has some details that you should be familiar with. When indexing a 
numeric value, RavenDB will actually index it multiple times. Once as a string, which allow it to take part in lexical comparisons and once as 
a numeric value. Actually, it is even more complex then that. The problem is that when we deal with computers, the answer of what is a number 
is actually a bit complex.

> **Range queries on mixed numeric types**
>
> A interesting pitfall can happen if you are using the wrong numeric type when querying. For example consider the `products/68` document
> in the sample data set. It's `PricePerUnit` is set to `12.5`, yet if I'm querying for: `from Products where PricePerUnit > 12` RavenDB
> find no results.
>
> The problem in this case is that we are using an `int64` with a range query, but that `PricePerUnit` is actually a `double`. In this case,
> RavenDB indexed the `PricePerUnit` field during indexing as both `double` and `int64`. However, when indexing the `12.5` value as `int64`
> the value was naturally truncated to `12`, and the query clearly states that we want to search for values _greater than_ `12`, so we skip
> it.
>
> A small change to the query, `from Products where PricePerUnit > 12.0`, will fix this issue. 

RavenDB supports two numeric types, 64bits integer and IEEE 754 double-precision floating-point. When RavenDB index a numeric field, we actually
index it three times. Once as a `string`, once as a `double` and once as `int64` and allow you to query over all of them, without really caring
what you use to find your results.

#### Full text searching

So far we looked at querying the data exactly as it is. But what would happen if we run the following query?

```
from Employees where FirstName = 'ANDREW'
```

Unlike the previous times we run this query, now the `FirstName` is using a different case then the value of the field in the document, so what do
you think the result would be? The answer is that we would get the result, as you probably expected. Queries that require you to match case have their
place but they tend to be quite frustrating for the users, so RavenDB defaults to using case insensitive matching in queries.

On the other hand, you could have written the query as shown in Listing 9.5 and find only the results that match the value and the casing used.

```{caption="Case sensitive queries using the exact() method" .sql}
from Employees 
where exact(FirstName = 'Andrew')
```

Within the scope of the `exact`, you'll find that all comparisons are using case sensitive matches. This can be useful if you are comparing 
BASE64 encoded strings that are case sensitive, but is rarely useful otherwise.

By default queries in RavenDB are case insensitive, which helps a lot, but what happens when we need more than a match? We can use the 
`StartsWith` and `EndsWith` to deal with such queries. Consider the following query: 

```
from Employees where StartsWith(FirstName, 'An')
```

This will find all the employees who name starts with `'An'`. The same can be done with `where EndsWith(LastName, 'er')` for the other side.

Note that queries using `StartsWith` can use the index efficiently to perform prefix search, but `EndsWith` is something that will cause 
RavenDB to perform a full index scan and as such isn't recommended for general use. If you really need this feature, you can use a static index
to index the reverse of the value you are searching on and use `StartsWith`, which will be much faster.

Of more interest for us is the ability to perform full text searches on the data. Full text search allow to search for a particular term (or
terms) in a set of documents and find results without having an exact match. For example, examine Figure 9.6, where we are searching for a store
that has the word 'stop' in its name.

![Full text search queries on companies' name](./Ch09/img06.png)

The result of this search this query is that we are able to find two results. What makes this interesting is that unlike the `EndsWith` case, 
RavenDB didn't have to go through the entire result set. Let us go into the terms for the `Auto/Companies/BySearch(Name)` index and see how this
works.

We have two fields indexed in this index, the first is `Name` and if you click on that you'll see 91 results, one for each of the companies that
we have in the sample data set. The other one is named `search(Name)` and is far more interesting. Clicking on it shows 223 results, and the 
terms that are indexed are _not_ the names of the companies. Figure 9.7 shows a comparison of the two fields. 

![List of indexed terms for `Name` and `search(Name)` fields](./Ch09/img07.png)

When we do a simple equality query, such as `where Name = 'Consolidated Holdings"`, it is very easy to understand how the database is going to 
execute this query. The `Name` fields terms are sorted, and we can do a binary search on the data to find all the documents whose name is equal
to `"Consolidated Holdings"`. But what happens when we query using `search(Name)`?

The answer is in the way RavenDB indexes the data. Instead of indexing `Name` field as a single value RavenDB will break it into separate 
tokens, which you can see in Figure 9.7. This means that we can search for individual words inside the terms. The way it works is that we
are going to search not the full field, but the indexed tokens and from there to get to the matching documents.

> **Full text search is a world unto itself**
>
> I'm intentionally not going too deep into full text search and how it works. If you are interested in learning more about full text search,
> and I personally find the topic facinsating, I recommend reading 
> [Lucene in Action](https://www.amazon.com/Lucene-Action-Second-Covers-Apache/dp/1933988177) and 
> [Managing Gigabytes](https://www.amazon.com/Managing-Gigabytes-Compressing-Multimedia-Information/dp/1558605703). They are both good books 
> that can give you insight into how full text search works. Lucene in Action will give you a practical overview while Managing Gigabytes is
> an older (it was written about twenty years ago), but more digestable book for handling the theory of full text search. That isn't required
> to understand how to use RavenDB, though.

Most of the work was already done during the indexing process, so queries tend to be very fast. Full text search in RavenDB also allow us to do
some really things. For example, consider the following query: 

```
from Companies where search(Address, "London Sweden")
```

The `Address` property on the `Companies` documents isn't a simple string, it is actually a nested object, but RavenDB has no problems indexing
the entire object. The results of this query includes companies that reside in the city of London and the country Sweden. This is a powerful 
option to have which allows you to search across complex objects easily.

Something to note when looking at the results of this query is the order in which the results have returned from the query. In order to better
see that, we'll use a `select` clause (we'll talk about it more later in this chapter) to fetch just the information we are interested in. See
Listing 9.6 for the full query.

```{caption="Full text search and projection on the relevant fields" .sql}
from Companies 
where search(Address, "London Sweden")
select Address.City, Address.Country
```

The results of the query in Listing 9.6 are really interesting. First, we have six companies that are located in London and then two which are 
based in Sweden. This is interesting because this isn't accidental. RavenDB ranks the results based on their quality, a match on London would 
rank higher then a match on Sweden, since London was the first in the query (switch them around and see the change in the results). 
This means that the more relevant results are nearer the top and more likely to be seen by an interested user.

#### Lucene

RavenDB uses the Apache Lucene library for indexing, which means that there is quite a bit of power packed behind these indexes. Lucene is a full text 
search library that can support complex queries and is considered to be the de facto leader in the area of search and indexing. 

Unfortunately, Lucene is also temperamental, tricky to get quite right and... not known for its ease of use or robustness in production systems. 
To be frank, this library is amazing and whenever you run into search _anywhere_ it would be a safe bet to assume that Lucene is the core engine
behind it. For that reasons, it is common to consume Lucene using a solution that wraps and handle all of the details of managing Lucene (such as
Apache Solr or ElasticSearch).

In the case of RavenDB, a major factor in our Lucene usage is that we are able to have our storage engine (Voron) to provide transactional guarantees 
for Lucene, which means that our Lucene indexes are also properly ACID and safe from corruption, without giving up on the expected performnace. In general, 
all the operational
aspects of running Lucene indexes are handled for you and shouldn't really concern you. We'll discuss Lucene in more depth in the
["Static Indexes"](#static-indexes) chapter but for now I want to focus on the querying capabilities that Lucene provides.

If you are familiar with Lucene, you might have noticed that RQL is nothing like the Lucene query syntax. This is intentional, Lucene queries only 
allow to find matches, with all else, like sorting of projections is handled via code. This make it a great tool for finding information, but a poor one for
actual queries. That said, you can use an RQL query and use the `Lucene` method as an escape hatch to send queries directly to Lucene.

The following query is using the `Lucene` method do to query using wildcards, which isn't supported by RavenDB. 

```
from Companies where Lucene (ExternalId, "AL?K?") 
```

There are some scenarios where this is required, particularly if you are upgrading an application from older versions of RavenDB, which exposed the 
Lucene syntax directly to users, but in general, RQL should sufficent and is the recommended approach to use. Typically  you would only use
`Lucene` on static indexes where you have control over what fields are indexed.

> **Builtin methods in RQL are case insensitive**
>
> Builtin methods (such as the ones listed in Table 9.2) are case insensitive, and you can call `where startsWith(Name, 'And')` or
> `where StartsWith(Name, 'And')` without issue. Note that _field_ names are case sensitive, though. 

Most of what you can do with `Lucene` is available natives in RQL. For example, we can use the `Boost()` method to change the way queries are evaluated.
Consider the query in Listing 9.7, which express a fairly complex conditional and ranking requirement using `Boost()`

```{caption="Using boost to modify query results ranking" .sql}
from Companies
where Boost(Address.City = 'London', 3) or
      Boost(Address.City = 'Paris', 2) or
      Address.Country IN ('Germany', 'Sweden')

```

The query in Listing 9.7 will select companies based in London, Paris or anywhere in Germany or Sweden. The effect of `Boost()` on the results is that a 
a document matching on London would be give a boost factor in the ranking. This means that the query in Listing 9.6 will first get results for London, then
Paris and then Germany and Sweden. 

This many be silly, but there are many search scenarios where this can be a crucial feature. Consider searching on messages, a match on the  `Subject`
field is more important than matches on the `Body` field, but we want to get results from both.

An interesting issue with boosting is that it isn't quite as obvious as you may think. Consider the query in Listing 9.6, if we change the last clause to
be `Address.Country IN ('Germany', 'France')` we'll start getting Parisian companies first, even though the boost on London based companies is higher. 
The reason for that is that the Parisian companies will have two matches to their names (both Paris and France) while the London companies will only have
one, so they are considered higher quality and ranked first. 

> **Exposing the raw scoree**
>
> The query result also include the `@index-score` metadata property that expose the scoring of each result. You can inspect this to figure out why the 
> final sort order of a query is the way it is. 

We could adjust that by increasing the boost factor for the London based companies, but in more complex scenarios it can be hard to figure out the 
appropriate ratios. In practice, when using such techniques, we aren't usually too concerned with absolute ordering, the expected consumer of these sort
of queries is the end user, which can scan and make sense of the information as long as the ranking more or less make sense.

### Projecting results

We looked into how to filter the results of the query, but so far we always pulled the full document back from the server. In many cases, this is what
you want to do. In the ["Document Modelig"](#modeling) chpater we spent a lot discussion how you should think about documents, and one of trifecta of
document modeling (cohesive, coherent and isolated) is the notion that a document is cohesive. From modeling perspective, it doesn't usually make sense 
to just grab some pieces of data from a document without having it all there.

At least, it doesn't make sense until you realize that you often need to _display_ the data to the user, you often need to pick and choose what will be 
shown. For example, while an order without its order lines isn't really meaningful in a business sense, to the user, knowing that an order was made on 
Dec 17th is probably enough to recall that they had to get expediated shipping on their last minute holidays shopping to get it in time. 

In this section, we are going to take documents aparts and then mash them together. In almost all cases, projections query are used for either subscriptions
or for feeding the data into some sort of a user interface. If you need to actually _work_ with the data, it is generally better to get the full document
from the server and use that. It is also important to remember that on the client side, projections are _not_ tracked by the session and modifications to 
a projection will not modify the document when `SaveChanges` is called.

The simplest query projection can be seen in Listing 9.8.

```{caption="Projecting only some parts of the document" .sql}
from Companies
select Name, Address.City, Address.Country as Country
```

The query in Listing 9.8 will produce the results with three fields, Name, City and Country. A single projection form this query is shown in Figure 9.8.
This query demonstrate simple projection of fields and the use of aliases. You can see that we didn't specify an alias for the `Address.City` field and that
full name was used in the resulting projection. On the other hand, the use of aliases, as we can see in the case of `Country` allow us to contorl what 
would be the name of the field that would be returned.

![A single document result in a projection query](./Ch09/img08.png)

In the case of the query in Listing 9.8 we are only projecting simple fields, but RQL is capable of much more. Listing 9.9 has a more complex projection 
example, projecting both objects and arrays.

```{caption="Projecting arrays and objects using RQL" .sql}
from Orders
select ShipTo, Lines[].ProductName as Products
```

A single projection from the results of the query in Listing 9.8 is shown in Figure 9.9. This query is a lot more fun, you can see that there is no
need to flatten out the query and that we can send complex results back. The projection of `Lines[].ProductName` is more interesting. Not only are we
projecting an array, but we are actually projecting a _single_ value from the array back to the user. I don't think that I need to expand on how 
powerful such a feature can be.

![Projecting array and complex object from a document](./Ch09/img09.png)

The `select` clause listing is an easy way, and quite familiar to users, to get a specific piece of data out. But it only let us select what we are getting
back and rename it using aliases. RavenDB is a JSON database and as smart as the `select` is, it is best for dealing with mostly flat data. That is why we 
have the ability to project object literals.

#### Projecting with object literals

SQL was meant to handle tabular data, and as such, it is great in _expressing_ tabular data but not so great when we need to work with anything but the most
trivial of documents. With RQL, you aren't limited to simplify select the flat list of properties from the document but can also project a complex result with
the object literal syntax. Let us look at a simple example of using object literals to query in Listing 9.9.

```{caption="RQL projection using object literal syntax" .sql}
from Orders as o
select {
    Country: o.ShipTo.Country,
    FirstProduct: o.Lines[0].ProductName,
    LastPRoduct:  o.Lines[o.Lines.length - 1].ProductName,
}
```

The result of the query in Listing 9.9 for document `orders/1` is showing in Listing 9.10. As you can see, we are able to project the data out not only using 
property paths but also using complex expression, pulling the first and last products from the order.

> **Alias is required with the object literal syntax**
> 
> The query in Listing 9.9 is using `from Orders as o`, defining the alias `o` for the `Orders` collection. This is required when using the object literal
> syntax, since we need to know what is the root object the expression starts from. 

```{caption="Result of projection from Listing 9.9" .json}
{
    "Country": "France",
    "FirstProduct": "Queso Cabrales",
    "LastPRoduct": "Mozzarella di Giovanni",
    "@metadata": {
        "@id": "orders/1",
    }
}
```

The key to the object literal syntax is that this isn't a JSON expression, it is a JavaScript object literal, and any valid JavaScript expression is going to 
be work. For example, let us take a look at Listing 9.11, which shows a slightly more complex example.

```{caption="Projections of JavaScript metohd calls" .sql}
from Orders as o
select {
    Year: new Date(o.ShippedAt).getFullYear(),
    Id: id(o)
}
```

Because JSON doesn't have a way to express dates natively, we can use the `new Date().getFullYear()` to handle date parsing and extracting of the year portion
of the date. And you can also see the projection of the document identifier as well. In addition to the usual JavaScript methods, you also have access to 
functions defined by RavenDB itself, such as `id`, `year` (instead of the more long winded JavaScript version), etc. A full list of the functions available
for your use can be found in the online documentation.

We'll look at one final example of the kind of projections you can make with the object literal syntax, mostly because I think it is a beautiful example of
the kind of stuff that you can use. Listing 9.12 shows a query that will get the two most expensive products and the total value of the order.

```{caption="Making non trival calculations in projections" .sql}
from Orders as o
select {
    TopProducts: o.Lines
        .sort((a, b) => 
        	(b.PricePerUnit * b.Quantity) - 
        		(a.PricePerUnit * a.Quantity) 
        )
        .map(x=>x.ProductName)
        .slice(0,2),
    Total: o.Lines.reduce(
    	(acc, l) => acc += l.PricePerUnit * l.Quantity,
    	 0)
}
```

There is a lot going on in this small bit of code, so let us break it into its individual pieces. First, we use the object literal syntax and define two 
properties that we'll return. For `TopProducts`, we sort the lines by the `PricePerUnit` in descending orders, grab just the names and then take the first
two items.
For `Total`, we simply use the JavaScript `reduce` method to calculate the total price on the order during the query.
If you are familiar with JavaScript, this is nothing special, but it express a lot of the power available to you when you project using the object literal
syntax. 


> **Projections are applied as the last stage in the query**
>
> It is important to understand that projections, either simple via `select o.ShippedTo.Count, o.Company` or more complex using the object literal syntax
> are applied as the last stage in the query pipeline. In other words, they are applied _after_ the query has been processed, filtered, sorted and paged. 
> This means that the project doesn't apply to _all_ the documents in the database, only to the results that are actualled returned. 
>
> This reduce the load on the server significantly, since we can avoid doing work only to throw it immediately after. And it also means that we cannot do
> any filtering work as part of the projection. You can filter _what_ will be returned, but not _which_ documents will be returned, that has already been
> determined earlier in the query pipeline.
>
> Another consideration to take into accoun is the cost of running the projection. Especially with object literal syntax and the method declarations that 
> we'll soon explore, it is possible to make the projection query expensive to run. RavenDB has limits to the amount of time it will spend in evaluating
> the projection, and exceeding these (quite generous) limits will fail the query. 
>
> I want to emphasize that you shouldn't be reluctant of using projections or the object literal syntax in particular. This can signficantly reduce the
> amount of data that is sent over the network, and is usually preferred when you need to return a list of documents and are only interested in some of 
> the data in them for display purposes. 

The object literal syntax is quite flexible, but it has a few limits. In particular, take a look at Listing 9.12 and how we compute the cost of a 
particular product. this is using using the following formula: `l.PricePerUnit * l.Quantity`. However, I forgot to also include the discount that may
be applied here. The formula for the discount is simple, the new way to compute the price of a product is simply: 
`l.PricePerUnit * l.Quantity * (1 -l.Discount)`. That is simple enough, but this repeats three time in Listing 9.12. This is an ideal example of the 
Don't Repeat Yourself principle. If we were writing code using any standard programming language, we would wrap this in a function call to make it 
both easier to understand and allow it to change it in a single location. Luckily, RQL also has such a provision and it allows you to define functions. 

Listing 9.13 shows how we can use the function declaration to avoid repeating ourselves and properly compute the product price. 

```{caption="Using functions to consolidate logic" .sql}
declare function lineItemPrice(l) {
    return l.PricePerUnit * 
    	   l.Quantity * 
    	   (1 - l.Discount);
}
from Orders as o
select {
    TopProducts: o.Lines
        .sort((a, b) => 
        	lineItemPrice(b) - 
        		lineItemPrice(a) )
        .map( x => x.ProductName)
        .slice(0,2),
    Total: o.Lines.reduce((acc, l) => 
    		acc + lineItemPrice(l),
    		0)
}
```

In Listing 9.13, we first declare the function `lineItemPrice`. This takes line item and computes the total amount you would pay for it. Once this has 
been declared, you can then use the function inside the object literal.

> **Declaring functions in queries**
>
> You can declare zero or more functions as part of the query, and they will be visible both for each other and from the object literal expression.
> Such functions can do anything you want, subject to the usual limits of projections (you can't take _too_ long to run, since it will time out the
> query). 
>
> Inside the function all the usual JavaScript rules apply, with the exception that we'll ignore missing properties by default. In other words, you 
> can write code such as `l.Who.Is.There` and instead of throwing a `TypeError`, the entire expression will be evaluated to `undefined`. 
>
> Declared functions can only be used from inside the object literal expression and are _not_ available for the simple select expression syntax.

I sure that you can imagine the kind of queries that declaring functions make possible. You can tailor the results of the query specifically for the 
what you want, and you can do all that work on the server side, without having to send a lot of data over the wire. 

In fact, there is one more way to project data from queries. Using a function directly. This is usually used for when you want to return objects with
different shape in the query. Before we proceed to see how this can be done, a word of caution. It is usually hard to deal with heterogenous query 
results, with each object being in potentially different shape. There are some cases that this is exactly what you want, but it is usually complicates
the client code and should not be overused. 

Listing 9.14 shows how we can project a method directly to the client, doing what is probably the world most ridicilous localization effort.

```{caption="Returning differently shaped results based on the document data" .sql}
declare function localizedResults(c) {
    switch(c.Address.Country)
    {
        case "France":
            return { Nom: c.Name };
        case "Brazil": 
            return { Nome: c.Name };
        default:
            return { Name: c.Name };
    }
}
from Companies as c
where id() in ('companies/15', 'companies/14', 'companies/9')
select localizedResults(c)
```

The result of this query can be seen in Figure 9.10, where you can see that different documents have different shape. I had a lot of fun writing the query
in Listing 9.14, but I wouldn't want to have to deal with that in my code, because it would probably be too confusing. 

![RQL query results for the projecting via a method call](./Ch09/img10.png)

To summarize projections, we have the following options available to us when we query RavenDB.

* Getting the whole document back, this can be done by omitting the `select` clause entirely or using `select o` or `select *`, with `o` being the root
  alias of the query. 
* Projecting values from the document using simple select expressions, such as `select o.ShipTo.Country, o.Company as CompanyId`. This allow to control
  what is sent back and rename fields. We can also project nested values and dig into arrays and objects, but this is intentionally made simple, to ensure
  that we can process it quickly and efficently.
* Projecting values from the document using object literal expression gives you far more power and flexiblity, you can utilize JavaScript expressions to 
  get the results just the way you want them. This includes doing computation on the returned result set and even declaring functions and doing more work
  inside the function to avoid repetitions and make it easy to build complex queries.
* Projection values as the result of a single method call in the select, such as `select localizedResults(c)`. In this case, the shape and structure that
  will be returned is completely up to you. You can even return `null` or `undefined` from the method call and that will be sent to the client (where you'll
  need to be careful about handling it, of course). 

Of the four options we have, you need to remember that only the first option will give you the full document back. In all other cases, you will be returning
a projection. This is important from the client side, because the client API will not be tracking a projection and changes to the projection will not be saved
back to the server when you call `SaveChanges`.

> **Querying by id**
>
> If you'll look at Listing 9.14 you'll see an interesting type of query. In there, we are querying by the document id and specifying a projection. This may
> see likely a strange thing to do. Surely it would be better to just get the documents directly, if we know what their ids are, no?
>
> Querying by id are handled differently. Instead of going throught an index, if the query optimizer can see that your query is using an id, it will fetch
> the relevant documents directly using their id, and then pass them to the rest of the query for processing. This applies when you are querying by id and 
> does not have additional filters, sorting or the like that would require us to still use an index. 
> 
> This allows us to define projections on a single document (or a group of them) and use all the power of RQL projections to get back the results we want.
> For large documents, this can be a significant saving in the amount of data that goes over the network, without the server having to make any additional
> effort, since this is an exception to the rule that queries that don't have an index to cover them will have one created for them. In this case, the 
> query optimizer can use the internal storage indexes and avoid creating another one. 

We looked into all the different ways we can project results from a document as part of a query, but there is still more that we can do. We can use RQL to
work with _multiple_ documents, this is the topic of the next section.

### Loading and including related documents

In general, queries in RavenDB apply only to a single document. That is, you can ask questions about a single document and not about other documents. 

> **Querying on relations**
>
> The previous state is not _quite_ true. You can actually query on related documents and even across heterogenus document collections using RavenDB,
> but only when you are the one who is defining the index. We'll discuss static indexes in the next chapter, so I'll hold discussion of that until 
> then.

In other words, you can query on every aspect of a document quite easily, but you cannot query on related data trivially. If you are used to SQL, then
the simple answer is that RavenDB doesn't allow joins. Recall back the three tenants of document desing, coherent, cohesive and independent. With proper
modeling you shouldn't usually want to do that, and RavenDB have ways to enable that scenario, discussed in the next chapter. 

That said, it can be very useful to grab some data from related documents during the query. Consider a query to show the list of recent orders. We can
query it using the following query: `from Orders where Company = 'companies/1'` and the result of this is shown in Figure 9.11.

![The results of simple query on orders](./Ch09/img11.png)

As you can see in Figure 9.11, the output is the document, and that include very useful fields, such as `Company` and `Employee`. This is great, but 
if we intend to show to a user, showing `employees/6` is not considered to be a friendly act. We can ask RavenDB to include the related documents as
well, as you can see in Listing 9.15.

```{caption="Including related documents in RQL" .sql}
from Orders 
where Company = 'companies/1'
include Company, Employee
```

Figure 9.12 shows the output of this in the studio and you can see that we got the company and the employees back from the query. We have already 
talked about the include feature in Chpater 4, [Advanced Client API](#advanced-client-api) at length. It allow us to ask RavenDB to send us related
documents as well as the query results themselves, saving us the network roundtrip to fetch the additional information.

![Viewing included results in the studio](./Ch09/img12.png)

Including related documents is very useful, but if we just intend to show the information to the user, sending the full documents back can be a waste.
We can do better by using `load`. In Listing 9.16 you can see a small example of pulling data from multiple documents and returning that to the user.

```{caption="Using load to fetch data from related documents" .sql}
from Orders as o
where Company = 'companies/1'
load o.Company as c, o.Employee as e
select {
    CompanyName: c.Name,
    EmployeeName: e.FirstName + " " + e.LastName,
    ShippedAt: o.ShippedAt
}
```

It is important to remember that the `load` clause is not a join, it is applied _after_ the query already run and before we send the results to the 
projection for the final result. As a result, it can't be used to filter the results of the query by loading related documents and filtering on their
properties. It also means that `load` doesn't impact the cost of the query, and the database will only need to handle a single page of
results to send back to the client.

You can also use the `load()` method inside declared functions or inside the object literal. We could have skipped the `load o.Company as c` and used
`CompanyName: load(o.Company).Name` instead and gotten the same results. Load is also supported for collections, as you can see in Listing 9.17.

```{caption="Loading data using arrays" .sql}
from Orders as o
where Company = 'companies/1'
load o.Employee as e, o.Lines[].Product as prodcuts[]
select { 
    CompanyName: load(o.Company).Name,
    EmployeeName: e.FirstName + " " + e.LastName,
    ShippedAt: o.ShippedAt,
    Products: prodcuts
}
```

In Listing 9.17 we pull all the related products from the lines. Note that we indicate to RavenDB that the result is an array by using the `prodcuts[]`
but we use `prodcuts` in the object literal (since it is an array instance value there). The same would be the case for simple select, we don't need
to specify the `[]` postfix for RavenDB to know that this is an array.

Loading documents in such manner allow you to bring together a complete picture for the user. This is typically done as a way to feed the results 
directly from RavenDB to the UI, with minimal involvement of middleware between the UI and the results of the query. For includes, you are actually 
getting the real documents back and modifications on them will be sent to the server when you call `SaveChanges`, but when you are using `load` you'll
typically get a projection back, which isn't tracked.

With `load` you typically have less bytes going over the network, but sometimes it is easier to do certain things in your own code. Even though `load` 
and object literals allow you to shape your results in a some pretty nifty ways, do not try to push too much into the database layer, espcially
if this is business logic. That road rarely leads to maintainable software systems. 


### Sorting query results

All the query we made so far have neglected to specify the sort order. As such, the order in which results are returned is not well defined. It will
usually be whatever RavenDB thinks is the most suitable match for the query. That works if you are using queries that match over complex conditionals
but is usually a poor user experience if you query for the orders a user made in the past six months.

RQL supports the `order by` clause which allows you dictate how results are sorted. Take a look at Listing 9.18 for such an example. 

```{caption="Sorting by multiple fields in RQL" .sql}
from Employees 
where Address .Country = 'USA'
order by FirstName asc, LastName asc```

There query in Listing 9.18 reads very much like a typical SQL query, by design. However, you need to be aware of a very important distinction. Consider
the query in Listing 9.19.

```{caption="Sorting by multiple fields in RQL with different order" .sql}
from Employees 
where Address .Country = 'USA'
order by LastName asc, FirstName asc
```

The query in Listing 9.19 is very nearly the same exact query as the one in Listing 9.18. However, the sort order is different. Why does this matter?
It matters because in both cases, we used the same index: "Auto/Employees/ByAddress.CountryAndFirstNameAndLastName", in this case. This is one of those
cases where you needed to have experienced the pain to understand why this is such an important detail.

Typically, databases will use an indexing format that allows the database to very quickly answer very specific order by clauses. Similar to the phone
book we discussed earlier in the chapter, they can only be used for the purpose for which they were created. It is possible to use the phone book index
to answer the query in Listing 9.19, but not in Listing 9.18. RavenDB, however, doesn't use such single purpose indexes and index each field indepdnently.
That means that it is able to answer both queries (and any combination thereof) using a single index.

The more flexible index and sorting behavior  make very little difference if the size of the data is small, but as the size of the data increases, this 
means that you can still offer flexbile sorting to the users while other databases will typically be forced to do full table scans. 

Another important factor of sorting in RavenDB is that it is applied _after_ the filters. In fact, the RQL syntax has been designed so each step in the
query pipeline will have the corresponding place in the query. You can see that in the queries in Listing 9.18 and 9.19, the `order by` comes after the
`where` clause, because we first filter the result, and then we sort them.

This is more flexible, but it has a downside, if you are querying over a large dataset without a filter and apply sorting, then we need to sort all of 
the results, and then give you back just the first few records. This is usually only a problem if you query has hundreds of thousands or results that we
need to sort through. In such cases, it is usually advisable to filter the query to reduce the number of results that RavenDB needs to sort.

You aren't limited to sorting just by the fields on the document. You also have the following sorting options:

* `order by score()` - order the results by how closely they match the where clause (useful if you are using full text search or using `OR` in 
  the `where` clause)
* `order by random()` - random order, useful for selecting a radnom result from the query.
* `order by distance()` - useful for spatial queries, and will be discussed later in this chapter
* `order by count()` / `order by sum()` - allow to order the result of queries using `group by`, discussed later in this chapter. 

The sort order can also be impacted by how you want RavenDB to sort the fields. For example, consider the following query:
`from Products order by PricePerUnit desc`. If you'll run it, you'll get some peculiar results, as shown in Figure 9.13.

![Unexpected ordering with numeric order by](./Ch09/img12.png)

The issue is that RavenDB doesn't know the type of the `PricePerUnit` field, and as such, it defaults to lexical ordering. In this case this means that
`7` is sorted after `62.5`. In our `order by` clause, we need to let RavenDB know what kind of sorting we want to do. An example on how to do just that
can be seen in Liting 9.20.

```{caption="Sorting by numeric data in RQL" .sql}
from Products
order by PricePerUnit as double desc
```

The `as double` in Listing 9.20 instructs RavenDB that the results should be sorted as double. You can also use `as long` to specify that the data should
be sorted as natrual integer, truncating any fractional values. The way `as long` and `as double` work is that the direct RavenDB to use a dedicated field
with the numeric values in the index, instead of using the string value for sorting. 
There is also the ability to sort using `as alphanumeric`, which will do as you expect and apply alpha numeric sorting to the query. 

> ** Deep paging is discouraged **
>
> Sorting and paging usually go together. Paging is actually specified outside of RQL, so we won't be seeing it in this chapter. However, paging
> in RavenDB is pretty simple in general, you specify the number of results you want and the number of results you want to skip. The first option,
> the number of results you want to get back, is pretty obvious and easy for RavenDB to deal with. The second, not so much.
>
> For example, if you want to get the first page, you specify `start` as `0` and `pageSize` as `10`. If you want the second page, you specify that
> `start` is `10`, and so on. This works very well, as long as the depth of your paging isn't too excessive. What do I mean by that?
> 
> If you expect to be issuing queries in which the `start` is very high (thousands or higher), you need to be aware that paging will happen during
> the sorting portion of processing the query. We'll get all the matching results for the query, sort them, and then select the relevant matches
> based on the page required.
> 
> However, the more deeply you page, the more work you force RavenDB to do. If you need to page deeply into a resultset, it is typically much better
> to do the paging in the `where` clause. For example, if we were looking at recent orders for a customer, and we expected customers to want to look
> at very old orders, we would be better off by specifying that the pages we show are actually dates. So the query will become 
> `where OrderedAt < $cutoffPoint`. This will significantly reduce the amount of work required from RavenDB.

There isn't much more to say about sorting In RavenDB, it works pretty much as you would expect it to. 

#### Spatial queries 

order by disstance

//TODO: 

### Aggregation queries

Aggregation in RavenDB can be used either directly from RQL using `group by` or by building your own Map/Reduce indexes. In both cases, however, the 
underlying implementation is the same. Aggregation in RavenDB happens during indexing, not during query, and as such are much cheaper than aggregation 
queries in other databases. 

Let us start by looking at the simple aggregation query in Listing 9.21. 

```{caption="Simple group by query in RQL" .sql}
from Orders 
group by Company
where count() > 25
order by count() as long desc
select count(), Company
```

This query is quite trivial, listing the companies with the most orders in descending rank if they have more than 25 orders in total. Simple and quite
obvious, but there is a lot going on behind the scenes. As usual, the query optimizer will generate an index for us to answer this query. This index
will serve all queries on `Orders` that group by `Company`. 

The interesting bit is that the index is going to handle the actual aggregation for us. In other words, during indexing, we are going
to do the grouping and write to the index the already computed results. When we query, we don't need to do any additional work, only
to lookup in the index all the companies with more than 25 orders and return that immediately.

When there is a new order, the index will not need to recompute the entire aggregation from scratch, but will be able to just update
the relevant details. We'll discuss this in detail in the next chpater, so for now I'm going to defer further explantations.

RQL aggregations support is pretty basic, you can do most simple queries directly in RQL, but as the complexity grows, you'll likely find it eaiser
to define a static index and handle map/reduce in that fashion. 

Regardless of whatever you are using a `group by` in your queries or a map/reduce index, the idea that aggregation queries are cheap has some really
interesting implications on your system. Instead of having to make sure that every time that you're making an aggregation query you'll have caching in 
place and a way to update the cache and a scehduler to recompute results, all of that is done for you.

Let us see why this is so important. Consider the query in Listing 9.21. In a relational database, this kind of query is actually quite expensive. Even
assuming that we have an index on the `Company` field, the relational database will need to go over all the results and count them, filter those that 
don't have enough order and them sort them.
If the number of orders is high, that effectively means that the relational database needs to read through all the orders (or at least the entire index on
the `Company` column). 

RavenDB, on the other hand, already did this work during indexing, so when you make the query, RavenDB just grabs all the companies that have more than 25 
orders, sort them and give them back to you. This is significantly cheaper. Cheap enough that you don't need to worry about how up to date your reports are.
Unlike other databases, RavenDB can avoid the need to do aggregation only during off hours, leaving you with data that is usually 24 hours old. Instead,
you can have an aggregation that is keeping up with the incoming flow of the data and is very close to real time.

### Indexing in the background

Indexing in RavenDB will always happen in the background. This has been mentioned a few times previously in this book, but it is important to call it out
explicitly and explain what it means. 

BASE, Stale, etc