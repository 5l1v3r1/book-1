
## The Query Engine

[Query Engine]:(#query-engine)

Queries in RavenDB are using a SQL-like language called^[Aren't you surprised?] RavenDB Query Language, henceforth known as RQL^[Pronounced
Rachel, like my wife and because it is funny.]. 

You already run into the RavenDB Query Language before, even if I didn't explicitly called it out as such, when using subscriptions. Both
subscriptions and queries are using RQL, although there are a few differences between the supported options between the two. The idea with 
RQL is to expose directly the inner working of the RavenDB query pipeline in a way that isn't going to overwhelme users.

Therefor, we'll first take a brief look at how RavenDB is actually processing queries, then get started on actually _running_ queries. We'll
start from the simplest scenarios and explore all the nooks and cranies of what you can do with RavenDB queries.
And the first place to is the query optimizer.

### The query optimizer

When a RavenDB instance gets a query, the very first thing that happens is that the query optimizer analyzes it. The role of the query
optimizier is to determine what indexes should be used by this particular query. This is pretty much par the course for databases. However,
with RavenDB, there are two types of queries. You may have a dynamic query, such as `from Orders where ...`, which give the query optimizer
full freedom with regards to which index that query will use. Alternatively, a query can specify a specific index to be used, such as: 
`from index "Orders/ByCompany" where ...`, which instructs RavenDB to use the `Orders/ByCompany` index.

> **Queries are always going to use an index**
> 
> You might have noticed that we are talking about index selection for the query as primarily the _selection_ of the index to use. 
> However, you might be familiar with query plans that couldn't find an appropriate index and fell back into querying using a full
> scan. 
>
> RavenDB doesn't include support for full scans, by design. Queries in RavenDB are _fast_, and they will _always_ use an index. Using
> full scans is an excellent method when the size of your data is very small, but as it starts to grow, you are going to experience
> ever-increasing query times. In contrast, RavenDB queries are always using an index and can return results with the same speed regardless
> of the size of the data.

What happens when the query optimizer is unable to find an index that can satistfy this query? Instead of scanning all of the documents,
inspecting each one in turn and including it in the query or discarding it as an unsuccessful match, the query optimizer go in a different
route. It will _create_ an index for this query, on the fly. 

If you are familiar with relational database, you might want to take a deep breath and watch your pulse. Adding an index to a relational
database in production is fraught with danger, it is _possible_, but it needs to be handled very carefully. In contrast, RavenDB indexes
will not lock the data and they are designed so they will not consume all the system resources while they running. This means that adding
a new index isn't the world shattering spectacle that you might used to. RavenDB has gotten it to be such routine event that we let the 
query optimizer run it on its own, as needed. 

Now, creating an index per query is going to result in quite a few indexes in your database, which is still not that good an idea. It's a 
good thing that the query optimizer doesn't do that. Instead, when it gets a query, it analyzes it and see what index can answer this query
and if there isn't one, it creates an index that can answer this query and _all previous queries_ on that collection.

Indexing in RavenDB is a background operation, which means that the new query is going to be waiting for the index to complete indexing
(or a timeout), but at the same time, any existing queries will proceed normally using the existing indexes. When the new index has caught
up, RavenDB will cleanup all the old indexes that are now superceded by the new one. 

In short, over time the query optimizier will analyze the set of queries that you are making to your database and will generate the optimal
set of indexes to answer those queries. Changes in your queries will also trigger a change in the indexes on your database, as it adjusts to
the new requirements. 
Practically speaking, this means that a new version of your application being deployed will not invalidate all the hard work the DBA put in 
to make sure that all the queries are optimized. 

> **Learning on the side**
>
> You don't have to do the new version adjustment on the production systems. You can run the new version of your system on a test instance
> of RavenDB and let it learn what kind of queries are going to be performed. Then, you can export that knowledge into the production 
> system during quite time, so by the time the new system is actually deployed, the database is already familiar and ready for the new
> workload.

Lets get started with actual queries. In the studio, create a new database and then go to `Settings` and then to `Create Sample Data` and 
click on the big `Create` button. This will create a sample database (the Northwind online shop data) that we can query.
Now, go to `Indexes` and then `List of Indexes`, you'll note that there are three indexes that are defined in the sample database. 
We are going to switch back and forth between `List of Indexes` and `Query` quite often for the next part, so you might want to open the 
`Query` in a separate tab and switch between the two. 

Go to 'Query' and issue the following query:

```
from Employees
```

You will get a list of employees in the studio, which you can inspect. You can view the full document JSON by clicking on the eye icon.
If you'll look at the list of indexes, you'll see that no new index was created, even though there are no existing indexes on the 
`Employees` collection. This is because there isn't any filtering used in this query, so the query optimizer can just use the raw 
collection documents as the source for this query, no need to do any work. 

The same is true for querying by a document id with `from Employees 
where id() = 'employees/1'` or 'from Employees where id() in
 ('employees/1','employees/2')'. The query optimizer doesn't need any index to handle these queries and can answer them directtly.

However, what happens when we start querying on the data itself? You can see the result in Figure 9.1. In particular, you'll note that 
RavenDB reports that this query used the `Auto/Employees/ByFirstName` index. 

![RQL query for employees named Andrew](./Ch09/img01.png)

Switching over to the indexes listing will show you that indeed, a new auto index was created for us to answer these kinds of queries. 
Let us test this further and query by _last_ name now, usnig: `from Employees where LastName = 'Fuller'`. You can see the results of 
running this query in Figure 9.2. 

![The merged auto index can answer queries by first name or last name, or both](./Ch09/img02.png)

The query optimizer has detected that there is no index for this query, looked at the previous history of queries on the `Employees`
collection and create an index that can satisfy all such queries in the future. If you were fast enough, you might have managed to 
catch the `Auto/Employees/ByFirstName` index disappearing as it was superceded by the new index. 

Now that you have experienced the query optimizer first hand, let us give it a bit of workout, shall we? Let us see what kind of queries
we can do with RavenDB.

### Querying capabilities

Requiring that all queries will always use an index has a few interesting results. It means that it queries tend to be _really_ fast, because
there is always an index backing the query and we don't need to go through full scans.  Another aspect of this decision is that 
	RavenDB only support query operations that _can_ be answered quickly using an index. For example, consider the following query:

```
from Employees where FirstName = 'Andrew'
```

This kind of query is very easy to answer using an index that has indexed the `FirstName` field, because we can find the `Andrew` 
entry and get all the documents that has this value. However, a query like the following is not permitted:

```
from Employees where years(now() - Birthday) > 18
```

This query would require RavenDB to perform computation during the query, forcing us to do a full scan of the results and evaluate each one in turn. 
That isn't a good idea if you want fast queries, and RavenDB simply does not allow these type of queries. You can re-write the previous query to
efficently use the index by slightly modifying what you are searching for:

```
from Employees where Birthday < $eighteenYearsAgo
```

The `$eighteenYearsAgo` variable would be set for the proper time and that would allow the database to find the results by merely seeking in the 
index and then returning all the results smaller then the given date. That is cheap to do and the proper way to run such queries. 
In general, you can usually do a straightforward translation between queries that require computations and queries that do not, as above. Sometimes
you can't just modify the query, and you need to tell RavenDB that it needs to do some computation during the indexing process. We'll see how that
can be done in the chapter about ["Static Indexes"](#static-indexes).

Queries can also use more then a single field, as you can see in Listing 9.1.

```{caption="Querying over several fields at the same time" .sql}
from Employees 
where 	(FirstName = 'Andrew' or LastName = 'Callahan') 
and 	Address.Country = 'USA'
```

Using the sample data set, this should give two results, as shown in Figure 9.3, where you can also see some of the options available to inspect
the index behavior. Viewing the index definition will tell you what is indexed and how, and the indexing performance statistics
will give you all the details about the costs of indexing, broken down by step and action. This is very important if you are trying to unerstand
what is consuming system resources, but that will be covered in the next part of the book, discussing 
["Prouction Deployments'](#production-deployments) and how to monitor and manage RavenDB in production. 

![Available operations for inspect index state](./Ch09/img03.png)

Far more important for us at this point is the `View index terms` page, which can expose the internal structure of the index to you. This is very
helpful when you need to understand how RavenDB is processing a query. 
If you'll click on that link, you'll be taken to the index terms page, where you'll see the index fields. Clicking on this will show you what was
actually indexed, this is shown in Figure 9.4.

![The indexed terms for the various fields in the index](./Ch09/img04.png)

Why is this so important? Even though Figure 9.4 doesn't show all the values, it is enough to explain how RavenDB is actually going to process 
the query. 

> **RavenDB indexes aren't your typical B+Tree**
>
> A common way to 


> ** Deep paging is discouraged **


#### Aggregation queries

#### Exact matches

#### Full text search

#### Lucene

#### Spatial queries 

#### Recursive map/reduce


#### Suggetsions

#### Side by side