
# Inside RavenDB Indexes

In this chapter, we are going to go over a lot of the theoretical details and reasoning behind how RavenDB indexes work. You'll not actually learn how to _use_ the indexes in this query, but you'll learn all about their details. You can feel free to skip this chapter for now, and go straight ahead to the next one to read the practical details on using indexes. But come back here and read this chapter at your leisure, it contains a lot of very important information about how RavenDB operates internally.

We have already done quite a bit with RavenDB, but we haven't talked about indexing at all and very little about querying. That doesn't mean that we didn't _use_ indexes, however. Let us consider the following query:
	
	var recentOrdersQuery =
		from order in session.Query<Order>()
		where order.Company == "companies/1"
		orderby order.OrderedAt descending
		select order;

	var recentOrders = recentOrdersQuery.Take(3).ToList();

How does a query like that work, on the server side? If you are used to relational databases, you might assume that the following pseudo code is run:

	var results = new List<Order>();
	foreach(var order in GetAllDocumentsFor("Orders")) {
		if(order.Company == "companies/1")
			results.Add(order);
	}
	results.Sort((x,y) => y.OrderedAt.CompareTo(x.OrderedAt));

This type of operation is called a table scan, and it is quite frequent in relational databases. This is also quite efficent, as long as the number of items you have in the database is very small. It tends to fail pretty horribly the moment your data size reach any significant size.
I've run into variants of this issues at customers over and over again, and when the time came to designing RavenDB, I decided that as part of the Safe By Default culture, we will simply not support this problem.

*RavenDB does no table scans!* In fact, there are no O(N) operations in general in RavenDB queries. Given the title of this chapter, I'm sure that you can guess how we handle queries. We use indexes to speed up queries. Using an index turn a query from an O(N) operation to an O(logN) operation. For those of you who don't care about abstract computer science stuff, the difference is between waiting 30 minutes for a result, or getting it right away.

> **We haven't created any indexes, but we can query!**
>
> Yes, that is confusing, isn't it? RavenDB doesn't allow queries without an index to answer the question. Yet at the same time, it does support queries without first defining an index. 
> 
> The answer is very simple, RavenDB is a pretty smart beast, whenever you make a query, the query optimizer get a chance to look at that, and it select the appropriate index to use. But what happens when we don't _have_ such an index? Well, you obviously want to query that information, otherwise you won't have send the database this query. What to do...
> 
> The query optimizer at this point can figure out what you need to be index, and it will _create this index for you_. The details of this process are explained later in the chapter, but the key part to understand is that RavenDB can automatically optimize itself to answer the kind of queries that you execute.
> This happens on the fly and without requiring any human involvement. The more you use RavenDB, the smart it become and the faster it is in responding to requests.

But we are jumping ahead of ourselves here, we'll discuss the ad how querying optimization RavenDB does in the [dynamic indexing](#dynamic-indexing) section. Before we get there, let us look at a few standard RavenDB indexes first.

## How indexing works in RavenDB?

An index is a way for the database to organize information about your data so it will able to retrieve said data efficiently. Let us look at an index definition in RavenDB. In this case, we want to index the `Name` property of a `Product`, so we can search for a product by name. Listing 6.1 shows a simple index that will allow us to answer such a query.

```{caption="{Index definition for searching products by name}" .cs}
from product in docs.Products
select new 
{ 
	product.Name 
}
```

This doesn't look very much like an index, does it? It looks a Linq query. In fact, if we were to excute this query we'll get the following results:

----							----						
Alice Mutton					Chocolade					
Aniseed Syrup					CÃ´te de Blaye				
Boston Crab Meat				Escargots de Bourgogne		
Camembert Pierrot				Filo Mix					
Carnarvon Tigers				Flotemysost					
Chai							Geitost						
Chang							Genen Shouyu				
Chartreuse verte				Gnocchi di nonna Alice		
Chef Anton's Cajun Seasoning	Gorgonzola Telino			
Chef Anton's Gumbo Mix			Grandma's Boysenberry Spread
----							----						
Table: First 20 product names, sorted.

So how can this be an index? The answer is that this isn't actually the index. The link expression above is actually the _index definition_, this determine _what_ will be indexed (as well as exactly how, but we'll touch on that later). How does that work?

Let us look at Listing 6.1, this is the external respresentation of the index, but internally, we add need to track where the details came from so the end result is:

	from product in docs.Products
	select new { product.Name, **product.__document_id** }

The output of the index definition is a list of objects with a `Name` and a `__document_id` property. But what can we do with this? 

> The following isn't actually how this work in RavenDB, we'll get to the full details of that in a bit. This is an attempt to explain how RavenDB works by simplyfing things as much as possible.

Now that we have the data to be indexed, we can actually put this in the index. From a logical perspective, Listing 6.2 shows what is going on after we have the index

```{caption="{Logical view of storing index entries in the index}" .cs}
var index = new Dictionary<string, string>(); // name --> doc id
foreach(var indexEntry in results)
	index[indexEntry.Name] = indexEntry.__document_id;
```

And queries now become a simple issue of reading through the index and then sending the results back, as shown in Listing 6.3.

```{caption="{Logical view of querying the index}" .cs}
// query for Name = Chang

var docId = index["Chang"]
return LoadDocument(docId);
```

Again, this isn't actually how it works, but it is a simple way of thinking about this.	And right now I want you to understand the general concept, rather than the actual details.

> **The `__document_id` property**
>
> The __document_id` is a reserved property named in RavenDB, it maps to the document id of the document, regardless of the client side convention. 

So, we use a linq expression to select the fields to index from our documents. We also add the relevant document id to the output, and then we put all of those details in an index. When we query, we use the index to figure out what is the actual document id that match the query, and then we load the document (or documents) from storage by id, and send it to the client.

For the rest of this chapter (and in general), we'll use the following terminology:

* **Indexing function** - the linq expression (such as the one in Listing 6.1) used to project the fields to be indexed from the documents.
* **Index entry** - the output of the indexing function. A single document can output zero or more index entries.

## Incremental indexing

By now, you have almost all the pieces you need to understand how RavenDB indexing works. In Chapter 4, we discussed [etags](#etags). An etag is just an ever increasing number that changes whenever a document changes. Because a RavenDB database can contain a _lot_ of documents, it isn't practical to run the indexing function over the entire data set every time. Instead, we do incremental indexing, and we do that using the etag. Listing 6.4 shows a simplified version of how indexing works.

```{caption="{Highly simplified indexing process}" .cs}
while (databaseIsRunning) {
	var lastDocEtag = GetLatestEtagForAllDocuments();
	var lastIndexEtag = GetLastIndexedEtagFor("Products/ByName");

	if(lastDocEtag == lastIndexEtag) { 
		// index is up to date
		WaitForDocumentsToChange();
		continue;
	}
	
	var docsToIndex = LoadDocumentsAfter(lastIndexEtag);
	for(var indexEntry in indexingFunc(docsToIndex)) {
		StoreInIndex(indexEntry);
	}
	SetLastIndexEtag("Products/ByName", docsToIndex.Last().Etag);
}
```

I'll repeat again that Listing 6.4 shows the _conceptual_ model, the actual working of this is very different.

## The indexing process

In relational databases, indexes are computed as part of the same write transaction. That leads to an interesting tradeoff. If you don't have the right indexes, you are falling back to a table scan, and all the performance degredation that comes with that. So you want your indexes to cover all the columns you are querying. But the more indexes you have, the slower writes become.

It ends up being up to the DBA, who need to make a judgement call. And often the DBA need to make that judgement call without a lot of information. The decision need to be made upfront, before the DBA has any actual performance numbers (because the application hasn't been created yet). With RavenDB, we chose a different approach.

Instead of executing the indexes as part of the write transactions, we run them as a background task. You can see a hint of that in Listing 6.4. This code (or rather, its conceptual cousin) is always running in the background, and whenever there is a change in the documents, the indexing function is run on the new or updated documents.

This has some interesting implications. The most obvious one is that there is an inherit race condition between updating a document and the indexes catching up with that update. Usually, the time between a document being updated and the relevant indexes being updated is measured in milliseconds, usually between 15 - 25 ms. 

> **Staleness in the real world**
> 
> At first sight, the idea of a query that may not be fully up to date sounds scary. But in practice, this is how we almost always work in the real world. The trivial counter example that I keep getting thrown in my face is financial transactions.
> 
> "Of course that you need full consistency for everything financial", they tell me. Try this, call you bank and ask them how much money you have in your account. The answer you'll get is going to be some variant of: "As of last business day, you had...".
> 
> Or let us take a pure software example, if you create a new bug, does it matter if your manager sees it right away, or wait an additional 25 ms to get it? This design choice was made explicitly, and it has quite a lot of benefits to it (detailed below).
>
> One very important factor to note is that RavenDB will always _tell_ you if you are getting potentially stale results, but more on that later.

The other implications of this design decision is that you the kind of promise the RavenDB database engine is drastically different than the kind of promises a relational database engine will give. A relational database will promise you that you'll have a fully consistent view of the universe. The problem with that is that it is very costly to actually do this. That is why relational databases has the concept of transaction isolation levels, and why very few of them opt to default to a high isolation level.

It is just too costly to do so. In order to keep its promise, the relational engine has to take locks, and do a lot of extra work to isolate different transactions from each other. The more transactions you have, the higher the cost. Until at a certain point, the relational database is overload and it will throw its hands up in the air and go sit in the corner while it is having a funk.

Your application, in the meantime, will start erroring (if you are lucky) or just hang, waiting for the relational database to respond.

With RavenDB, you get a different kind of promise. RavenDB will promise to:

* Give your immediate results based on what we currently have in the index.
* If the current state of the index isn't up to date, RavenDB will tell you so, including how up to date the index is.
* RavenDB will make its best to reduce the indexing latency.
* You have the option to explicitly wait for the results to become non stale.

> **Documents are always consistent**
>
> RavenDB uses the terms stale and non stale to refer to out of date indexes. This is done intentionally, because consistency is always maintained. 
> 
> Listing 6.3 showed how queries work, from a logical perspective. We first consult the index to find a match for the query we are executing. Once we have the match, we have the relevant document id. Using that document id, we go to the document storage and load that document by id.
>
> The RavenDB's document storage subsystem is fully consistent^[For the database nerds, which I assume that you are if you are reading this book, the document storage subsystem implements Snapshot Isolation and optimistic write locks.], so you are always getting the latest committed version of the document.

Why is it important that RavenDB has a different set of promises than a relational database? 

Because by making a different set of promises, we have opened ourselves to a great deal of optimization opprtunities. Here are just a few of those that are implemented in RavenDB.

### Throughput vs. Latency

I/O rates is usually the most expensive part of indexing. And it doesn't really matter if we are indexing a single document or a hundred, the base I/O cost of an indexing run is high enough to overshadow all other costs. Because of that, RavenDB utilizies several stratgies when it comes to indexing. 

Under light load, RavenDB uses a low latency / low throughput strategy. Documents will be indexed as soon as possible, and while the I/O cost of that can be high, it doesn't matter, because we would don't have enough load to saturate the system. But when the load gets higher, RavenDB automatically switches to a different strategy. The high latency / high throughput strategy. Under those conditions, we are going to run fewer indexing runs, but each indexing run will have more documents that need to be udpated. This allows us to amortize the I/O cost of indexing over a large set of documents, resulting in a greater efficency all around.

> **What is with all the implementation details?**
> 
> You don't really need to know all those details. And even though I'm going over the details, I'm still leaving a lot of stuff out. 
> But it is good to have a proper understanding of 

### Prefetching



## Working with stale results

## Lucene 

## Dynamic indexing

## How RavenDB index documents?