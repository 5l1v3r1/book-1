# Getting ready for RavenDB...

## What is this?

## Who is this book for?

//TODO

##  RavenDB, The back story

This is a technical book, but as important as the details about how things work, or what the design process is, I would like to tell you the actual story about how RavenDB started out. I'm going to be talking about myself quite a lot for this section, but we'll resume talking about RavenDB immediatley afterward.

In Sep 2007, I was sitting in JAOO, listening to [Joe Armstrong](http://joearms.github.io/) talk about Erlang, distributed systems and 9 nines reliability. 
Afterward, I bought his [Programming Erlang](http://pragprog.com/book/jaerlang2/programming-erlang) book and read it cover to cover. 
I thought the ideas presented in both the talk and the book were facinating, but just _reading_ about them in a book wasn't enough. Armed with just enough knowledge about Erlang to be able to sort of understand what it does, I decided that I need something bigger.

At the time, [CouchDB](http://couchdb.apache.org/) was one of the most cited Erlang projects, so I decided that I would go over its code and learn how production Erlang code is written. 
I [blogged about the experience](http://ayende.com/blog/3607/reading-erlang-inspecting-couchdb), so you can read my raw thoughts at the time.
This was my first real introduction to NoSQL. And it was at the level of actually reading through the codebase of a production quality database. It was a facinating journey.

But I don't _like_ the Erlang syntax. And I had several disagreements with the way CouchDB does things. And that was how it stayed for quite some time. Since 2004 or so, I have been dealing primarily with Object Relational Mappers and relational database. I'm a core team members in the NHibernate Project and I've been a consultant for much of that time.

Taken together, this means that ever since 2004, my job was mostly to go to clients and try to get their applications to perform well, be stable and scale to their requirements.
The problem with that was that at some point, I made a mistake. I was doing a code review for two clients, and I sent each of them the report about the issues that I found in their code and how to resolve it.

Mistakes like that aren't pleasant, but they happen. So imagine my surprise when the clients _didn't notice that they had a report about a completely different codebase_ before I pointed it out. In fact, one client was actually fast enough to _implement_ my suggestions before I could get back to them. Although they did comment that I was probably working on top of a different branch :-).

That led me to go back and review all of my work for the past several years, and realize that I was really doing the exact same thing, over and over again. I was working for clients that ranged from Fortune 100 to small startups, and in diverse industries such as health care, social media, risk management and real estate management. But the _problems_ that the clients run into were the same. And the _solutions_ were often the same as well.

It got to the point where I would tell my clients that if I wasn't able to give them a *major* performance boost within two days of arriving, I would cut my rate by 50%. I never had to do that, because usually within two hours of arriving at a customer, I was able to point out one of two or three very common issues that would drastically improve their situation.

I was very deeply into NHibernate consulting at the time. Which meant that most of my consulting was done on either the database interaction or the overall architecture of the system. In one memorable case, I helped a customer reduce the load on his system from roughly 17,000 (seventeen thousand) queries per page to a "mere" 75 queries per page. That is corrent, they have 17 _thousands_ queries per page. In production. For several years.
Admittedly, that is quite an extraordinary case. But my target was 75% - 90% reduction in the number of queries that the system made, and a comparable just in performance.

Usually I actually got to use my NHibernate knowledge to optimize the way the system accessed the database. But that usually happened at least several days into my visit. The first few days were _always_: Find the common Select N+1 issues, find the common Unbounded Result Set issues, etc.
Note that I didn't even try to find all those issues, because they were so prevelant. Just fixing the first three or five would usually give the system a very big boost in performance and make the customer very ahppy.

It made _me_ very sad, however. I was the database consultant equivalent for a plumber. I would go to a client, "unclog" the database, give some advice about how to do better, and move to another client, to do the exact same thing. 
I blogged about those issues extensively, and most of the people who invited me to look over their code were readers of my blog. By definition, then, they weren't stupid, careless or malicious. In fact, most of them were dedicated, hard working and very good at their jobs.

Something had to give, because if I saw yet another Select N+1 bug, I felt that I would just scream. So in 2008 I started working on what became the NHibernate and Entity Framework Profilers. Those tools monitor the interaction between your application and a relational database. Based on that information, they can show you how your code interacts with the database, what queires are being generated by what methods, and on top of that, they analyze the database interactions use that information to raise warnings and suggest improvements.

Building this tool meant that I could give it to my clients, and they would have the same insights as I did about how to properly work with a relational database. It also gave me an interesting project to work on that didn't involve finding the same issues over and over again with slight variations on the naming conventions.

