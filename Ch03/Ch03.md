
# Document Modeling

Modeling your data is important, crucially so. This is because RavenDB, and any other database, really need you to understand 
how it is actually storing information, what are the features that it has available for you to utilize and what impact 
different modeling decisions will have on your data, the amount of work the database needs to do, etc.

If you get it wrong, you may be forcing the database to do expnonential amount of additional work. On the other hand, if you 
play for the database strengths, you can get a robust and easy to build system. So, overall, no pressure whatsoever.

Relational based modeling is so frequently encountered that is most cases you don't even see people talk about the relational
part, they just consider that as simple "data modeling". But when you try to apply a relational modeling solution to a non 
relational system, the end result is usually... suboptimal.

The problem is that this is extremely well entrenched behavior, to the point where most people don't even realize that they are
making choices and decisions based on what would work best for a relational database. So the first section of this chapter is 
going to deal with how to get away from the relational mindset, and then focus on how to model data for RavenDB.

## Beyond relational data modeling

You've very likely used a relational database in the past. That means that you've learned about normalization, and how 
important that is. Words like data integrity are thrown around quite often, usually. But the original purpose of normalization 
had everything to do with reducing duplication to the maximum extent.

A common example for normalization is addresses. Instead of storing a customer's address on every order that he has, we'll 
simply store the address id in the order, and we have saved ourselves the need to update the address in multiple locations. 
You can see a sample of such a schema in Figure 3.1.

![A simple relational schema for orders](./Ch03/img01.png)

You've seen (and probably wrote) such schemas before. And at a glance, you'll probably agree that this is a reasonable way to 
structure a database for order management. Now, let explore what happens when the customer wishes to change his address. The 
way the database is set up, we can just update a single row in the Addresses table. Great, we're done.

Except... we've just introduce a subtle but deadly data corruption for our database. If that customer had existing orders, 
both those orders and the customer information are all pointing at the same address. Updating the address for the customer 
therefor will also update the address for _all of its orders_. When we'll look at one of those orders, we'll not see the 
address that it was shipped to, but the _current_ customer address.

> **When a data modeling error means calling the police**
> 
> In the real world, I've seen such things happen with payroll systems and paystubs (payslips across the pond). An employee 
> had married, and changed her bank account information to the new shared bank account. The couple also wanted to purchase a 
> home, so they applied for a mortgage. As part of that, they had to submit paystubs from the past several months. That 
> employee requested that HR department send her the last few stubs. When the bank saw that there were paystubs made to an 
> account that didn't even existed at that time, they suspected fraud, the mortgage was denied and the police was called. An 
> unpleasant situation all around^[This end up being sorted out eventually, by uttering the magic words: "Computer Error", 
> for what it is worth].

The common response for showing this issue is that it is an issue of bad modeling decisions (and I agree). The problem is that 
a more appropriate model is more complex to build and work with, more expensive to query and harder to reason about in 
general. 

A lot of the widespread wisdom about data modeling is limited to only seeing the world through relational eyes. The relation 
model offers us the Tables, Rows and Columns to store our data, and it is up to us to hammer the data to the right shape so the 
relational database can accept it. Along the way, we have to deal with an impedance mismatch between how your software (and our 
minds) model the data and how we are forced to store it to the relational database.



## Using RavenDB as a key/value store