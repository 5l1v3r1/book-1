
# RavenDB concepts

We have a running instance of RavenDB, and we have already seen how we can put and get information out of our database. But we are still only just scratching the surface of what we need to know to make effective use of RavenDB. In this chapter, we'll go over the major concepts inside RavenDB. 

The first step along the way is to understand what documents _are_.

## Entities, Aggregate Roots and Documents

When using a relational database, you are used to using Entities (hydrated instances of rows from various tables) that makes up a single Aggregate Root. There is also the relatively minor concept of Value Objects, but those tend to be underused, because you _have_ to have a distinct identity for many things in your domain that don't really require it. The classic example is the order line. It has no independent existance, and it must be modified in concert with the whole order.
Yet, in a relational database, an order line must have its own primary key, and it is entirely feasible to change an order independently of the order it is associated with.

We'll dedicate Chapter 4, Document based modeling, for a full discussion on modeling behavior inside RavenDB, but here are the basics. In RavenDB, every document is an Aggregate Root. In fact, we generally don't even bother calling them Aggregate Roots, and just call them Entities. The distinction between an Aggregate and an Entity is only there because of the limitations of relational databases.

An Entity is-a document, and it isn't limited to simple structures such as a key/value map. You can model very complex structures inside a document. In the order and order line case, we'll not model the order and order lines independently. Instead, the order lines will be _embedded_ inside the order. Thus, whenever we want to load the order, we'll get all of the order lines with it. And modification to an order line (be it updating, removing or adding) is a modification to the order as a whole, as it should be.

The order line is now a Value Type, an object that only has meaning within its parent object, not independently. This has a lot of interesting implications. You don't have to worry about Coarse Grain Locking^[You might notice a lot of terms from the Domain Driven Design book used here, that is quite intentional. When we created RavenDB, we intentionally made sure that DDD applications would be a natural usecase for RavenDB.] or partial entity updates. Rules like external references should only be to aggregates are automatically enforced, simply because documents _are_ aggregates, and they are the only thing you can reference.

Documents are independent and coherent. What does those mean? When designing the document structure, you should strive toward creating a document that can be understood in isolation. You should be able to perform operations on a document by loading that single document and operating on it alone. It is rare in RavenDB to need to reference additional documents during write operations. That is enough modeling for now, we'll continue talking about that in the next chapter. Now we are going to go beyond the single document scope, and look at what a collection of documents are.

## Collections

On the face of it, it is pretty easy to explain collections. See Figure 1 as a good example.

![The collections in the Northwind database](.\Ch03\Figure01.png)

It is tempting to think about collections as a set of documents that has the same structure and are stored in the same location. That is not the case, however. Two documents in the same collection can be utterly different from one another in their internal structure. See Figure 2 for one such example.

![Two differently structured documents in the Users collection](.\Ch03\Figure02.png)

Because RavenDB is schemaless, there is no issue with doing this, and the database will accept and work with such documents with ease. This allow RavenDB to handle dynamic and user generated content without any of the hard work that is usually associated with such datasets. It is pretty common to replace EAV^[Entity-Attribute-Value schemas, the common way to handle dynamic data in relational databases. Also notorious for being hard to use, very expensive to query and in general a trouble area you don't want to go into.] systems with RavenDB, because it make such systems very easy to build and use.

RavenDB stores all the documents in the same physical location, and the collection assoication is actually just a different metadata value. The `Raven-Entity-Name` metadata value controls which collection a particular document will belong to. Being a metadata value, it is something that is fully under you control. 

> Collections & document identifiers
> 
> It is common to have the collection name as part of the document id. So a document in the Products collection will have the id of `products/`. That is just a convention, and you can call have a document in the Products collection (because its metadata has the `Raven-Entity-Name` value set to 'Products') while it has the name 'bluebell/butterfly'.

RavenDB does use the collections information to optimize internal operations. Changing the collection once the document is created is _not_ supported. If you need to do that, you'll need delete the document and create it with the same id, but a different collection.

We've talked about the collection value in the metadata, but we have actually talked about what _is_ the metadata. Let talk meta.

## Metadata

The document data is composed of whatever it is that you're storing in the document. For the order document, that would be the shipping details, the order lines, who the customer is, the order priority, etc.
But you also need a place to store additional information, not related to the document itself, but _about_ the document. This is where the metadata comes into place.

The metadata is also a JSON format, just like the document data itself. However, there are some limitations. The property names follow the HTTP Headers convention of being Pascal-Cased. In other words, we separate words with a dash and the first letter of each word is capitalized, everything else is in lower case. This is enforced by RavenDB.

RavenDB uses the metadata to store several pieces of information about the document that it keeps track of:

* The collection name - stored in the `Raven-Entity-Name` metadata property.
* The last modifed date - stored in the `Last-Modified` metadata property^[This is actually stored twice, once as `Last-Modified` and once as `Raven-Last-Modified`, the fisrt is following the RFC 2616 format and is only accurate to the second. The second is accurate to the millisecond.].
* The client side type - stored in the `Raven-Clr-Type` metadata property.
* The etag - stored in the `@etag` metadata property, and discussed at legnth later in this chapter.

You can use the metadata to store your own values, for example, `Last-Modified-By` is a common metadata property that is added when you want to track who changed a document. From the client side, you can access the document metadata using the following code:

	Product product = session.Load<Product>("products/1");
	RavenJObject metadata =  session.Advanced.GetMetadataFor(product);
	metadata["Last-Modified-By"] = currentUser.Name;

It is important to note that there will be no extra call to the database to fetch the metadata. Whenever you load the document, the metadata is fetched as well. In fact, we usually need the metadata to materialized the document into an entity.

Once you have the metadata, you can modify it as you wish, as seen in the last line of code. The session tracks changes to both the document and its metadata, and changes to either one of those will cause the document to be updated on the server once `SaveChanges` has been called.

Modifying the metadata in this fashion is possible, but it is pretty rare to do so explicitly in your code. Instead, you'll usually use listeners to do this sort of work.

## Listeners

It is pretty common to want to run some code whenever something happens in RavenDB. The classic example is when you want to store some audit information about who modified a document. In the previous section, we saw that we can do that manually, but that is both tedious and prone to errors or ommisions. It would be much better if we could do it in a single place.

That is why the RavenDB Client API has the notion of listeners. Listeners allows you to define, in a single place, additional behavior that RavenDB will execute at particular points in time. RavenDB has the following listeners:

* `IDocumentStoreListener` - called when an entity is stored on the server.
* `IDocumentDeleteListener` - called when a document is being deleted.
* `IDocumentQueryListener` - called before a query is made to the server.
* `IDocumentConversionListener` - called when converting an entity to a document and vice versa.
* `IDocumentConflictListener` - called when a replication conflicted is encountered, this listener is discussed in depth in Chapter 10, Replication.

The store and delete listeners are pretty obvious. They are called whenever a document is stored (which can be a new document or an updated to an existing one) or when the document is deleted. A common use case for the store listener is as an audit listener, which can record which user last touched a document. A delete listener can be used to prevent deletion of a document based on your business logic, and a query listener can modify any query issued.

You can see examples of all three in Listing 1.

```{caption="{Store, Delete and Query listeners}" .cs }  
public class AuditStoreListener : IDocumentStoreListener
{
	public bool BeforeStore(string key, 
		object entityInstance, RavenJObject metadata, 
		RavenJObject original)
	{
		metadata["Last-Modified-By"] = WindowsIdentity
			.GetCurrent().Name;
		return false;
	}

	public void AfterStore(string key, 
		object entityInstance, RavenJObject metadata)
	{
	}
}

public class PreventActiveUserDeleteListener : 
	IDocumentDeleteListener
{
	public void BeforeDelete(string key, 
		object entityInstance, RavenJObject metadata)
	{
		var user = entityInstance as User;
		if (user == null)
			return;
		if (user.IsActive)
			throw new InvalidOperationException(
				"Cannot delete active user: " +
				 user.Name);
	}
}

public class OnlyActiveUsersQueryListener : 
	IDocumentQueryListener
{
	public void BeforeQueryExecuted(
		IDocumentQueryCustomization queryCustomization)
	{
		var userQuery = queryCustomization as
			IDocumentQuery<User>;
		if (userQuery == null)
			return;
		userQuery.AndAlso().WhereEquals("IsActive", true);
	}
}
```
In the `AuditStoreListener`, we modify the metadata to include the current user name. Note that we return `false` from the `BeforeStore` method as an indication that we didn't change the `entityInstance` parameter. This is an optimization step, so we won't be forced to re-serialize the `entityInstance` if if wasn't changed by the listener.

In the `PreventActiveUserDeleteListener` case, we throw if an active user is being deleted. This is very straightforward and easy to follow. It is the case of `OnlyActiveUsersQueryListener` that is interesting. Here we check if we are querying on users (by checking if the query to customize is an instance of `IDocumentQuery<User>`) and if it is, we also add a filter on active users only. In this manner, we can ensure that all user queries will operate only on active users.

We register the listeners on the document store during the initialization. Listing 2 shows the updated `CreateDocumentStore` method on the `DocumentStoreHolder` class.

```{caption="Registering listeners in the document store" .cs }   
private static IDocumentStore CreateDocumentStore()
{
	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind",
	};

	documentStore.RegisterListener(
			new AuditStoreListener());
	documentStore.RegisterListener(
			new PreventActiveUserDeleteListener());
	documentStore.RegisterListener(
			new OnlyQueryActiveUsers());

	documentStore.Initialize();
	return documentStore;
}
```

Once registered, the listeners are active and will be called whenever their respected action occur. 

The `IDocumentConversionListener` allows you a fine grained control over the process of the conversion process of entities to documents and vice versa. If you need to pull data from an additional system when a document is loaded, this is usually the place where you'll put it^[That said, pulling data froms secondary sources on document load is frowned upon, documents are coherent and independent. You shouldn't require additional data, and that is usually a performance problem].

A far more common scenario for conversion listener is to handle versioning, whereby you modify the old version of the document to match an update entity definition on the fly. This is a way for you to do rolling migrations, without an expensive stop-the-world step along the way.

While the document conversion listener is a great aid in controling the conversion process, if all you care about is the actual serialization, without the need to run your own logic, it is probably best to go directly to the serializer and use that.

## The Serialization Process

RavenDB uses the [Newtonsoft.JSON](http://james.newtonking.com/json) library for serialization. This is a very rich library with quite a lot of options and levers that you can tweak. 
Because of version incompatibilities between RavenDB and other libraries that also has a dependeny on Newtonsoft.JSON, RavenDB has internalized the Newtonsoft.JSON library. 
To access the RavenDB copy of Newtonsoft.JSON, you need to use the following namespace: `Raven.Imports.Newtonsoft.Json`. 

Newtonsoft.JSON has several options for customizing the serialization process. One of those is a set of attributes (`JsonObjectAttribute`, `JsonPropertyAttribute`, etc). Because RavenDB has its own copy, it is possible to have two sets of such attributes. One for serialization of the entity to a doucment in RavenDB, and another for serialization of the document for external consumption.

Another method of customizing the serialization in Newtonsoft.JSON is using the `documentStore.Conventions.CustomizeJsonSerializer` event.
Whenever a serializer is created by RavenDB, this event is called and allow you to define the serializer's settings. You can see an example of that in Listing 3.

```{caption="Customizing the serialization of money" .cs }   
DocumentStoreHolder.Store.Conventions
	.CustomizeJsonSerializer += serializer => 
	{
		serializer.Converters.Add(new JsonMoneyConverter());
	};

public class JsonMoneyConverter : JsonConverter
{
	public override void WriteJson(JsonWriter writer, 
		object value, JsonSerializer serializer)
	{
		var money = (Money) value;
		writer.WriteValue(money.Amount + " " + money.Currency);
	}

	public override object ReadJson(JsonReader reader, 
		Type objectType, object existingValue, 
		JsonSerializer serializer)
	{
		var parts = reader.ReadAsString().Split();
		return new Money
		{
			Amount = decimal.Parse(parts[0]),
			Currency = parts[1]
		};
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof (Money);
	}
}

public class Money
{
	public string Currency { get; set; }
	public decimal Amount { get; set; }
}
```
The idea in Listing 3 is to have a `Money` object that holds both the amount and the currency, but to serialize it to JSON as a string string property. So a `Money` object reprensenting 10 US Dollars would be serialized to the following string: "10 USD".

The JsonMoneyConverter converts to and from the string representation, and the json serializer customization event register the converter with the serializer. Note that this is probably not a good idea, and you will want to store the `Money` without modifications, so you can do things like sum up order by currentcy, or actually work with the data.

I would only consider using this approach as an intermediary step, probably as part of a migration if I had two versions of the application working concurrently on the same database.

## Document Identifiers

A document id in RavenDB is how we identify a single document from all the rest. They are the moral equivalent for the primary key in a relational system. Unlike a primary key, which is unique per table, all the documents in a database share the same key space^[Remember, collections are a virtual concept]. 

> Identifiers terminology
> 
> Document identifiers are also called document keys, or just ids or keys. In the nomenclature of RavenDB, we use both keys and ids to refer to a document id.

### Don't use Guids

Therefor, it follows that one of the chief requirements of the document ids is that they would be unique. This turn out to be a not so trivial problem to solve. A simple way to handle that is to use a Guid, such as this one:

	92260D13-A032-4BCC-9D18-10749898AE1C

It is entirely possible to use Guids as document identifers in RavenDB. But it is also possible to to drive to work on a unicycle. Possible doesn't mean advisable. Guids are used because they are easy to generate, but they suffer from weaknesses when it comes to their use as a unique identifier, they are relatively big compare to other methods and are nonsequential.

Those two means that it is easy to get a database into a situation where it has to do a _lot_ more work just to get data in when you are using a Guid. But that isn't their chief problem. The problem is that they are utterly opaque to humans. We often use identifiers for many purposes. Debugging and trouble shooting are not the least of those.

And having to look at 92260D13-A032-4BBC-9D18-10749898AE1C and see what did we do with it along the way is not a realy good way to spend your time. If you ever had to read a Guid over the phone, or keep track of multiple Guids in a log file, or just didn't realize that the Guid in this paragraph and the Guid higher up in the page aren't in fact he same Guid...

Guids aren't good for us. And by us, I mean humans.

### Human readable identifiers

A much better alternative is the default approach used by RavenDB, using the collection name as a prefix with a numberic id to distigiush different documents. You've already seens examples of this default approach. We have "products/1", "orders/15", etc.

This approach has several advantages. It tend to generate small and sequential keys, and most importantly, these type of keys are human readable and easily understood.

The question now is, how do we get this numeric suffix? 

### High/low algorithm

The problem with generating unique values is that you might not be the only one that want to generate them at this particular moment in time. So we have to ensure that we don't get duplicates.

One way to do that is to use a single source for id generation, which will be responsible for never handing out a duplicate value. RavenDB supports that option, and you can read about it in the next section, Identity.
However, such an approach requires going to the same source each and every time that we need to generate an identifier. 

The default approach used by RavenDB is quite different. We use a set of documents call the hilo documents. Here is a list of those documents in the Northwind database:

* Raven/Hilo/categories
* Raven/Hilo/companies
* Raven/Hilo/employees
* Raven/Hilo/orders
* Raven/Hilo/products
* Raven/Hilo/regions
* Raven/Hilo/shippers
* Raven/Hilo/suppliers

Those are pretty trivial documents, they all have just a single property, `Max`. That property's value is the maximum possible number that has been generated (or will be generated) for that collection.
When we need to generate a new identifier for a particular collection, we fetch that document and get the current max value. We then add to that max value and update the document.

We now have a range, between the old max value and the updated max value. Within this range, we are free to generate identifier with the assurance that no one else can generate such an identifier as well.

The benefit of this approach is that this also generate roughly sequential keys, even in the presence of multiple clients generating identifiers concurrently.

#### Self optimizing

The basis of the hilo algorithm is that a client that needs to generate 10 ids, it can take a range of 10 when it communicate with the server. From then on, it can generate those ids independently from the server until it runs out of ids.

Of course, you usually don't know upfront how many ids you'll want to generate, so you guess. By default, we use 32 as the default range, but the nice thing about the hilo approach is that it is the client that control how much to take.

Remember how we said that RavenDB is self optimizing? Here is one such case. When the client runs out of the reserved id range, it has to go back to the server to get a new reserved range. When it does so, it checks to see how much time has passed since the last time it had to go to the server. If the time is too short, that is an indication that we are burning through a lot of ids. In order to reduce the number of remote calls, the client will then request a range twice as big as before.

In other words, we start by requesting a range of 32. We consume that quickly, and we request a range of 64, and so on. Very quickly, we find the balance where we don't have to go to the server too often to get new ids. 

The actual mechanics are a bit more complex, because we scale up higher than just by a power of two in practice. We also have the ability to reduce the size of the range we request if we aren't going through the range fast enough. 

The actual details of how it works is not part of the algorithm, those are internal implementation optimization detail. But it is important to understand the benefits that you get when using this.

#### Concurrency

So far, we talked about hilo as if there was just a single client talking to the server. The question is, what happens when there are two clients requesting a range in the same time.

> Requesting a hilo range
>
> While the terminology we use is "requesting a range", the RavenDB server isn't actually aware of the hilo protocol in any meaningful way. Requesting a range is a process that involved loading the document, updating the Max value and saving it back. 
> 
> Aside from those basic operations, all the behavior for hilo is implemented client side.

As you'll see toward the end of the chatper, RavenDB supports optimistic concurrency, and the hilo protocol takes advantage of this. When we save the document back after raising the Max value, we do so in a way that would throw a `ConcurrencyException` if the document has been changed in the meantime. 
If we get this error, we retry the entire process from the beginning, fetching the document again, recording the current Max value, then saving with the new Max.

This way, we are protected against multiple clients overwriting one another's changes and generating duplicate ids.

#### Distributed hilo

Using the hilo algorithm, we only have to go back to the database once we run out of ids in the range we reserved. But what happens when we cannot contact that database? We'll touch on distribution model later on, in Part 3, Scale Out, but I do want to expand on how this relates to hilo at this time.

Assuming that we have a RavenDB cluster made of 3 nodes. We will configure each node to have its own uqnieu hilo prefix. This way, if the primary node is down, we can still reserve ranges, and we don't have to worry about reserving the same range as another client because of a network failover. 

We'll discuss such scenarios extensively in Part 3, for now, all you really care about is that you can use the hilo system in a cluster without worrying about a single point of failure.

#### Manual hilo

You don't need to do anything special to use the hilo algorith. It is what the RavenDB Client API does by default. It generate ids that have the following format:

* orders/13823
* products/7371
* PackageTracking/3824822^[When the entity name is composed of a single word, we'll default to lower casing it, when it is composed of multiple words, we'll presreve the casing.]

But sometimes you want to just have the numeric id and work with that. Maybe you are working with internal ids (see Chapter 5, Modeling) or using semantic ids (see a bit later in this chapter) but for whatever reason, you want to be able to generate those hilo values yourself. 

You don't need to start implementing everything from scratch. You can just write the following code:

	HiLoKeyGenerator hiloKeyGenerator = new HiLoKeyGenerator("tags", 8);
	long id = hiloKeyGenerator.NextId(documentStore.DatabaseCommands);

The `hiloKeyGenerator` instance should be a singleton, do _not_ try to create a new hilo whenever you need an id. That would require us to reserve a new range every time.
The `HiLoKeyGenerator` constructor accepts the hilo name and the initial size of the range. The actual size of the range will change, according to your actual usage. 

Most of the time, when we call `NextId`, we will never have to go to the server, we can just increment the internal value and as long as we are in range, we are good. This is effectively what the RavenDB Client API does for you, but we usually default to a range of 32.

You can use the generated id to do quite a lot of good, and you benefit from not having to go to the server all the time.

#### The downside for hilo

The hilo algorithm is the default approach for generating ids in RavenDB for a reason. It is simple, efficent, scalable and it generates very nice identifiers. _Is_ there a downside?
Of course there is, if only because someone ate my free lunch.

The one downside for hilo is that it can generate non consecutive ids. What do I mean by that? Let us assume that we need to save sevearl new orders. Using hilo, we generate the following ids for them: orders/65, orders/66, orders/67. Then we restart the application, and save some more orders.

Because hilo reserve a range, and there is no way to _unreserve_ part of that range, that means that this range has been lost. In this case, we reserved the range 65 - 96, but after generating just 3 such ids, we have been restarted. The range has been lost, and now we'll generate ids such as: orders/97, orders/98, etc. 

In practice, that isn't really a big downside. You might lost a few ids if the application restarted in production, but you'll likely not notice that. It is most often in development, where it is common to restart the application frequently, that people notice and wonder about this behavior.

But the actual reason that this isn't a big issue is that the ids that the RavenDB Client API generates aren't meaningful on their own. It doesn't actually matter if an order document's id is: orders/58 or orders/61. So skipping ids isn't something that we are generally need to concern ourselves with. When we do, we have the identity option.

### Identity

If you really need to have consecutive ids, you can use the identity option. Identity, just like in a relational database (sometimes called sequence) is a simple always incrementing value. Unlike the hilo option, you always have to go to the server to generate such a value. 

There are two ways to generate an identity value. The first is to do so implicitly, as shown in Listing 4. 

```{caption="{Using implicit identity}" .cs }  
using (var session = documentStore.OpenSession())
{
	var product = new Product 
	{
		Id = "products/", 
		Name = "What's my id?"
	};
	session.Store(product);
	Console.WriteLine(product.Id);
	// output: products/
	session.SaveChanges();
	Console.WriteLine(product.Id);
	// output: products/78
}
```

You can see that we actually define an id for the product. But a document id that ends with a slash (/) isn't allowed in RavenDB. We treat such an id as an indication that we need to generate an identity. That has an interesting implication. 

> How identities are stored?
> 
> Identities are stored^[This is a conceuptial description, the actual storage is quite different] as a list of tuples containing the identity key and the last value. This data is persistent.
> In other words, if you delete the latest document, you won't get the same id back. 

> As a result of that, identities are actually created lazily, the first time we need them, and the first value generated is always one and there is no way to set a different step size for identities. 
> This raises the question, what happens if we create a document with the id "products/1" manually, then try to save a document with the id "products/"?
> 
>  RavenDB is smart enough to recognize this scenario, and it will generate a non colliding id in an efficent manner. In this case, we'll get the id "prdocuts/2"

We don't go to the server until we are actually calling `SaveChanges`. That means that we don't know what the actual document id is until after we already got the reply from the server. That isn't fun, but on the other hand, we can save multiple documents using identity without having to go to the server for each of them individually.

The other way to use identities is to do so explicitly. You can do that using the following code:

	long nextIdentity = documentStore.DatabaseCommands
		.NextIdentityFor("invoices");

This allows you to construct the full document id on the client side. But it does require two trips to the database, one to fetch the identity value and the second to actually save it. There is no way to get multiple identity values in a single request. 

You can set the identity next value using this command:

	long nextIdentity = documentStore.DatabaseCommands
		.SeedIdentityFor("invoices", 654);

> Invoices, and other tax annoyances
> 
> For the most part, unless you are using semantics ids (covered later in this chapter), you souldn't care what your document id is. The one case you care is when you have an outside requirement to generate absolute consecutive ids. One such common case is when you need to generate invoices.
>
> Most tax authorities have rules about not missing invoice numbers, to make it just a tad easier to actual audit your system. But an invoice document's _identifier_ and the invoice _number_ are two very different things. 
> 
> It is entirely possible to have the document id of invoices/843 for invoice number 523.

#### The downsides for identity

There is no such thing as a free lunch, and identity also has its own set of drawbacks. Chief among them is that identities are actually not stored as a document. Instead, they are stored internally in a way that isn't quite so friendly.

That means that exporting and importing the database would _not_ also carry over the identities values. The identities values are also not replicated, so identity isn't suitable for use in a cluster. 

Finally, modifying an identity happens in a _seprate transaction_ than the current transaction. In other words, if we try to save a document with the name "product/", and the transaction failed, the identity value is still incremented. So even though identity generate consecutive numbers, it might still skip ids if a transaction has been rollbacked. 

Except for very specific requirements, such as an actual legal obligation to generate consecutive numbers, I would strongly recommend not using identity. Note my wording here, a legal obligation doesn't arise because someone want consecutive ids because they are easier to grasp. Identity has a real cost assoicated with it.

### Semantic ids

Document ids in RavenDB do not actually have to follow the "products/43" format. A document id can be any string up to 1,024 unicode characters^[That doesn't mean that is is a _good_ idea to have a very long document id, long document ids require us to allocate more resources and do a lot more work internally. Ideal document ids are pretty short.], so you have a lot more options here.

One common scenario where you want to generate your own semantic ids is when you want to ensure that something is unique. Let us say that we wanted to make sure that we had unique user names. We can do that by naming the users documents with the actual user names:

* users/ayende
* users/john83
* users/zebrrra

This does several things at once, it allows us to ensure that there can never be a duplicate user name as well as allow us to load the document easily given just the user name. What if we don't have a username in our system, but just use the email[^unique-constraints]? We use the same approach:

[^unique-constraints]: What happens when you want to have _both_ username and email unique? That is where the RavenDB Unique Constraint Bundle comes to the rescue. This is discussed in Chatper 11, Bundles.

* users/ayende@ayende.com
* users/john83@example.org
* users/zebrrra@endofworld.left

Another reason to want semantic ids is to generate ids such as "customers/483/transactions/2014-08-06". As you can probably tell, this document is for Customer #483 and it contains all the transactions for Aug 6, 2014. Semantic ids are important in the context of modeling, and are discussed in Chapter 5, Modeling. 

Generating a semantic id is just a matter of setting the `Id` property of the document before calling `Store`. 

### Working with document ids

By now, you have a pretty good idea about document ids, and how they work. But that was almost entirely a discussion on how the client and the server generate ids. We haven't talked about actually _working_ with them.

RavenDB uses the `documentStore.Convenions.FindIdentityProperty` convention to figure out where the document is stored on your entities. By default, that is a property (or field) named "Id" (case sensitive). We have already talked about how to customize that in the previous chapter.

You probably realized it, but it is important to mention it explicitly. Identifiers in RavenDB are strings. That surprises people coming from relational background, where they are used to ids just being integers (or evil guids). 

> Avoid `public int Id { get;set; }`
> 
> If you define your `Id` property as an integer (or long, or Guid), everything will work. However, under the covers, the document id is still a string. What happens is that the RavenDB Client API will pretend take your "products/328" document id, strip off the first part (because the convention says that it is the collection name) and stick the numeric part in the id.
> 
> This matches what a lot of people is familiar with from working with relational database, and this feature is provided solely to make it easier to migrate to RavenDB. The problem with this approach is that the id is still a string. And there is a limit to how well we can pretend that it is an integer.
> 
> This usually come up in the context of indexes or transformers, because those run on the server side, and we can't fake it out there. However, now you have a disconnect in your model, your client side code thinks it is an integer, and on the server side it is a string. Since indexes and transformers are actually defined on the client side, but executed server side, you can see how that would cause issues.

Given a document id, the most efficent way to get it to your hands is to `Load` it. Because it is a pretty common mistake to try to `Query` for a document id (which is several times more expensive), such an attempt is blocked and will throw^[You can set the convention option `AllowQueriesOnId` to allow that if you _really_ require this].

A document id cannot be changed once created, and attempt to associate two entity instances with the same document id, or attempt to change the document id on the entity once it was loaded or stored would result in an exception.

And that is quite enough about document identifiers. We'll now move to the other crucial piece of information that every document has, the ETag. 

## ETags

An etag in RavenDB is a 128 bits number that is associated with a document. 
Whenever a document is created or updated, an etag is assigned to that document. The etags are always incrementing, and they are heavily used inside RavenDB. Among their usages:

* Ensuring cache consistency
* Optimistic concurrency
* Indexing
* RavenDB replication
* Relational database replication
* Incremental exports

An etag is associated with the document metadata, so whenever you load the document, you also have the etag available for you. Retrieving the etag is easy, all you have to do is:

	Etag productEtag = session.Advanced.GetEtagFor(product);

On the client side, etags are used for optimistic concurrency control and for caching. We'll touch on optimistic concurrency in the next section, and caching is the section after that. I want to focus on how we are using etags on the server side.

> The structure of an ETag
>
> There is just one promise that we make about etags, and that promise is that they are always incrementing. Anything else is an implementation details. That said, it can be an _interesting_ implementation detail. Let us take a look at an etag: `01000000-0000-0001-0000-000000000EB6`.
> 
> This looks like a Guid, and indeed, this is a 128 bits number, which is using the Guid format convention because it is convenient. This is actually composed of the following parts:
>
> (@type) 01 
>
> (@restarts) 000000-0000-0001
>
> (@changes) 0000-000000000EB6
> 
> The first part is the etag type. 01 is etag for a document, this is the most common etag you'll run into. The second is the number of database restarts, this value is incremented by one every time the server restarts. In the case of our etag, it was generated on the first time the database was created.
>
> The last part is the number of changes that happened during the current database restart. All etags inside the same database restart period are consecutive. 
>
> There isn't really much cause for you to care about the actual content of an etag, but the question is raised often enough. Just remember that the details are _implementation details_, and might change in the future.

Because an etag is assigned to a doucment on every put^[RavenDB doesn't make a distinction between create or update.], and because etags are always incrementing, it is possible for RavenDB to iterate over documents in their _update_ order. So if I save products/1, products/2 and products/3 and then update products/1, when I'll iterate over them using the etag, I'll get results in the following order: products/2, products/3, products/1.

In fact, in the studio, when you are looking at all the documents, we default to sorting the documents by their last update. We do that by iterating over the documents in reverse update order, using the etags. But beyond the studio, iterating over the documents in update order turns to be _quite_ useful.

That is how RavenDB implements indexing and replication, among other features. The way it works is quite simple. We start from the empty etag (`00000000-0000-0000-0000-000000000000`) and ask the storage engine to give us all the documents that have an etag greater than that etag. RavenDB gives us a batch of documents to process. After we process those documents, we take the last document etag and remember it. Then we go back to the storage engine and ask us to give us all the etags after that etag. Rinse, repeat, and you have process through all the documents.

> ETags in distributed system
>
> An etag is only consistent within the node that defined it. RavenDB ensures that an etag is always incrementing within the node, but there is no coordination over etags in the cluster as a whole.

The reason that this works is that when a document is updated midway through this operation, we will see it again (because it etag was changed to a higher value). The actual behavior we have for indexing or replication is quite a bit more complex, but this is the basis for that. 

Now, let us see what other usages we have for etags...

## Optimistic Concurrency Control

What happens when we have two users that try to modify the same document at the same time? A document is a unit of change, and as such, trying to modify it concurrency is not allowed, so a `ConcurrencyException` will be thrown.
But actually managing to save the same document on the same instant to the server is pretty rare in most systems. Usually you are a lot more worried about the following scenario:

* John has loaded orders/3
* Martha has loaded orders/3
* John modify orders/3 and saves 

Optimistic Concurrency Control

## Caching

## Transformers

## Distributed Transactions

## Application databases vs. Organizational database