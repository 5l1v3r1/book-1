
# Document Modeling

Modeling your data is important, crucially so. This is because RavenDB, and any other database, really need you to understand 
how it is actually storing information, what are the features that it has available for you to utilize and what impact 
different modeling decisions will have on your data, the amount of work the database needs to do, etc.

If you get it wrong, you may be forcing the database to do expnonential amount of additional work. On the other hand, if you 
play for the database strengths, you can get a robust and easy to build system. So, overall, no pressure whatsoever.

Relational based modeling is so frequently encountered that is most cases you don't even see people talk about the relational
part, they just consider that as simple "data modeling". But when you try to apply a relational modeling solution to a non 
relational system, the end result is usually... suboptimal.

The problem is that this is extremely well entrenched behavior, to the point where most people don't even realize that they are
making choices and decisions based on what would work best for a relational database. So the first section of this chapter is 
going to deal with how to get away from the relational mindset, and then focus on how to model data for RavenDB.

## Beyond relational data modeling

You've very likely used a relational database in the past. That means that you've learned about normalization, and how 
important that is. Words like data integrity are thrown around quite often, usually. But the original purpose of normalization 
had everything to do with reducing duplication to the maximum extent.

A common example for normalization is addresses. Instead of storing a customer's address on every order that he has, we'll 
simply store the address id in the order, and we have saved ourselves the need to update the address in multiple locations. 
You can see a sample of such a schema in Figure 3.1.

![A simple relational schema for orders](./Ch03/img01.png)

You've seen (and probably wrote) such schemas before. And at a glance, you'll probably agree that this is a reasonable way to 
structure a database for order management. Now, let explore what happens when the customer wishes to change his address. The 
way the database is set up, we can just update a single row in the Addresses table. Great, we're done.

Except... we've just introduce a subtle but deadly data corruption for our database. If that customer had existing orders, 
both those orders and the customer information are all pointing at the same address. Updating the address for the customer 
therefor will also update the address for _all of its orders_. When we'll look at one of those orders, we'll not see the 
address that it was shipped to, but the _current_ customer address.

> **When a data modeling error means calling the police**
> 
> In the real world, I've seen such things happen with payroll systems and paystubs (payslips across the pond). An employee 
> had married, and changed her bank account information to the new shared bank account. The couple also wanted to purchase a 
> home, so they applied for a mortgage. As part of that, they had to submit paystubs from the past several months. That 
> employee requested that HR department send her the last few stubs. When the bank saw that there were paystubs made to an 
> account that didn't even existed at that time, they suspected fraud, the mortgage was denied and the police was called. An 
> unpleasant situation all around^[This ended up being sorted out eventually, by uttering the magic words: "Computer Error", 
> for what it is worth, but it was very exciting for a while there.].

The common response for showing this issue is that it is an issue of bad modeling decisions (and I agree). The problem is that 
a more appropriate model is more complex to build and work with, more expensive to query and harder to reason about in 
general. 

A lot of the widespread wisdom about data modeling is limited to only seeing the world through relational eyes. The relation 
model offers us the Tables, Rows and Columns to store our data, and it is up to us to hammer the data to the right shape so the 
relational database can accept it. Along the way, we have to deal with an impedance mismatch between how your software (and our 
minds) model the data and how we are forced to store it to the relational database.

A document database like RavenDB doesn't solve this problem completely, it is entirely possible to construct models that would 
be a poor fit for the way RavenDB store the data. However, the way most business applications (and in general OLTP systems) 
think about their data is a really good fit for RavenDB.

You can read more about that by looking at `Domain Driven Design`^[The 
[book]( https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) is a bit dry, but I remember 
being very impressed when I read it the first time.] and in particular, about the notion of an `Aggregate Root`.

> **What are aggregates?**
>
> One of the best definitions I have read is [Martin Fowler](https://martinfowler.com/bliki/DDD_Aggregate.html)'s:
>  
>> A DDD aggregate is a cluster of domain objects that can be treated as a single unit. An example may be an order and its 
>> line-items, these will be separate objects, but it's useful to treat the order (together with its line items) as a single 
>> aggregate.

>> An aggregate will have one of its component objects be the aggregate root. Any references from outside the aggregate should
>> only go to the aggregate root. The root can thus ensure the integrity of the aggregate as a whole.

In the context of RavenDB, this is highly relevant, since every RavenDB document is an aggregate, and every aggregate is a 
document. Modeling techniques for aggregates works really well for document oriented design, and that give you a great reasource
for modeling in the real world. 

But before we can start running, we need to learn to walk, so let us tart by learning how to use RavenDB with the most basic of 
modeling techniques, none.

## Using RavenDB as a key/value store

RavenDB is a document database, but it is also quite good at being just a key/value store. That is mostly accidental, but as 
part of making sure that we have a really fast database, we also significantly reduced the cost of just storing and loading 
documents without any of the other benefits of RavenDB.

With the restriction that the data must be JSON, using RavenDB as a key/value store make a lot of sense. It makes a lot of 
sense to use RavenDB to cache information, store the shopping cart during purchase process or just hold on to the user session 
data, all classic models for key/value stores.

RavenDB doesn't impose any additional costs on storing / loading documents by default, so you get to use very fast database 
with the simplest of all access models. Typical complexity in key/value modeling reside in generating the appropriate key, and 
what sort of operations you can do on it.

For the purpose of using RavenDB as a key/value store, the following features are probably most relevant:

* You can generate the document key independently of the collection used.
* Loading saved document(s) can be done in a single call, by providing the id(s) to load. 
* RavenDB provide automatic expiration for documents, which you can use with caching / session data.
* You can perform searches using the document key as a prefix (and even using glob like searches).
* Includes can be used to fetch related data without having to make multiple remote calls.

The nice thing about using RavenDB as a key/value store for such information is that you aren't _limited_ to just those 
key/value operations. If you are storing shopping cart data inside RavenDB, you can also start pulling data from there. If 
you want to know what is the most popular item currently being purchases across the board, or to do projections on inventory
or any of a whole host of things that would be useful to know.

In a typical key/value store (`Redis`, for example) you'll have to manually track such things, but RavenDB allows you to 
query and aggregate the data very easily.

But using RavenDB just for key/value data is somewhat of a waste, given what it is capable of doing with your data. So, without
further ado, let us dive into document modeling in RavenDB.

## Modeling considerations in RavenDB

The reason that we cover modeling on this chapter is that I wanted you to have the chance to get a feeling for some of 
RavenDB's capabilities before we start discussing modeling techniques. This is because the kind of features that RavenDB has
to offer are directly relevant to the models you'll write.

We typically encourage you to using DDD techniques for modeling in RavenDB, since they fit so well. A core design principle 
for modeling documents is that they should be: Independent, Isolated and Coherent.

* *Independent* - a document should have its own separate existence from any other documents. 
* *Isolated* - a document can change independently from other documents. 
* *Coherent* - a document should be legible on its own, without referencing other documents.

This is actually easier to explain using negation. A document is not independent if it can't stand up on its own. A good 
example of a dependent document would be the `OrderLine`. An order line doesn't really have a meaning outside the scope of 
and order, and it is not 