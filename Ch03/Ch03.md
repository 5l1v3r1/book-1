
# Document Modeling

Modeling your data is important, crucially so. This is because RavenDB, and any other database, really need you to understand 
how it is actually storing information, what are the features that it has available for you to utilize and what impact 
different modeling decisions will have on your data, the amount of work the database needs to do, etc.

If you get it wrong, you may be forcing the database to do expnonential amount of additional work. On the other hand, if you 
play for the database strengths, you can get a robust and easy to build system. So, overall, no pressure whatsoever.

Relational based modeling is so frequently encountered that is most cases you don't even see people talk about the relational
part, they just consider that as simple "data modeling". But when you try to apply a relational modeling solution to a non 
relational system, the end result is usually... suboptimal.

> **Documents are not flat**
>
> Documents, unlike a row in a relational database, are not flat. You are not limited to just storing keys and values. Instead, 
> you can store complex object graphs as a single document. That includes arrays, dictionaries and trees. Unlike a relational
> database, where a row can only contain simple values and more complex data structures need to be stored as relations,
> you donâ€™t need to work hard to map your data into a document database.
>
> That give you a major advantage and simplify a lot of the common tasks, as you'll see in this chapter. 

The problem is that this is extremely well entrenched behavior, to the point where most people don't even realize that they are
making choices and decisions based on what would work best for a relational database. So the first section of this chapter is 
going to deal with how to get away from the relational mindset, and then focus on how to model data for RavenDB.

## Beyond relational data modeling

You've very likely used a relational database in the past. That means that you've learned about normalization, and how 
important that is. Words like data integrity are thrown around quite often, usually. But the original purpose of normalization 
had everything to do with reducing duplication to the maximum extent.

A common example for normalization is addresses. Instead of storing a customer's address on every order that he has, we'll 
simply store the address id in the order, and we have saved ourselves the need to update the address in multiple locations. 
You can see a sample of such a schema in Figure 3.1.

![A simple relational schema for orders](./Ch03/img01.png)

You've seen (and probably wrote) such schemas before. And at a glance, you'll probably agree that this is a reasonable way to 
structure a database for order management. Now, let explore what happens when the customer wishes to change his address. The 
way the database is set up, we can just update a single row in the Addresses table. Great, we're done.

Except... we've just introduce a subtle but deadly data corruption for our database. If that customer had existing orders, 
both those orders and the customer information are all pointing at the same address. Updating the address for the customer 
therefor will also update the address for _all of its orders_. When we'll look at one of those orders, we'll not see the 
address that it was shipped to, but the _current_ customer address.

> **When a data modeling error means calling the police**
> 
> In the real world, I've seen such things happen with payroll systems and paystubs (payslips across the pond). An employee 
> had married, and changed her bank account information to the new shared bank account. The couple also wanted to purchase a 
> home, so they applied for a mortgage. As part of that, they had to submit paystubs from the past several months. That 
> employee requested that HR department send her the last few stubs. When the bank saw that there were paystubs made to an 
> account that didn't even existed at that time, they suspected fraud, the mortgage was denied and the police was called. An 
> unpleasant situation all around^[This ended up being sorted out eventually, by uttering the magic words: "Computer Error", 
> for what it is worth, but it was very exciting for a while there.].

The common response for showing this issue is that it is an issue of bad modeling decisions (and I agree). The problem is that 
a more appropriate model is more complex to build and work with, more expensive to query and harder to reason about in 
general. 

A lot of the widespread wisdom about data modeling is limited to only seeing the world through relational eyes. The relation 
model offers us the Tables, Rows and Columns to store our data, and it is up to us to hammer the data to the right shape so the 
relational database can accept it. Along the way, we have to deal with an impedance mismatch between how your software (and our 
minds) model the data and how we are forced to store it to the relational database.

A document database like RavenDB doesn't solve this problem completely, it is entirely possible to construct models that would 
be a poor fit for the way RavenDB store the data. However, the way most business applications (and in general OLTP systems) 
think about their data is a really good fit for RavenDB.

You can read more about that by looking at `Domain Driven Design`^[The 
[book]( https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) is a bit dry, but I remember 
being very impressed when I read it the first time.] and in particular, about the notion of an `Aggregate Root`.

> **What are aggregates?**
>
> One of the best definitions I have read is [Martin Fowler](https://martinfowler.com/bliki/DDD_Aggregate.html)'s:
>  
>> A DDD aggregate is a cluster of domain objects that can be treated as a single unit. An example may be an order and its 
>> line-items, these will be separate objects, but it's useful to treat the order (together with its line items) as a single 
>> aggregate.

>> An aggregate will have one of its component objects be the aggregate root. Any references from outside the aggregate should
>> only go to the aggregate root. The root can thus ensure the integrity of the aggregate as a whole.

In the context of RavenDB, this is highly relevant, since every RavenDB document is an aggregate, and every aggregate is a 
document. Modeling techniques for aggregates works really well for document oriented design, and that give you a great reasource
for modeling in the real world. 

But before we can start running, we need to learn to walk, so let us tart by learning how to use RavenDB with the most basic of 
modeling techniques, none.

## Using RavenDB as a key/value store

RavenDB is a document database, but it is also quite good at being just a key/value store. That is mostly accidental, but as 
part of making sure that we have a really fast database, we also significantly reduced the cost of just storing and loading 
documents without any of the other benefits of RavenDB.

With the restriction that the data must be JSON, using RavenDB as a key/value store make a lot of sense. It makes a lot of 
sense to use RavenDB to cache information, store the shopping cart during purchase process or just hold on to the user session 
data, all classic models for key/value stores.

RavenDB doesn't impose any additional costs on storing / loading documents by default, so you get to use very fast database 
with the simplest of all access models. Typical complexity in key/value modeling reside in generating the appropriate key, and 
what sort of operations you can do on it.

For the purpose of using RavenDB as a key/value store, the following features are probably most relevant:

* You can generate the document key independently of the collection used.
* Loading saved document(s) can be done in a single call, by providing the id(s) to load. 
* RavenDB provide automatic expiration for documents, which you can use with caching / session data.
* You can perform searches using the document key as a prefix (and even using glob like searches).
* Includes can be used to fetch related data without having to make multiple remote calls.

The nice thing about using RavenDB as a key/value store for such information is that you aren't _limited_ to just those 
key/value operations. If you are storing shopping cart data inside RavenDB, you can also start pulling data from there. If 
you want to know what is the most popular item currently being purchases across the board, or to do projections on inventory
or any of a whole host of things that would be useful to know.

In a typical key/value store (`Redis`, for example) you'll have to manually track such things, but RavenDB allows you to 
query and aggregate the data very easily.

But using RavenDB just for key/value data is somewhat of a waste, given what it is capable of doing with your data. So, without
further ado, let us dive into document modeling in RavenDB.

## Modeling considerations in RavenDB

The reason that we cover modeling on this chapter is that I wanted you to have the chance to get a feeling for some of 
RavenDB's capabilities before we start discussing modeling techniques. This is because the kind of features that RavenDB has
to offer are directly relevant to the models you'll write.

We typically encourage you to using DDD techniques for modeling in RavenDB, since they fit so well. A core design principle 
for modeling documents is that they should be: Independent, Isolated and Coherent.

* *Independent* - a document should have its own separate existence from any other documents. 
* *Isolated* - a document can change independently from other documents. 
* *Coherent* - a document should be legible on its own, without referencing other documents.

This is actually easier to explain using negation. A document is not independent if it can't stand up on its own. A good 
example of a dependent document would be the `OrderLine`. An `OrderLine` doesn't really have a meaning outside the scope of 
an `Order`, so it should be a `Value Object` inside the `Order` document. An `Entity` is defined as "a thing with distinct and 
independent existence". And that is how you treat documents, as entities. If a document exists only as a part of larger whole, the 
model should be refactor so that single large whole is a single document.

A documnet is not isolated if changing this document also requires updating additional document(s). For example, if you update the 
`CustomerBilling` document and also need to update the `Customer` document, they are not isolated.. A document should be able to 
change independently from other documents, otherwise, there is an unclear transaction boundary involved. With each document isolated, 
the transaction boundary (what can change together) is much clearer, it is drawn at the document level.

A document is not coherent if it is not possible to make sense of the document with just the information on that document. If you need
to go and lookup additional state or information from other documents, that document isn't coherent. A good example would be the 
`Order` document and the `ShippingMethod`. If, in order to ship an order, we need to go and look at the `Customer` document, then the
`Order` document is not coherent. 

### Looking at physical documents

A really good trick for document modeling is to consider the data as, well... documents. What I mean by that, _physical_ document, 
the kind that you actually hold up in your hand and can get a paper cut from. A lot of the same considerations that apply in the real
world apply for document modeling.

If I hand you a document and tell you that you need to fill up _this_ form, and then go and update _that_ form, you'll right consider 
the process (normal goverment behavior / bureaucratic / kafkaesque)^[Circle the approach choise]. If I gave you a form and told you 
that in order to understand it you had to consult this other document... you get my point.

When modeling, I find that it really helps when I'm picture the document in its printed form. If it make sense as a printed page, it 
is probably valid in term of document modeling.

### Denormalization and other scary beasts

Anyone taking a relational modeling course had the notion that "Store a Fact Only Once" as  just short of sacred (or maybe not so 
short). The basic idea is that if you store a fact only a single time, you are preventing update anomolies. Such as when you updated 
a person date of birth in the employee record, but forgot to update it on the "send a card" listing. 

I wholeheartedly agree with this statement, in principal. But the problem is that sometimes, this isn't the same fact at all, even if
it looks the same. Let us consider the notion of a `Customer`, `Order` and what the `Address` property means in this case. The 
`Customer` entity has an `Address` property, that holds the address of the customer, and the `Order` which has a `ShipTo` proeprty.

Why are we duplicating this information? The answer is that this isn't the same information, even if the content is the same. On the 
one hand, we have the `Customer.Address` which represent the _current_ customer's address. On the other hand, we have the 
`Order.ShipTo` which represent a _point in time_ copy of the customer address at the time we created the order. Those are very 
important distinctions. 

One of the more common objections to the kind of modeling advice in this chapter is that the data is denormalized. And that is true, 
but for the most part, even if the same data appears in multiple locations, it doesn't have the same semantic meaning. And the notion
of point in time data is quite important in many fields. 

RavenDB has quite a few features that help in working with normalized data (`LoadDocument` and transformers are the two main one, 
covered in [Part II](#map-indexes).), but you need to consider whatever it make sense to traverse document references in your model or
if you are breaking document coherency. 

The most useful question that you can ask yourself at that situation is whatever you are looking at the _current_ value (need 
normalization) or the _point in time_ value (use a copy).

And with all of this information now in our head, we can turn to looking at concrete modeling scenarios and how to deal with them.

## Common modeling scenarios 

Giving you advice on how to model your application is beyond the scope of this book. The DDD book is highly recommended in general, but it
isn't always the best choice. Proper DDD modeling takes a lot of discipline and hard work, and it is most appropriate only in specific 
parts of your system (typically the most highly valued ones). RavenDB doesn't have any requirement regarding how you would model your data 
in your application. You can use DDD, you can use business objects or data transfer objects - it doesn't matter to RavenDB. 

What matters is how you _structure_ the data inside RavenDB, and that is what we'll be talking about for the rest of this chapter. We'll 
focus on concrete scenarios, rather than generic modeling advice. Instead of trying to advice you on how to model your entire system, I'm g
going to focus on giving you the tools to build the model as you need it to, so it will play best with RavenDB.

To make things interesting, we are going to use a kindergarden as our data model. As you can expect, we have the notion of children, 
parents, registrations, etc. On the face of it, this is a pretty simple model, we can model it using the code in Listing 3.1.

```{caption="Simple kindergarden model" .cs}
public class Parent
{
	public string Name { get; set; }
}

public class Registration
{
	public DateTime EnrolledAt { get; set; }
	public EnrollmentType Type { get; set; }
}

public class Child
{
	public string Name { get; set; }
	public DateTime Birthday { get; set; }
	public Parent Father { get; set; }
	public Parent Mother { get; set; }
	public Registration Registration { get; set; }
}
```

The code in Listing 3.1 is obviously very simplified model, but it is a good place to start our discussion. A core tenant of modeling in 
RavenDB is that we need to identify what pieces of information belong together, and what pieces are independent of one another. Recall our
discussion on the basics of document modeling design. A good document model has documents that are Independent, Isolated and Coherent. 

With the basic model in Listing 3.1, and our understanding of a kindergarden, we can now proceed to explore aspects of document modeling, 
and we'll start with the most obvious one. In this model, we don't have documents, we _a_ document, just a single one per child. That is 
because we are embedding all information about the child in the document itself. Why would we do that?

### Embedded documents

A document model is very different from a relational model. It would be very typical in a relational model to have a separate table for 
each class showing in Listing 3.1. A concrete example might work better, and Listing 3.2 shows how this model works for registering Alice
to our kindergarden. 

```{caption="Kindergarden record of Alice in Wunderland" .json}
// children/alice-liddell
{ 	
	"Name": "Alice Liddell",
	"Birthday": "2012-05-04T00:00:00.0000000Z",
	"Mother": {
		"Name": "Lorina Hanna Liddell",
	},
	"Father": {
		"Name": "Henry Liddell"
	},
	"Registration":	{				   
		"EnrolledAt": "2014-11-24T00:00:00.0000000Z",
		"Type": "FullDay"
	}
}
```

All of the information is in one place. You can see that we used a semantic id, `children/` with the child name as the document id. This 
works quite well for data that is well known and predictable. The data itself is centrally located and easy to access. Looking at the data
it is easy to see all relevant infromation about our Alice^[Except maybe which rabbit hole she wondered down to...].

For the most part, embedding infomration is our default approach, because that lead us to more coherent documents, which contain all the 
information relevant to processing it. This is because we aren't limited by format of schema, we can represent arbitrarily complex data
without any issue, and we want to take full advantage of that.

So if the default approach is to embed data, when _wouldn't_ we want to do that? There are a few cases, primarily when we the data doesn't
belong to the same document because it is owned by another entity. A good document model give each document a single reason to change, and
that is the primary force for splitting document apart. 

In the case of the kindergarden record, the obvious example here are the parents. Henry and Lorina are independent entities, and are not 
fully owned by the Alice record. We need to split them into independent documents. On the other side of things, Henry and Lorina had more
children than just Alice, there were also Harry and Edith^[The real Harry and Lorina had a total of 
[10 children](https://en.wikipedia.org/wiki/Alice_Liddell), by the way. ]. So we need to consider how to model such information.

### Many to one relationship

How do we model a kindergarten where Alice, Harry and Edith are all the children of Henry and Lorina? The technical term for this 
relationaship is `many to one`. Unlike the previous example, where we embedded the parents inside the child document, now we want to model
the data so there is a distinct difference between the different entities. You can see the document model as JSON in Listing 3.3.

```{caption="Many to one modeling with children and parents" .json}
// children/alice-liddell
{
	"Name": "Alice Liddell",
	"MotherId": "parents/1923-A",
	"FatherId": parents/1921-A",
}

// children/henry-liddell
{
	"Name": "Henry Liddell",
	"MotherId": "parents/1923-A",
	"FatherId": parents/1921-A",
}
```

Listing 3.3 shows^[I removed all extra information from the documents to make it clearer.] both Alice and Henry (you can figure out how 
Edith's document looks like on your own) with references to their parents. 
I've intentionally not semantic ids for the parents, to avoid causing confusion about what information is stored on the side holding the
reference. Alice and Henry (and Edith) only hold the _identifier_ for their parents' documents, nothing else.

How does this model reflect in our code? Let's look at Listing 3.4 to see that (again, with some information redacted to make it easier
to focus on the relevant parts).

```
public class Child
{
	public string Name { get; set; }
	public string FatherId { get; set; }
	public string MotherId { get; set; }
}
```

Instead of storing the parent as an embedded document, we just hold the id to that parent. And when we need to traverse from the child
document to the parent document, we do that by following the id. To make things faster, we'll commonly use the `Include` feature to make
sure that we load all those documents in one remote call, but that doesn't impact the data model that we use.

What about the other side, when we need to find all of Lorina's children? Using a query, as shown in Listing 3.5.

```{caption="Loading Lorina and her children" .cs}
using(var session = store.OpenSession())
{
	var lorina = session.Load<Parent>("parents/1923-A");
	var lorinaChildren = (
	 	from c in session.Query<Child>()
		where c.MoethdId == lorina.Id 
		select c
	).ToList();
}
```

As you can see in Listing 3.4 and 3.5, we are being very explicit when we move between documents. RavenDB doesn't allow you to 
transparentely move between different documents, each document is a standalone entity. This help to ensure that you don't create silent
dependencies in your model, since each document is clearly delineated. 

> **Using lazy operations**
>
> In Listing 3.5 you can see that we have to make two separate calls to the server to get all the information we want. When going from
> a child to a parent, we can use the `Include` feature to reduce the number of calls. On the other way, `Include` wouldn't work, but we
> don't have to give up, we have the option of making a few lazy operations and only go to the server once. We'll see exactly how this is
> possible in the next chpater.

The many to one relation is probably the simplest one and it is incredibly common. However, when using it you need to carefully consider
whatever the association should cross a document boundary, or remain inside the document. In the case of parents and children, it is 
obvious that each is a separate entity, but orders and order lines are just the reverse. I the case of orders and order lines it is just
as obvious that order lines do _not_ belong in a separate document but should be part and parcel of the order document. 

There are many cases where that distinction isn't quite so obvious, and you need to give it some thought. The decision can be situational
and is frequently highly dependant on the way you _use_ the data. An equally valid decision in the kindergaden case would be to embed the
parents information in the child document, and just duplicate that infromation for the case where we have two or more siblings in the 
kindergarden a the same time.

It depend what kind of work is done with the parents. If all or nearly all the work is done with the children, then there is no point in 
creating a parent document (it isn't meaningful inside the domain of the kindergarden outside the scope of the children). However, if we 
wanted to keep track of parents as well (for example, Mrs. Liddell takes two sugars in her tea), then we'll likely use a separate 
document.

Children and parents are all well and good, but what about when we push the example up a bit, and explore the world of grandchildren and
grandparents? Now we need to talk about many to many relationships.

### Many to many relationship

A many to many relationship is a lot more complex than a simple many to one relationship, because they are usually used very differently. 
In our kindergarden example, let us consider how we can model the grandparents. Obviously, each child have multiple grandparents, and each
grandparent can have mutliple children. 

When working with parents and children, it was obvious that we needed to place the association on the children. But how should we model 
grandparents? One way to do it would be to simply model the hierarchy. So a grandparent is the parent of a parent. That seems elegant, 
since this is pretty much what it _is_, but it will lead to a poor model. Grandparents and grandchildren have association between them 
that is completely separated from the one going through the parent, and that deserved to be model on its own, not as a side affect.

The next question is where to put the relationship. We can add a `Grandparents` array to the child document, which will hold all the 
document ids of the grandparents. We can add a `Grandchildren` array to the grandparent document, and store the children ids there. Or
we can do both. What should we choose?

In the context of many to many associations, we always place the record of the assoication on the smaller side. In other words, since a 
child is likely to have fewer grandparents than a grandparent to have children, the assoication is going to be kept on the child 
document. 

> **The users and groups model**
>
> A more technical example that frequently come up within the context of many to many associations is the users & groups model. A user can
> belong to many groups, and a group can have many users. How do we model this? 
>
> A user typically belongs to a few groups, but a group can have a _lot_ of users. So we record the relationship on the smaller side by 
> having a `Groups` property on the user document.

Traversing a many to many association, from the grandchild (smaller) side, can be done by just including and loading the grandparents,
as showing in Listing 3.6.

```{caption="Alice and her grandparents" .cs}
using(var session = store.OpenSession())
{
	var alice = session
		.Include<Child>(c=>c.Grandparents)
		.Load("children/alice-liddell");
	var gradparents = session.Load<Parent>(alice.Grandparents);
}
```

Following the association from the other side requires us to query, as shown in Listing 3.7.

```{caption="Alice and her grandparents" .cs}
using(var session = store.OpenSession())
{
	var grandparent = session.Load<Parent>("parent/1923-A");
	var grandchildren = (
		from c in session.Query<Child>()
		where c.Grandparents.Contain(grandparent.Id)
		select c
	).ToList();
}
```

The code in Listing 3.7 will load Alice's mother and all of her grandchildren. In this case, we can see a slighly more complex query, but 
the essence of it remains the same as the one in Listing 3.5. We have separate documents and clear separation between them. In other 
words, we can query for related data, but we don't just traverse the object graph from one document to another.

### One to one relationship

A one to one relationship is a pretty strange sight. If there is a one to one relationship, shouldn't this be an embedded document, 
instead of having a separate document? Indeed, in nearly all cases, that would be a better idea.

There are a few reasons why I would want to store a part of a document in a separate document. Usually this is the case if we have a 
document that is conceptually the same, but it has very different access patterns. In the order example, we might have the order header, 
which is very frequently accessed and looked at. And then there is the full order, which might be very big (lots of line items) which we
don't need to access very often. 

In that case, it might make sense to create a document just for the order header (call it `orders/2834/header`). But using a transformer
will be almost as good (we discuss them in [Chapter 18](#advanced-indexes)) and save us the need to split our data. The typical way you'll
build one to one relationship in RavenDB is to utilize document id postfixes to create a set of related documents (`orders/2834` and 
`orders/2834/header`, for example).

This tend to result in clearer intent, since it is obvious what each part is doing and what it is meant to be, but even so, that is often
not something that would be advisable. Just putting it all in a single document is easier in most cases.

## Advanced modeling scenarios

The RavenDB modeling techniques that we explored so far are very good in modeling standard business data. You know how to build you 
entities, how to deal with relationship between them (and how to identify whatever they should be separate documents or nested in the same
document). But there is also a lot of sophistication that we can apply to non standard scenarios, which is the topic of this section.

### Reference data

Reference data is very common, it can be anything from a list of states to the tax rates to localized text to dispaly on the screen. The 
common thread for reference data is that it is typically small and not really interesting in isolation. Such data gets interesting when 
you start working with the lot of them.

It is typical to ignore the modeling concerns for such items, and just throw them in a pile somewhere and not give it any thought. With 
the list of states example, the most natural way to do that is to define a document whose id is `states/ny` and has a single `Name` 
property whose value is obviously `New York`. That would _work_, but it is hardly the best method to go about it. 

Going back to basic principles, such a document will hardly be coherent or independent. Indeed, such a document make very little sense on 
its own. Instead of storing each state and each configuration value as its own document, we'll raise the bar a bit and introduce 
configuration documents. You can see the example in Listing 3.8.

```{caption="Storing the states list as a configuration document" .json}
// config/states
{
    "AL": "Alabama",
    "AK": "Alaska",
    "AS": "American Samoa",
    ...
    ...
    "WV": "West Virginia",
    "WI": "Wisconsin",
    "WY": "Wyoming"
}
```

Modeling reference data in the manner shown in Listing 3.8 has several advantages. It is much easier to work with the data. Instead of 
issuing a query, we can just load the document in one shot, and it is already ready for our consumption. It means that the database has to
do less work, and it plays very nicely into the way RavenDB cache data. It also means that we can reduce deserialization costs, nad make 
it easier to edit and work with the reference data.

In fact, because this is a single document, we can also get RavenDB to do some tasks for us, such as versioning. We'll discuss that in 
more detail in ??XYZ_XYZ??, but RavenDB has builtin versioning capability, which can be _very_ useful when you are talking about reference
or configuration data, since it is easy to look and see what were the changes (or revert them).

### Hierarchical information

Working with hierarchical data is complex because there are cases where you need to traverse the hierarchy, and that traditionally has 
been expensive. In many cases hierarchies are recursive and often have no limits to the number of levels (although in practice the number
is usually known to be small). 

We need to make a distinction between several types of hierarchies. The first one is quite simple, and can comfortably fit into a single 
document. Typical example of such a hierarchy are comments in a discussion thread. The entire thread is a single document, and all the
comments in the thread always reside in that document. In such a case, storing and working with the hierarchical nature of the data is 
quite trivial, since you'll often just traverse the data directly after loading the document from the server. 

A common example of a hierarchy that doesn't fit the 'everything in a single document' model would be the company hierarchy. Each employee
is an independent entity and we can't store them all as a single document. Instead, we'll strive to model the hierarchy explcitly as an 
independent concept from the employees. In this case, we'll have the notion of a `department`, which will record just the chains of who
reports to whom. The idea is that we separate the hierarchy out since the position of an employee in the hierarchy is orthogonal to most
aspects of the employee. 

The notion of separated hierarchy document gives us a lot of simplicity. Hierarchical operations and queries (all direct and indirect 
reports, for example) are very easy and natural, and it plays nicely with caching and the use of `Include`.

The final example for modeling hierarchies in RavenDB is when we need to model the hierarchy directly in the model. Departments in an 
organization might be a good example, their location in the hierarchy is very important to what they are. In this case, we'll typically
model such a relationship as many to one or many to many relationships at each individual level. That is the simplest method to handle
such a requirement.

This works as long as we need to handle just a single level, but it doesn't handle hierarchial queries. Finding all the departments under
`R&D`, regardless if they are directly or indirectly attached. This requires a bit more work, since we'll need to define indexes that are
able to walk through the hierarchy. We haven't talked about complex operations in indexes, so I'll just mention that RavenDB's indexes can
use `Recurse` to work with hierarchical data and leave that topic to [Chapter 18](#advanced-indexes), where we'll cover it in depth.

### Temporal data model

Temporal data is often a challenge, because it can really mess with the way you think about information. Despite the fancy name, temporal
data is just a way to store data that has a relation to time. The best example I've seen for temporal data is payroll. Consider the notion
of a paycheck. An employer and employee have a contract stipulating that for a given amount of work, a given amount of money will be 
exchanged. 

The problem is that this contract can _change_ over time. An employee can get a raise, have additional vacation days, better overtime 
terms or all of the above. For extra fun, you may get some of those changes retroactively. This sort of thing make it hard to figure out 
exactly what you are supposed to do (consider the case of terms change midmonth, and how you'll handle overtime calculation on a 
shift between 8 PM and 4 AM that fall in that switch). 

The way to model temporal data in RavenDB is to embrace the document nature of RavenDB fully, especially because in most temporal 
domains, the notion of documents and view over time is so important. Consider a paystub that was issued on May 1st, and then a retroactive
pay raise was given. How is that money counted? It is easy to see that when we model the data as physical documents, we don't try to model
a paystub as a mutable entity, but a point in time view. Any changes that were made during the time frame it covered will be reflected in 
the _next_ paystub.

This approach make it much easier on yourself, you don't have to keep track on valid time, effective time and bitemporal time, all at 
once. You just store facts, and the time in which they were stored. Just as if you were keeping all your printed paystubs as a drawer 
somewhere.

The same apply to contracts and other things that mutate over time. Consider the documents seen in Figure 3.2, they represent the same 
contract, with modifications over time as things change.

![Contract documents and changes over time](./Ch03/img02.png)

The key aspect is that when we consider references to this contract, we can select what _kind_ of refence we want. When looking at the 
employee's record, we'll have a referecnce to `contracts/hourly/1234-A`, which is the current version of the contrac, but when issuing
a paystub, we'll always reference a fixed revision of this contract such as `contracts/hourly/1234-A/2013-05-21`. This way, we have set
ourselves up so we choose whatever we want the point in time information or the current (continously updated) version. 

If this sounds similar to the way we decide if we'll copy data from another document to get a point in time snapshot to it or reference it
by id to always get the latest data, that is probably because it _is_ similar. And it simplify dealing with temporal data significantly.

### Handling unbounded growth 

### Cached queries properties

